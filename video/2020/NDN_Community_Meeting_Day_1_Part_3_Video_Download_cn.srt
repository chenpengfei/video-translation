1
00:00:01,660 --> 00:00:02,160
好的。

2
00:00:02,160 --> 00:00:04,270
欢迎大家回来。

3
00:00:04,270 --> 00:00:08,320
这是海报和演示环节。

4
00:00:08,320 --> 00:00:12,548
这个环节我们有七场讲座。

5
00:00:12,548 --> 00:00:17,728
每位演讲者将有大约三分钟的时间进行演讲，之后，

6
00:00:17,728 --> 00:00:23,340
我们将在不同的BlueJeans房间进行实际的海报和演示会议。

7
00:00:24,770 --> 00:00:28,254
第一场演讲是由时俊霄进行的

8
00:00:28,254 --> 00:00:33,109
NDNts 命名数据网络库，适用于现代网络。

9
00:00:33,109 --> 00:00:37,567
Junxiao 目前在 NIST 工作，他的博士学位来自于

10
00:00:37,567 --> 00:00:42,890
Junxiao 目前在 NIST 工作，他的博士学位来自于亚利桑那大学，目前是 NIST 的一名研究员。他是核心的 NDN 开发者，并且一直在开发 NDN 网络转发器。

11
00:00:42,890 --> 00:00:48,583
他是核心的 NDN 开发者，并且一直在开发 NDN 网络转发器。

12
00:00:48,583 --> 00:00:52,401
最近他在开发 NBN dpdk 转发器。

13
00:00:52,401 --> 00:00:55,251
继继续吧。

14
00:00:55,251 --> 00:00:56,834
>> 下一页。

15
00:00:56,834 --> 00:00:58,108
你好，我是石俊霄。

16
00:00:58,108 --> 00:01:04,690
今天我将介绍我的个人项目NDNts：适用于现代网络的NDN库。

17
00:01:04,690 --> 00:01:05,190
~!@#$%^&*()

18
00:01:07,285 --> 00:01:11,228
NDNts是一套现代的JavaScript库集。

19
00:01:11,228 --> 00:01:16,810
它同时兼容TypeScript和JavaScript项目。

20
00:01:16,810 --> 00:01:20,855
它可以同时在Node.js和浏览器环境中运行，

21
00:01:20,855 --> 00:01:26,460
我们拥有良好的测试覆盖率，以及自动化和手动的浏览器测试。

22
00:01:26,460 --> 00:01:32,590
NDNts库可以独立运行，无需使用转发器或

23
00:01:32,590 --> 00:01:37,870
如果您选择，它可以连接到NFD或NDN-DPDK转发器。

24
00:01:37,870 --> 00:01:43,559
最重要的是，NDNts项目正在积极维护，新功能正在不断推出。

25
00:01:43,559 --> 00:01:49,261
添加到库中的内容大多数都是最新的，我们支持最新的NDN规范。

26
00:01:49,261 --> 00:01:49,761
下一页。

27
00:01:53,270 --> 00:01:56,126
在支持海报演示会议期间，

28
00:01:56,126 --> 00:01:59,559
我将展示一些端点API的代码示例。

29
00:01:59,559 --> 00:02:05,110
这是一个新的API设计，它是面部识别的一个更好的版本。

30
00:02:05,110 --> 00:02:08,581
在左侧是当前面部的特征。

31
00:02:08,581 --> 00:02:13,280
它只有一点点的渔夫特性，但是配合端点，它将会自动处理。

32
00:02:13,280 --> 00:02:18,055
自动兴趣重传、日期签名等几项功能，

33
00:02:18,055 --> 00:02:20,463
基于信任模式的验证。

34
00:02:20,463 --> 00:02:23,088
生产者端的数据缓冲，以及

35
00:02:23,088 --> 00:02:26,740
它还会自动处理传输错误。

36
00:02:26,740 --> 00:02:30,900
所以在应用程序中，你只需要专注于应用逻辑。

37
00:02:30,900 --> 00:02:31,400
下一页。

38
00:02:34,079 --> 00:02:35,148
在演示环节中，我还会展示一些代码示例。

39
00:02:35,148 --> 00:02:35,765
信任模式实现。

40
00:02:35,765 --> 00:02:41,471
所以，信任模式就是这种实现。

41
00:02:41,471 --> 00:02:46,687
受到了Casey去年演讲的启发

42
00:02:46,687 --> 00:02:51,257
受到了Casey去年演讲的启发，多功能安全工具包。Next Page.

43
00:02:51,257 --> 00:02:52,056
下一页。

44
00:02:54,950 --> 00:03:00,635
我将展示一个在线Web应用程序，它显示

45
00:03:00,635 --> 00:03:05,668
我将展示一个在线Web应用程序，它显示今天全球NDN测试床的NLSR状态。And there's a URL example on top right corner you can already try to look at it.

46
00:03:05,668 --> 00:03:06,799
右上角有一个URL示例，你可以尝试去查看一下。

47
00:03:06,799 --> 00:03:10,544
下一页。

48
00:03:14,182 --> 00:03:19,740
我将展示我的NDN证书管理协议的实现。

49
00:03:19,740 --> 00:03:23,081
这包括一个名为的Node.js网络应用程序

50
00:03:23,081 --> 00:03:28,460
NDNts个人证书颁发机构，以及一个指挥地客户端

51
00:03:28,460 --> 00:03:33,360
请求证书的NDNts认证管理协议。

52
00:03:33,360 --> 00:03:33,862
请翻到下一页。

53
00:03:40,067 --> 00:03:41,667
请翻到下一页。

54
00:03:45,267 --> 00:03:52,390
最后，我将展示一个家用民用摄像头的演示。

55
00:03:52,390 --> 00:03:55,960
两年前，我演示了这个应用程序的旧版本。

56
00:03:55,960 --> 00:03:58,000
它是基于NDNts编写的。

57
00:03:58,000 --> 00:04:02,640
但现在我已经用我新的库NDNts重建了这个应用程序。

58
00:04:02,640 --> 00:04:05,096
我还添加了一个屏幕录制功能，并且

59
00:04:05,096 --> 00:04:09,100
这将是一个在线演示，可以通过这个用户界面访问。

60
00:04:09,100 --> 00:04:09,840
好的，谢谢。

61
00:04:09,840 --> 00:04:14,074
我就说到这里，希望你能在会后加入我。

62
00:04:16,638 --> 00:04:17,840
>> 非常感谢你，俊霄。

63
00:04:18,860 --> 00:04:22,890
下一场演讲将由Alex Afanasyev主持。

64
00:04:22,890 --> 00:04:27,480
CertCoalesce：基于NDN系统的高效证书池。

65
00:04:27,480 --> 00:04:31,520
亚历克斯是佛罗里达国际大学的助理教授。

66
00:04:31,520 --> 00:04:35,632
他的主要研究重点是作为下一代架构的一部分

67
00:04:35,632 --> 00:04:38,489
他的主要研究重点是作为下一代架构的一部分，NDN项目，特别是可扩展性和基于名称的路由，自动配置autoconfiguration，

68
00:04:38,489 --> 00:04:42,254
基于名称的路由，自动配置autoconfiguration，

69
00:04:42,254 --> 00:04:47,084
分布式数据同步以及应用程序和网络安全。

70
00:04:47,084 --> 00:04:48,483
~!@#$%^&*()

71
00:04:48,483 --> 00:04:52,780
当然，所以你可能可以跳过我的演讲的标题幻灯片。

72
00:04:52,780 --> 00:04:55,230
继续前进。

73
00:04:55,230 --> 00:04:56,029
是的。

74
00:04:56,029 --> 00:04:58,000
所以基本上动机是

75
00:04:58,000 --> 00:05:02,810
这项工作是一个简单的假设，我们需要许多证书。

76
00:05:02,810 --> 00:05:07,430
例如，它需要被用来实现最小权限原则。

77
00:05:07,430 --> 00:05:11,736
分离，例如，我们有一种非常丰富的命名空间，

78
00:05:11,736 --> 00:05:16,513
您希望为该命名空间的各个部分拥有独立的键，

79
00:05:16,513 --> 00:05:20,383
像foo/bar/a、foo/bar/b等等。

80
00:05:20,383 --> 00:05:25,260
另一部分基本上是试图限制单个密钥的暴露。

81
00:05:25,260 --> 00:05:30,050
例如，如果证书的有效期大约是一年，

82
00:05:30,050 --> 00:05:33,400
那么你必须实施一些机制来撤销证书。

83
00:05:33,400 --> 00:05:36,642
如果你的有效期只有几分钟，

84
00:05:36,642 --> 00:05:40,812
那么你可能不需要额外的机制。

85
00:05:40,812 --> 00:05:41,740
下一张幻灯片，请。

86
00:05:43,858 --> 00:05:51,950
因此，在传统系统中的基本方法是使用某种方式

87
00:05:51,950 --> 00:05:57,230
在普通的证书系统中，一方会生成公钥对。

88
00:05:57,230 --> 00:06:00,570
当你想要获取证书时，你基本上是在请求证书。

89
00:06:00,570 --> 00:06:01,198
对于这对。

90
00:06:02,510 --> 00:06:07,110
理论上来说，你可以去找证书颁发机构或者

91
00:06:07,110 --> 00:06:11,190
证书颁发机构可以为相同的公钥重新颁发证书。

92
00:06:11,190 --> 00:06:16,370
但这并不是一个好主意，因为你想要限制单个密钥的暴露风险。

93
00:06:16,370 --> 00:06:18,360
这是一条基本原则。

94
00:06:18,360 --> 00:06:23,410
以及限制或者某种成果的种类，如果你想拥有大量的证书

95
00:06:23,410 --> 00:06:28,860
对于不同的命名空间或者大量不同种类的证书，

96
00:06:28,860 --> 00:06:34,440
对于不同的时间粒度来说，它既关系到网络开销也关系到存储需求。

97
00:06:34,440 --> 00:06:39,000
我在这项工作中基本上尝试做的是尝试进行一些

98
00:06:39,000 --> 00:06:44,750
在这项工作中，我基本上尝试做的是尝试进行一些优化，可能会有一些权衡，但还是试图进行一些优化。下一张幻灯片。

99
00:06:44,750 --> 00:06:45,450
所以下一张幻灯片。

100
00:06:50,010 --> 00:06:58,950
所以基本过程仍然是基于椭圆曲线密码学的，

101
00:06:58,950 --> 00:07:03,590
但是，与其拥有一把单独的密钥或一对单一的私钥和公钥，

102
00:07:03,590 --> 00:07:08,160
那么，获取单一证书，你基本上是在创建一个主密钥或者

103
00:07:08,160 --> 00:07:13,020
毛毛虫密钥可以引导一个无限序列的序列。

104
00:07:13,020 --> 00:07:18,120
合同实际上是可以在将来使用的公钥、私钥对。

105
00:07:18,120 --> 00:07:23,150
您可以请求对那个将产生的单一密钥进行认证，以便在未来使用。

106
00:07:23,150 --> 00:07:29,530
在某种证书发行网站上，生成无限的~!@#$%^&*()

107
00:07:29,530 --> 00:07:34,420
私钥序列、无限的公钥序列以及

108
00:07:34,420 --> 00:07:40,880
相应地，它基本上可以生成无限序列的证书。

109
00:07:40,880 --> 00:07:45,670
在信息技术设备的情况下，这可以相当简单。

110
00:07:45,670 --> 00:07:49,798
你可以只在设备上存储一个这样的主密钥。

111
00:07:49,798 --> 00:07:53,740
而且每当你需要的时候，你只需遵循基本的约定，

112
00:07:53,740 --> 00:07:54,650
命名约定。

113
00:07:54,650 --> 00:08:00,720
您确实定义了何时使用特定密钥，您会迅速生成那个私钥。

114
00:08:00,720 --> 00:08:04,350
您一旦在权威网站上的证书上，

115
00:08:04,350 --> 00:08:09,110
这个密钥是已经创建的相应证书。

116
00:08:09,110 --> 00:08:12,960
我可能会在这里停下来，除非我还有几分钟的时间。

117
00:08:12,960 --> 00:08:16,100
但无论如何这都是初步工作，

118
00:08:16,100 --> 00:08:19,240
我们可以想出一些方法来实现这个目标。

119
00:08:19,240 --> 00:08:23,075
我们有点借鉴了一些车辆工作方面的想法。

120
00:08:23,075 --> 00:08:25,336
最近提出的那些建议。

121
00:08:25,336 --> 00:08:28,554
我不会使用那个环境中的所有东西，但是

122
00:08:28,554 --> 00:08:32,040
大多数集中在拥有单一密钥的能力上。

123
00:08:32,040 --> 00:08:36,909
即便是生成、创建了许多种衍生密钥，仍然保留了在此衍生过程中的前向保密属性。

124
00:08:36,909 --> 00:08:42,351
即便是生成、创建了许多种衍生密钥，仍然保留了在此衍生过程中的前向保密属性。

125
00:08:42,351 --> 00:08:47,908
以及在证书颁发方的网站上独立生成的能力。

126
00:08:47,908 --> 00:08:53,959
证书如果你的任何原始主密钥仍未被吊销。

127
00:08:53,959 --> 00:08:59,893
所以基本上是某种结合了证书颁发机构或者

128
00:08:59,893 --> 00:09:04,825
发放证书和通过某种方式撤销证书

129
00:09:04,825 --> 00:09:09,410
不再发放新证书，我想这应该是可以的。

130
00:09:10,630 --> 00:09:12,880
好的，谢谢你，亚历克斯。

131
00:09:12,880 --> 00:09:17,520
我们的下一位演讲者是Sanjeev Ramani，他将介绍MDN Viber振动助手。

132
00:09:17,520 --> 00:09:20,900
自动引导物联网设备。

133
00:09:20,900 --> 00:09:25,450
Sanjeev 是一名在佛罗里达国际大学攻读博士学位的学生，他正在工作。

134
00:09:25,450 --> 00:09:28,940
在 Alex 的指导下工作。

135
00:09:28,940 --> 00:09:33,220
他的研究兴趣包括NDNViber的安全性以及隐私保护和

136
00:09:33,220 --> 00:09:37,770
他的研究兴趣包括无线传感器网络和物联网设备中的信任管理。

137
00:09:37,770 --> 00:09:41,070
Sanjeev，>> 希望我是可见的并且

138
00:09:41,070 --> 00:09:42,460
你们都能听到我说话。

139
00:09:42,460 --> 00:09:44,183
谢谢你，洛蒂。

140
00:09:44,183 --> 00:09:48,720
能不能翻到下一张幻灯片，我们大家。

141
00:09:50,070 --> 00:09:54,010
是的，所以我们都知道物联网设备已经

142
00:09:54,010 --> 00:09:56,880
已经在很大程度上渗透进了每个人的日常生活中。

143
00:09:56,880 --> 00:09:59,780
已经有很多可穿戴设备和其他种类的物联网设备，我们每天都在使用。

144
00:09:59,780 --> 00:10:03,950
我们日常使用的其他种类的物联网设备。

145
00:10:03,950 --> 00:10:10,870
但是，在不久的将来，我们预计它将会有更大规模的爆炸性增长。

146
00:10:10,870 --> 00:10:18,270
物联网设备生命周期中的一个重要方面是引导过程。

147
00:10:18,270 --> 00:10:22,440
而它实际上会了解它将要工作的网络或环境。

148
00:10:22,440 --> 00:10:25,450
而另一方面，网络实际上也会了解

149
00:10:25,450 --> 00:10:29,640
关于即将加入环境的设备，因此，

150
00:10:29,640 --> 00:10:34,060
因此，他们之后能够进行可信赖的沟通和交流。

151
00:10:34,060 --> 00:10:39,407
因此，通常这种引导过程发生在一个辅助通道中或者

152
00:10:39,407 --> 00:10:44,095
在一个辅助通道中，当引导密钥和其他信息加密材料被交换时。

153
00:10:44,095 --> 00:10:47,595
其他信息加密材料被交换。

154
00:10:47,595 --> 00:10:52,584
所以，在我们的探索中，我们基本上调查了所有的带外

155
00:10:52,584 --> 00:10:57,129
所以，在我们的探索中，我们基本上调查了所有的带外频道，以确定哪个在特定情况下最合适，而不是你有一个物联网设备却不在视线范围内。

156
00:10:57,129 --> 00:11:02,140
相反，你有一个物联网设备却不在视线范围内。

157
00:11:02,140 --> 00:11:06,410
它可能在墙后面或嵌在桌子里。

158
00:11:06,410 --> 00:11:09,770
我们希望尝试引导启动这个设备。

159
00:11:09,770 --> 00:11:13,600
我们并不试图增加与此相关的硬件的复杂性。

160
00:11:13,600 --> 00:11:18,940
我们只是尝试使用一个简单的加速度计或

161
00:11:18,940 --> 00:11:23,140
一个相当普遍的设备或传感器，它在如今大多数物联网设备中都有所应用。

162
00:11:23,140 --> 00:11:27,460
在如今的大多数物联网设备中都广泛应用。

163
00:11:27,460 --> 00:11:32,172
所以那时我们就把手放在基于振动的自动银行设备上。

164
00:11:32,172 --> 00:11:36,975
通道基本上为我们提供了多重安全保障。

165
00:11:36,975 --> 00:11:41,340
这基本上是我们基于接近性的信任的起点。

166
00:11:41,340 --> 00:11:46,365
因为你需要将设备和控制器放得非常近

167
00:11:46,365 --> 00:11:51,907
距离小于1.5厘米的范围内以便于

168
00:11:51,907 --> 00:11:56,868
以便于物联网设备实际感受到振动并进行引导启动。

169
00:11:56,868 --> 00:12:01,479
以及我们提出的使用NDNViber设计，

170
00:12:01,479 --> 00:12:05,140
这种基于振动的通道。

171
00:12:05,140 --> 00:12:09,580
可以是一种与最传统的静态方式相对的动态方法

172
00:12:09,580 --> 00:12:11,650
引导启动的方法。

173
00:12:11,650 --> 00:12:16,550
我们还可以使用普通或原生安卓手机作为控制器。

174
00:12:16,550 --> 00:12:17,050
下一张幻灯片，请。

175
00:12:20,565 --> 00:12:26,230
那么，NDNViber概述，我可能会很快地简单跑一遍。

176
00:12:26,230 --> 00:12:30,430
它分为四个不同的阶段，从引导序列开始，该序列会……

177
00:12:30,430 --> 00:12:37,330
将基本唤醒物联网设备，并使其在振动通道上进行监听。

178
00:12:37,330 --> 00:12:42,490
用于接收任何由控制器传递的触发器或任何信息。

179
00:12:42,490 --> 00:12:45,070
然后是触发器序列的执行，其中，

180
00:12:46,630 --> 00:12:50,670
接着是环境信息的交换，以及

181
00:12:50,670 --> 00:12:55,880
接着是学习信息，如临时加密密钥或者加密密钥。

182
00:12:55,880 --> 00:13:00,600
以及设备在之后应使用的频道

183
00:13:00,600 --> 00:13:02,850
通信时在网络中。

184
00:13:02,850 --> 00:13:08,320
在触发序列之后，是设备之后交换的锚点。

185
00:13:08,320 --> 00:13:14,370
锚点序列完成后，将了解信任锚证书。

186
00:13:14,370 --> 00:13:20,590
在设备运行时，最后我们有NDN证书序列。

187
00:13:20,590 --> 00:13:25,710
能够为关键的命名空间生成并获取其NDN证书，

188
00:13:25,710 --> 00:13:29,990
将其用于对网络中产生的信息进行签名。

189
00:13:29,990 --> 00:13:31,870
下一张幻灯片，请。

190
00:13:31,870 --> 00:13:34,250
所以基本上这就是概览，

191
00:13:34,250 --> 00:13:40,270
如果你能和我一起来到海报前，我们可以进一步讨论。

192
00:13:40,270 --> 00:13:43,180
特定的编码方案我们使用了什么~!@#$%^&*()

193
00:13:43,180 --> 00:13:47,645
振动通道以及它在NDNViber中的使用方式。

194
00:13:47,645 --> 00:13:52,080
我们在引导方面看到的优势有哪些？

195
00:13:52,080 --> 00:13:56,717
同时使用多个设备时，我们观察到的安全属性以及

196
00:13:56,717 --> 00:14:01,510
我们所面临的评估挑战，以及我们所进行的初步评估。

197
00:14:02,770 --> 00:14:06,270
这大概就是这个的全部了，我想我接下来会继续进行。

198
00:14:07,730 --> 00:14:09,450
是的，所以你有两张海报。

199
00:14:09,450 --> 00:14:15,430
这是第二个用于确保智能手机分发的海报。

200
00:14:15,430 --> 00:14:20,850
好的，所以这基本上还处于初步探索阶段。

201
00:14:20,850 --> 00:14:25,510
这更多的是我们都知道智能电网是一种现代化的采纳。

202
00:14:25,510 --> 00:14:29,650
的电力系统，具有彻底改变电力分配和管理的潜力。

203
00:14:29,650 --> 00:14:30,750
管理。

204
00:14:30,750 --> 00:14:35,070
在一般情况下，你会有多个，

205
00:14:35,070 --> 00:14:40,740
在一般情况下，你会有多个利益相关者，无论是消费者还是电力生产者。

206
00:14:40,740 --> 00:14:46,360
和许多其他中间设备，无论是传感器还是

207
00:14:46,360 --> 00:14:50,250
变压器，对，那些变压器可以转换电力，无论是升压还是降压变压器。

208
00:14:50,250 --> 00:14:54,570
将电力从升压变压器或降压变压器转换过来。

209
00:14:54,570 --> 00:14:59,660
这些设备之间发生了大量的数字通信。

210
00:14:59,660 --> 00:15:05,707
设备基本上是智能电网整个运作的支持系统。

211
00:15:05,707 --> 00:15:11,380
与此同时，智能电网基本上为我们提供了解耦错误的功能。

212
00:15:11,380 --> 00:15:17,000
电力发电站与消费地点之间的互联互通，

213
00:15:17,000 --> 00:15:21,120
使电力基本上成为了一种可以请求的商品。

214
00:15:22,430 --> 00:15:28,389
好的，所以我提到了两种基本上在这个系统中交换的信息。

215
00:15:28,389 --> 00:15:34,450
这个系统主要涉及与能源特性相对应的技术数据。

216
00:15:34,450 --> 00:15:38,922
以及与建筑、定价相关的管理信息，

217
00:15:38,922 --> 00:15:43,315
以及甚至可以用于分析以识别如何

218
00:15:43,315 --> 00:15:47,324
新的基础设施需要建立以及其他事项。

219
00:15:47,324 --> 00:15:51,774
最终，我们相信凭借所有这些内在特性，

220
00:15:51,774 --> 00:15:57,470
像数据中心安全、最优路由等其他

221
00:15:57,470 --> 00:16:02,160
数据中心方法的好处，数据中心

222
00:16:03,210 --> 00:16:09,940
架构可以更好地适用于智能电网通信。

223
00:16:09,940 --> 00:16:11,565
下一张幻灯片，请。

224
00:16:15,004 --> 00:16:21,973
是的，我们在当前智能电网设置中看到的常见问题是

225
00:16:21,973 --> 00:16:27,480
大多数这些电力系统通常是传统系统。

226
00:16:27,480 --> 00:16:29,350
它们之间并没有相互关联的界面。

227
00:16:29,350 --> 00:16:33,750
因此，如果你谈论的是作为最终消费者的物联网设备与

228
00:16:33,750 --> 00:16:39,610
因此，如果你谈论的是作为最终消费者的物联网设备与大型机械设备可能存在的接口问题，当前系统中这些设备之间的交互并没有得到很好的处理。

229
00:16:39,610 --> 00:16:45,930
在当前系统中，这些设备之间的交互并没有得到很好的处理。

230
00:16:45,930 --> 00:16:50,374
在当前系统中，这些设备之间的交互并没有得到很好的处理。并且，信息流动也存在许多安全问题，这些信息通过不同的渠道和媒介传播，而且需要进行双重检查。

231
00:16:50,374 --> 00:16:54,689
在当前系统中，这些设备之间的交互并没有得到很好的处理。并且，信息流动也存在许多安全问题，这些信息通过不同的渠道和媒介传播，而且需要进行双重检查。

232
00:16:54,689 --> 00:16:59,648
在使用NDN的情况下，我们可以采取一种默认关闭的方法，仅在必要时才开启。

233
00:16:59,648 --> 00:17:03,178
当任何节点需要或被请求时

234
00:17:03,178 --> 00:17:08,138
信息可以被启用，因此，你可以防止任何不良情况发生。

235
00:17:08,138 --> 00:17:12,790
信息的传入或系统中可能发生的任何泄露。

236
00:17:14,070 --> 00:17:15,130
下一张幻灯片。

237
00:17:15,130 --> 00:17:19,120
我这里可能有一个小例子。

238
00:17:19,120 --> 00:17:20,620
让我们考虑一下智能家居。

239
00:17:20,620 --> 00:17:23,290
我希望我没有在这件事上耗尽时间。

240
00:17:23,290 --> 00:17:24,170
我会很快做完的。

241
00:17:24,170 --> 00:17:27,020
如此智能的家庭拥有的那个智能冰箱就是...

242
00:17:27,020 --> 00:17:29,180
试图请求供电。

243
00:17:29,180 --> 00:17:33,410
它基本上就像我告诉你的，有不同的利益相关者不同的

244
00:17:34,470 --> 00:17:38,220
笔记涉及到这整个沟通过程中的不同人员。

245
00:17:38,220 --> 00:17:42,610
NDN通过其灵活的命名规则和

246
00:17:42,610 --> 00:17:48,360
通过其它好处使得它成为实现这种能力的一个更容易的选择，这种能力是

247
00:17:48,360 --> 00:17:53,270
通过智能信用系统将其基本上作为一种商品进行了解耦，并且

248
00:17:53,270 --> 00:17:56,330
通过智能信用系统将其基本上作为一种商品进行了解耦，并且高效地请求并使用它。下一张幻灯片，所以当你路过或

249
00:17:56,330 --> 00:18:00,110
下一张幻灯片，所以当你路过或

250
00:18:00,110 --> 00:18:05,920
当我们在海报展示环节，我们或许可以

251
00:18:05,920 --> 00:18:12,680
讨论NDN如何在所有这些智能电网操作中发挥基础作用，以及通过采用NDN，智能电网运行可以变得更加顺畅。

252
00:18:12,680 --> 00:18:19,750
通过采用NDN，智能电网运行可以变得更加顺畅。

253
00:18:19,750 --> 00:18:20,730
谢谢，我想是的。

254
00:18:22,270 --> 00:18:22,860
>> 好的。

255
00:18:22,860 --> 00:18:24,490
谢谢你，Sanjeev。

256
00:18:24,490 --> 00:18:29,514
下一位发言者是Italo Brito。

257
00:18:29,514 --> 00:18:34,680
关于NDN的距离向量路由的话题。

258
00:18:34,680 --> 00:18:39,370
Italo 是巴西巴伊亚联邦大学的一名博士研究生。

259
00:18:40,500 --> 00:18:41,000
继续吧，Italo。

260
00:18:43,960 --> 00:18:44,820
>> 大家好。

261
00:18:44,820 --> 00:18:45,780
下午好？

262
00:18:45,780 --> 00:18:49,440
所以这项工作是我和我的导师合作的，

263
00:18:49,440 --> 00:18:53,760
兰比诺教授，以及来自加州大学洛杉矶分校的阿丽西亚·张教授。

264
00:18:53,760 --> 00:19:01,120
因此，这个想法是为引擎提出一个距离向量路由算法。

265
00:19:01,120 --> 00:19:02,010
下一张幻灯片，请。

266
00:19:02,010 --> 00:19:08,880
因此，在移动Adhoc场景中的NDN呈现了一些挑战。

267
00:19:08,880 --> 00:19:14,450
因此，队列中部署了基于链路状态算法的引擎路由协议NLSR。

268
00:19:14,450 --> 00:19:16,400
基于链路状态算法。

269
00:19:16,400 --> 00:19:20,610
链路状态数据库需要在各个节点之间进行同步。

270
00:19:20,610 --> 00:19:25,330
节点、任何事物以及在移动文档场景中，

271
00:19:25,330 --> 00:19:29,950
它们设计了一种轻量级的无线动态环境，

272
00:19:29,950 --> 00:19:35,500
路由协议用于传播快速变化的数据可达性信息。

273
00:19:35,500 --> 00:19:39,780
距离矢量路由协议使得每个节点能够有选择地

274
00:19:39,780 --> 00:19:44,770
动作交换、名称前缀、可达性信息以及也能够

275
00:19:44,770 --> 00:19:50,510
估计愿望能力在分布式同步方式中设计数据。

276
00:19:50,510 --> 00:19:55,660
与链路状态路由不同，它需要同步距离。

277
00:19:55,660 --> 00:20:01,180
矢量是基于分布式的和同步通信的。

278
00:20:01,180 --> 00:20:01,980
下一张幻灯片，请。

279
00:20:06,446 --> 00:20:12,595
因此，我们的目标是提出一种尽可能简单的方式来传播名称。

280
00:20:12,595 --> 00:20:18,336
在移动自组织网络场景中的前缀可达性信息，以及

281
00:20:18,336 --> 00:20:24,040
我们的设计基于动态检测邻居节点。

282
00:20:24,040 --> 00:20:26,270
在检测到邻居节点后，

283
00:20:26,270 --> 00:20:31,010
节点发送一个兴趣请求以检索邻居的距离向量信息，

284
00:20:31,010 --> 00:20:36,180
我们需要记住，这些路由的兴趣请求并没有被加密，但是

285
00:20:36,180 --> 00:20:41,040
在我们的情况下这不是问题，因为这只是一个请求，然后邻居会回复。

286
00:20:41,040 --> 00:20:45,590
回传的是可达性信息，即到房子的距离向量。

287
00:20:45,590 --> 00:20:49,190
数据包是安全的，可以进行验证。

288
00:20:49,190 --> 00:20:51,640
所以我们可以确保数据是有效的。

289
00:20:52,740 --> 00:20:58,230
我们使用带序列号方法的分布式贝尔曼-福特算法。

290
00:20:58,230 --> 00:20:59,045
这些是真的，

291
00:20:59,045 --> 00:21:05,090
来自移动自组织网络研究社区的众所周知的算法。

292
00:21:05,090 --> 00:21:09,500
所以我们只是利用了同样众所周知的算法。

293
00:21:09,500 --> 00:21:10,354
下一张幻灯片，请。

294
00:21:16,383 --> 00:21:21,388
我们的命名方案主要基于两种消息，

295
00:21:21,388 --> 00:21:27,992
邻居发现使用的hello消息，它是用于发现邻居的消息，

296
00:21:27,992 --> 00:21:34,278
它也是一种扩展的hello消息，因为它还被用来通知

297
00:21:34,278 --> 00:21:39,660
它也是一种扩展的hello消息，因为它还被用来通知邻居们关于节点上的新D向量信息。So, we are going to discuss this a little bit later on the poster session.

298
00:21:39,660 --> 00:21:44,000
所以，我们稍后会在海报展示环节讨论这个问题。

299
00:21:44,000 --> 00:21:50,010
但另一种类型的信息是距离矢量信息。

300
00:21:50,010 --> 00:21:54,190
然后我们使用这种命名方案。

301
00:21:54,190 --> 00:21:58,240
我们有ndvr、dvinfo，还有halter name和~!@#$%^&*()

302
00:21:58,240 --> 00:22:03,780
包的版本，数据兴趣的版本。

303
00:22:03,780 --> 00:22:06,880
而这些信息通过路由器密钥被静默处理。

304
00:22:06,880 --> 00:22:11,900
而我们在进行密钥交换时，基本上也是使用相同的方法。

305
00:22:11,900 --> 00:22:20,230
使用与分析师交换密钥时相同的命名模式。

306
00:22:20,230 --> 00:22:23,110
用于验证数据的证书密钥，

307
00:22:23,110 --> 00:22:27,620
我们的假设是每个节点都必须了解一个信任锚点。

308
00:22:27,620 --> 00:22:31,680
在这种情况下，是针对斜杠网络名称的证书。

309
00:22:32,750 --> 00:22:33,634
下一张幻灯片，请。

310
00:22:36,577 --> 00:22:42,910
在这个例子中，我们只有两个无线路由器，路由器A和路由器B。

311
00:22:42,910 --> 00:22:46,960
在这种情况下，UFBA 只是网络名称的热点。

312
00:22:46,960 --> 00:22:49,730
它可以是谷歌，也可以是加州大学洛杉矶分校。

313
00:22:49,730 --> 00:22:54,350
它可以是国家标准技术研究所（NIST），或者任何你想要的东西，但这只是一个样本。

314
00:22:54,350 --> 00:23:00,070
第一步是通过网络发送兴趣信号来打招呼，表示友好。

315
00:23:00,070 --> 00:23:01,860
~!@#$%^&*()

316
00:23:01,860 --> 00:23:07,670
每个URC在Wi-Fi网络中发送了相同的兴趣。

317
00:23:07,670 --> 00:23:12,625
一旦一个热点得知另一个热点的存在

318
00:23:12,625 --> 00:23:17,120
这个更热的开始请求距离工厂形成的信息

319
00:23:17,120 --> 00:23:22,130
我们发送我们的兴趣请求，这意味着我们更加热切地想要

320
00:23:22,130 --> 00:23:25,020
我们刚刚发现的健康信息。

321
00:23:25,020 --> 00:23:28,360
它一旦接受到更热的处理请求，

322
00:23:28,360 --> 00:23:31,370
它会回复距离矢量信息。

323
00:23:31,370 --> 00:23:36,580
所以它会把这些矢量数据包发送回请求者。

324
00:23:36,580 --> 00:23:37,639
下一张幻灯片，请。

325
00:23:41,607 --> 00:23:46,810
所以我认为这是在……我希望你能加入我们的海报部分。

326
00:23:46,810 --> 00:23:50,420
在海报部分，我们将会进一步讨论关于……

327
00:23:50,420 --> 00:23:54,930
我们在ndnSIM 2.8上开发的原型。

328
00:23:54,930 --> 00:23:59,800
我们将展示一些我们使用的评估的初步结果，

329
00:23:59,800 --> 00:24:05,660
我们使用随机漫步移动模型，并与DTSN进行比较，

330
00:24:05,660 --> 00:24:09,660
它是一种数据同步算法。

331
00:24:09,660 --> 00:24:15,169
你将会呈现一些关于这个测试的挑战和正在进行的工作。

332
00:24:15,169 --> 00:24:15,902
谢谢。

333
00:24:17,952 --> 00:24:20,450
好的，谢谢你，Lito。

334
00:24:20,450 --> 00:24:24,370
下一位演讲者是Amar Abane。

335
00:24:24,370 --> 00:24:29,940
关于使用多元宇宙网络管理系统管理MDN。

336
00:24:29,940 --> 00:24:34,460
阿玛尔在法国国家应用科学院（CNAM）获得了博士学位，目前是一名研究员。

337
00:24:34,460 --> 00:24:36,954
他在美国国家标准与技术研究院（NIST）负责网络技术部门。

338
00:24:36,954 --> 00:24:37,660
请继续，阿马尔。

339
00:24:41,080 --> 00:24:41,660
>> 好的，谢谢。

340
00:24:43,840 --> 00:24:48,920
是的，这就是多元宇宙网络管理系统项目。

341
00:24:48,920 --> 00:24:52,950
所以这只是一个用来描述情况的情景。

342
00:24:52,950 --> 00:24:56,791
所以当我们处理NDN部署时，

343
00:24:56,791 --> 00:25:02,450
因此，当我们处理NDN部署时，一些管理功能是必需的，或者至少需要一些配置。

344
00:25:02,450 --> 00:25:07,410
需要在转发器上配置基本的路由信息。

345
00:25:09,240 --> 00:25:12,520
但至少如此，为了管理我们的NDN网络，

346
00:25:12,520 --> 00:25:16,630
我们面临着一些不同的情况。

347
00:25:16,630 --> 00:25:19,860
所以我们可以通过IP网络来管理NDN网络。

348
00:25:20,940 --> 00:25:25,684
如果我们需要远程管理，我们可以做到这一点。

349
00:25:31,755 --> 00:25:36,853
还可以通过IP和NDN来管理NDN网络。

350
00:25:36,853 --> 00:25:43,090
由于仍然有一些设备在使用IP，所以我们也需要管理一部分基于IP的网络。

351
00:25:43,090 --> 00:25:47,650
由于仍然有一些设备在使用IP，所以我们也需要管理一部分

352
00:25:47,650 --> 00:25:52,890
IP网络或者是到NDN或者是IP。

353
00:25:52,890 --> 00:25:57,480
我们认为可能有必要为这些不同情况或不同宇宙提供一个统一的管理解决方案。

354
00:25:57,480 --> 00:26:01,380
这些不同情况或不同宇宙。

355
00:26:01,380 --> 00:26:04,144
那么，请换到下一张幻灯片。

356
00:26:07,666 --> 00:26:15,135
是的，这正是多元宇宙网络管理系统设计的目的。

357
00:26:15,135 --> 00:26:18,785
所以我们的目标是管理这些不同的情况。

358
00:26:18,785 --> 00:26:19,603
下一张幻灯片。

359
00:26:23,091 --> 00:26:26,502
是的，简而言之，它是一种集中管理方式。

360
00:26:26,502 --> 00:26:31,078
我们希望坚持使用这种非常简单且非常熟悉的架构。

361
00:26:31,078 --> 00:26:36,060
我们有数据平面与

362
00:26:36,060 --> 00:26:42,870
我们目前正在努力支持的NDN-DPDK转发器。

363
00:26:42,870 --> 00:26:47,130
我们目前正在努力支持的NDN-DPDK转发器。它们是控制平面的组成部分，它们是部署在每个节点上的代理，they are agents are connected to the controller.

364
00:26:47,130 --> 00:26:49,800
它们是连接到控制器的代理。

365
00:26:49,800 --> 00:26:54,990
而且那里有一个控制器提供了一些集中管理功能。

366
00:26:54,990 --> 00:27:01,480
其中一些是自动功能，如人脸创建、人脸计算。

367
00:27:01,480 --> 00:27:09,230
还有一些其他东西是提供给操作员手动使用的。

368
00:27:09,230 --> 00:27:14,250
还有除了管理之外，还有遥测功能。

369
00:27:15,650 --> 00:27:19,800
这些代理集成的功能，取决于什么

370
00:27:19,800 --> 00:27:25,250
代理上实施了测量。

371
00:27:25,250 --> 00:27:26,470
嗯，所以在海报中，

372
00:27:26,470 --> 00:27:31,410
所以海报中基本上会有一些到目前为止实现的功能的截图，

373
00:27:31,410 --> 00:27:37,860
这个项目中也包含了一些设计课程。

374
00:27:39,310 --> 00:27:40,110
>> 我想就这样了。

375
00:27:40,110 --> 00:27:41,920
嗯，谢谢。

376
00:27:41,920 --> 00:27:43,760
好的，谢谢Amar。

377
00:27:43,760 --> 00:27:49,787
下一位演讲者是Quassim Karrakchuo，主题是“新型P4目标架构”。

378
00:27:49,787 --> 00:27:53,560
运行时可重配置的NDN数据平面。

379
00:27:53,560 --> 00:27:56,600
Quassim 从法国获得了他的学士学位，并且

380
00:27:56,600 --> 00:27:59,960
他目前是渥太华大学的博士研究生。

381
00:27:59,960 --> 00:28:04,580
他的研究兴趣包括信息中心网络（ICN）、软件定义网络（SDN）和云技术。

382
00:28:05,840 --> 00:28:06,698
继续吧，Ouassim。

383
00:28:06,698 --> 00:28:08,710
>> 谢谢你，Lotfi。

384
00:28:08,710 --> 00:28:10,580
大家好。

385
00:28:10,580 --> 00:28:17,770
所以今天我将快速介绍我们的工作，其标题为，

386
00:28:17,770 --> 00:28:22,326
一种针对运行时可重配置引擎数据平面的新颖P4目标架构。下一张幻灯片，请。

387
00:28:22,326 --> 00:28:25,328
下一张幻灯片，请。

388
00:28:28,331 --> 00:28:33,115
所以我们工作的动机是，在当前的交换机中，

389
00:28:33,115 --> 00:28:37,163
交换机的功能通常是固定的，而且

390
00:28:37,163 --> 00:28:41,680
通常只能由交换机制造商来更改。

391
00:28:41,680 --> 00:28:45,230
这意味着在交换机内部处理数据包的算法，通常只能由交换机制造商来更改，它们要么像硬件一样经过优化，要么直接在硬件中硬编码。

392
00:28:45,230 --> 00:28:51,410
它们要么像硬件一样经过优化，要么直接在硬件中硬编码。

393
00:28:51,410 --> 00:28:56,630
所以它们只能通过购买新硬件来更改，或者它们是一部分

394
00:28:56,630 --> 00:29:02,490
因此，如果需要支持新的协议，网络操作员将不得不等待交换机制造商的新更新。

395
00:29:03,830 --> 00:29:09,327
因此，网络操作员将不得不等待交换机制造商的新更新。

396
00:29:11,170 --> 00:29:16,040
因此，为了解决这一限制，P4语言被引入。

397
00:29:16,040 --> 00:29:21,310
打开数据平面并允许网络运营商自定义编写交换机中的行为。

398
00:29:21,310 --> 00:29:27,170
指定他们自己的自定义来编写他们交换机中的行为。

399
00:29:27,170 --> 00:29:28,340
那么它是如何工作的呢？

400
00:29:28,340 --> 00:29:33,750
网络运营商将使用P4，这是一种高级编程

401
00:29:33,750 --> 00:29:38,432
语言来编程他们的数据平面使用P4。

402
00:29:38,432 --> 00:29:43,150
为了完全指定他们在交换机中需要的一切，他们需要编写程序。

403
00:29:44,750 --> 00:29:49,009
现在，当前的P4架构，它们

404
00:29:49,009 --> 00:29:54,710
它们有一个小限制，即

405
00:29:54,710 --> 00:29:59,310
通常一个交换机一次只能运行一个大型P4程序。

406
00:30:00,600 --> 00:30:05,750
那就意味着如果网络运营商想要向他们的交换机添加新功能，他们必须编辑这个大型P4程序。

407
00:30:05,750 --> 00:30:10,522
that means if network operators want to add new features to their switch, they have to edit this large P4 program.

408
00:30:10,522 --> 00:30:16,750
然后将其上传到需要重置的交换机中，

409
00:30:16,750 --> 00:30:20,250
然后更新交换机中处理所有事务的整个程序。

410
00:30:20,250 --> 00:30:23,290
因此总是需要一段停机时间。

411
00:30:23,290 --> 00:30:26,830
每次更新都是为了给交换机增加功能。

412
00:30:28,160 --> 00:30:34,460
P4的第二个限制更具体地针对了NDN的情况。

413
00:30:34,460 --> 00:30:40,160
P4实际上是在IP世界的背景下设计的。

414
00:30:40,160 --> 00:30:47,180
在这种情况下，报头通常是固定的，并且具有固定大小的字段，对吗？

415
00:30:47,180 --> 00:30:53,710
在这种情况下，当你想要将其直接应用于NDN时，其中一个主要字段

416
00:30:53,710 --> 00:30:57,990
在头部中是常量名，它是一个变长的字符串。

417
00:30:57,990 --> 00:31:03,000
您需要克服一些限制。

418
00:31:03,000 --> 00:31:05,520
好的，请换到下一张幻灯片。

419
00:31:11,406 --> 00:31:16,602
那么，我们工作的主要目标是拥有一个引擎，

420
00:31:16,602 --> 00:31:22,380
我们的工作主要目标是拥有一个数据平面，它能够使用P4进行其他一些程序化操作。

421
00:31:23,430 --> 00:31:31,290
我们希望以一种方式来实现，你可以指派一个特定的自定义写入操作。

422
00:31:31,290 --> 00:31:37,322
将逻辑指派给一个特定的命名空间，这全部包含在P4函数中。

423
00:31:37,322 --> 00:31:41,920
将自定义的P4函数关联到一个命名空间中去。

424
00:31:41,920 --> 00:31:47,110
我们希望以一种方式来实现，所有这些P4功能都是独立的。

425
00:31:47,110 --> 00:31:53,570
并且你可以在不影响交换机其余部分的情况下添加它们，对吧，所以。

426
00:31:54,570 --> 00:31:59,606
所以我们想设计这种新的P4目标架构，它

427
00:31:59,606 --> 00:32:04,455
允许我们运行多个小型、轻量级的P4程序，

428
00:32:04,455 --> 00:32:08,745
使它们在隔离环境中运行，并使它们具有独立的状态。

429
00:32:08,745 --> 00:32:11,563
让它们具有独立的状态。

430
00:32:11,563 --> 00:32:16,237
因此，我们可以让每个默认功能都可以单独重新配置。

431
00:32:16,237 --> 00:32:21,080
因此，不会影响其他任何事物，也不会造成任何负面影响。

432
00:32:21,080 --> 00:32:26,604
并且因为我们工作的主要背景是NDN协议，

433
00:32:26,604 --> 00:32:31,727
我们希望以高效的方式扩展P4语言，以便

434
00:32:31,727 --> 00:32:37,453
允许所有这些对于支持NDN协议至关重要的字符串处理操作。

435
00:32:37,453 --> 00:32:40,280
支持NDN协议。

436
00:32:41,410 --> 00:32:48,210
同时兼容P4

437
00:32:48,210 --> 00:32:53,040
语言标准，因此我们可以使用普通的P4编译器而无需任何修改。

438
00:32:55,250 --> 00:32:56,344
下一张幻灯片，请。

439
00:32:59,964 --> 00:33:07,730
所以这是我们提出的数据平面架构的概要。

440
00:33:07,730 --> 00:33:12,800
所以这个架构的主要目标，正如我所说的，是能够分配

441
00:33:12,800 --> 00:33:17,705
将复杂的有状态转发行为分配到一个特定的命名空间中，

442
00:33:17,705 --> 00:33:21,086
例如，进行遥测这样的事情，

443
00:33:21,086 --> 00:33:25,507
地理监控、地理围栏、有状态防火墙等。

444
00:33:25,507 --> 00:33:30,660
因此，我们的架构有两个主要模块。

445
00:33:30,660 --> 00:33:35,900
第一个模块称为EProcessing模块，基本上我会说它包含主要的NDN转发管道以及一些修改。

446
00:33:35,900 --> 00:33:42,880
包含主要的NDN转发管道以及一些修改。

447
00:33:42,880 --> 00:33:48,640
为了将P4功能分配给一个命名空间。

448
00:33:48,640 --> 00:33:53,830
一旦这个EProcessing完成了数据包的处理，

449
00:33:53,830 --> 00:33:57,380
因此添加到了一个称为转发逻辑的新模块中，

450
00:33:57,380 --> 00:34:02,480
因此被添加到了一个包含一系列在隔离环境中运行的不同P4功能的新模块中，

451
00:34:02,480 --> 00:34:07,045
因此将处理这些NDN数据包以便

452
00:34:07,045 --> 00:34:13,450
进行任何类型的转发行为，这是网络运作或希望执行的操作。

453
00:34:13,450 --> 00:34:18,532
然后这些数据包被传递到解析器，解析器可能会

454
00:34:18,532 --> 00:34:25,408
在此之前，根据P4功能的指令，可以选择性地修改数据包。

455
00:34:25,408 --> 00:34:32,170
数据包通过接口被转发，并发送到下一个主机。

456
00:34:32,170 --> 00:34:39,680
我们还进行了一些小修改，将内容存储移到了快速处理路径之外。

457
00:34:39,680 --> 00:34:45,480
数据包在NDN管道中的路径。

458
00:34:45,480 --> 00:34:50,480
因此，内容存储是通过一个内部接口访问的。

459
00:34:50,480 --> 00:34:54,940
因此，可以通过添加控制缓存决策。

460
00:34:54,940 --> 00:34:59,460
通过命名空间向内容存储的下一跳添加，所以

461
00:34:59,460 --> 00:35:03,940
通过P4功能可以控制缓存决策，通过添加或

462
00:35:03,940 --> 00:35:08,270
移除到内容存储内部界面的下一跳。

463
00:35:09,540 --> 00:35:13,930
在海报展示环节，我将向你详细解释。

464
00:35:14,950 --> 00:35:18,460
我们是如何做到的以及这些不同模块内部包含了什么内容。

465
00:35:21,560 --> 00:35:25,260
数据平面以及我们如何高效地与人交互。

466
00:35:26,700 --> 00:35:31,890
谢谢大家，我们海报展示环节见。

467
00:35:33,880 --> 00:35:35,410
>> 好的，谢谢你，Ouassim。

