1
00:00:04,704 --> 00:00:06,750
欢迎大家回来。

2
00:00:06,750 --> 00:00:11,840
下一个议程项目，第四场会议开始。

3
00:00:11,840 --> 00:00:14,420
该场会议中我们有三个演讲，

4
00:00:14,420 --> 00:00:18,685
它将由来自Miter的Tamer Refaei分享。

5
00:00:18,685 --> 00:00:20,370
Tamer，轮到你发言了。

6
00:00:21,830 --> 00:00:23,590
>> 好的，那你们都能听到我说话吗？

7
00:00:23,590 --> 00:00:24,960
>> 是的。

8
00:00:24,960 --> 00:00:25,820
>> 好的，很好。

9
00:00:26,820 --> 00:00:28,580
这是一个DARPA共享项目。

10
00:00:28,580 --> 00:00:30,090
这是一个非常令人兴奋的项目。

11
00:00:30,090 --> 00:00:31,200
我很高兴主持这个会议。

12
00:00:32,450 --> 00:00:35,670
我认为DARPA主席计划大约在三年前开始的，

13
00:00:35,670 --> 00:00:40,540
它是我们利用的责任计划之一，以印第安纳州作为核心网络。

14
00:00:40,540 --> 00:00:45,290
整合技术以解决许多网络的一些限制和责任。

15
00:00:45,290 --> 00:00:47,370
所以我们在这里讨论DARPA Share。

16
00:00:47,370 --> 00:00:48,600
我们有三场演讲。

17
00:00:48,600 --> 00:00:51,520
第一场是由玛丽·舒尔戈特博士主讲的。

18
00:00:51,520 --> 00:00:55,480
她是DARPA Share项目的项目经理。

19
00:00:55,480 --> 00:01:00,850
那么我就简单介绍一下Schurgot博士。

20
00:01:00,850 --> 00:01:04,160
她于2020年3月加入DARPA，成为该机构的项目经理。

21
00:01:04,160 --> 00:01:07,280
战略技术办公室，即STO。

22
00:01:07,280 --> 00:01:11,080
她的研究兴趣包括安全高效的数据共享、自动化

23
00:01:11,080 --> 00:01:16,430
决策辅助和新型网络与通信范式的设计。

24
00:01:16,430 --> 00:01:21,960
在加入DARPA之前，Schurgot博士是机器学习的技术总监，以及

25
00:01:21,960 --> 00:01:27,300
在此之前，她在LG的创新部门开发并提升了Khaki的边缘计算能力，

26
00:01:27,300 --> 00:01:31,165
在分析学、网络安全和网络交互领域领导了多个项目。

27
00:01:31,165 --> 00:01:34,320
舍戈特博士，现在轮到你发言了。

28
00:01:35,570 --> 00:01:38,919
>> 谢谢你，塔玛尔，你们都能听到我，一切准备就绪。

29
00:01:38,919 --> 00:01:41,765
>> 这边都很好。

30
00:01:41,765 --> 00:01:42,807
>> 好的，太棒了。

31
00:01:47,612 --> 00:01:51,743
好的，希望大家都能看到我的屏幕。

32
00:01:51,743 --> 00:01:55,330
谢谢NIST主办这次社区会议。

33
00:01:55,330 --> 00:01:56,650
我很高兴能来到这里。

34
00:01:56,650 --> 00:01:59,367
我将会介绍股份计划并且

35
00:01:59,367 --> 00:02:03,409
然后接下来的两场演讲将会深入讨论关于如何

36
00:02:03,409 --> 00:02:05,448
我们正在SHARE中利用NDN。

37
00:02:09,897 --> 00:02:14,851
好的，所以SHARE，顾名思义，是关于在多个安全级别的战术网络中进行安全数据共享。

38
00:02:14,851 --> 00:02:18,600
在战术网络中的多个安全级别。

39
00:02:21,160 --> 00:02:25,100
我们在SHARE中有三个重点领域，我将简要介绍每一个，但是

40
00:02:25,100 --> 00:02:27,980
我认为这确实是弹性网络部分。

41
00:02:27,980 --> 00:02:29,840
观众最感兴趣的。

42
00:02:31,100 --> 00:02:35,607
在SHARE中，我们与战术突击套件应用程序集成以

43
00:02:35,607 --> 00:02:38,095
展示SHARE的能力。

44
00:02:40,860 --> 00:02:45,884
再次强调，我们不会在程序的整体构造上花费太多时间，

45
00:02:45,884 --> 00:02:49,430
但只是为了让你感受一下我们在这里做的事情。

46
00:02:49,430 --> 00:02:54,060
所以SHARE项目是关于将数据共享带到战术边缘，在这一点上与传统方式形成对比，

47
00:02:55,900 --> 00:02:58,810
这种方式就是今天所采用的回溯方法。

48
00:02:58,810 --> 00:03:04,100
连接到企业系统以便能够访问多个敏感级别的数据。

49
00:03:04,100 --> 00:03:08,070
在战术边缘环境中维护一个虚拟专用网络连接。

50
00:03:08,070 --> 00:03:13,500
在战术边缘环境中维护一个虚拟专用网络连接。

51
00:03:13,500 --> 00:03:17,010
此外，配置这些系统可能需要花费几个月到几年的时间。

52
00:03:17,010 --> 00:03:18,040
几个月到几年。

53
00:03:19,240 --> 00:03:24,660
相比之下，通过在移动设备上实现数据共享来应对这些挑战，

54
00:03:24,660 --> 00:03:27,930
手持设备，或者基本上是一部安卓手机。

55
00:03:27,930 --> 00:03:31,900
我们可以在不同的安全区域内隔离不同敏感级别的数据。

56
00:03:31,900 --> 00:03:34,970
在手机内部设置不同的安全区域。

57
00:03:34,970 --> 00:03:38,240
我们通过命名数据网络解决弹性网络问题。

58
00:03:38,240 --> 00:03:39,420
因此，我们有了缓存和

59
00:03:39,420 --> 00:03:43,920
因此，我们有了缓存和网络内的同步，而不是回到特定的服务器。Back at an enterprise system.

60
00:03:46,680 --> 00:03:48,110
回到企业系统。

61
00:03:48,110 --> 00:03:52,594
最后，我们有配置管理软件，它可以

62
00:03:52,594 --> 00:03:57,161
配置时间从几个月缩短到大约几分钟。

63
00:04:00,622 --> 00:04:06,265
因此，SHARE的关键部分是能够保存数据并且使用增强的数据集。

64
00:04:06,265 --> 00:04:09,850
存储带有增强数据集的数据。

65
00:04:09,850 --> 00:04:12,760
这里是一个概念性的高层架构。

66
00:04:12,760 --> 00:04:15,740
这是位于手持设备上的SHARE系统。

67
00:04:15,740 --> 00:04:19,520
这里我们有三个假想的敏感性等级。

68
00:04:19,520 --> 00:04:24,590
一个医疗飞地、一个美国飞地和一个合作伙伴飞地。

69
00:04:24,590 --> 00:04:29,190
所有这些飞地都通过手机内的管理进行管理。

70
00:04:29,190 --> 00:04:33,643
负责密钥存储、执行共享策略的飞地，

71
00:04:33,643 --> 00:04:38,611
然后你会看到它们从我们的手机上发出，我们使用了双重加密，

72
00:04:38,611 --> 00:04:43,189
然后你会看到它们从我们的手机上发出，我们使用了双重加密，数据包当然是对这个听众来说，

73
00:04:43,189 --> 00:04:47,791
我真的不需要强调命名数据网络需求的必要性，但是

74
00:04:47,791 --> 00:04:52,175
我会强调，在战术环境或Gog环境中。

75
00:04:52,175 --> 00:04:56,045
机动性和动态性非常剧烈。

76
00:04:56,045 --> 00:04:59,285
要能够在客户端和

77
00:04:59,285 --> 00:05:00,995
要能够在客户端和服务器之间进行有效通信是非常具有挑战性的。

78
00:05:00,995 --> 00:05:05,055
这就是那些虚线代表间死连接的意思。

79
00:05:05,055 --> 00:05:10,385
反而，在SHARE计划中应用NDN，我们已经证明我们不仅可以

80
00:05:10,385 --> 00:05:17,070
通过在手持设备中对不同敏感级别的数据进行安全管理，

81
00:05:17,070 --> 00:05:22,190
但我们可以通过改进和提高我们对NDN（命名数据网络）所做的进步，进一步实现韧性网络。

82
00:05:22,190 --> 00:05:25,420
我们对NDN所做的进步。

83
00:05:25,420 --> 00:05:26,385
这再一次，

84
00:05:26,385 --> 00:05:31,625
下一位发言者将会详细介绍这些具体的增强功能。

85
00:05:34,652 --> 00:05:36,573
我们不得不做的一些事情包括：

86
00:05:36,573 --> 00:05:40,370
只是简要介绍一下如何适应战术使用NDN。

87
00:05:42,250 --> 00:05:45,166
从屏幕右侧的这张图表开始，

88
00:05:45,166 --> 00:05:50,330
我们实现了一个NDN或者

89
00:05:50,330 --> 00:05:57,030
我们将NDN数据包存储在手持设备中。

90
00:05:57,030 --> 00:06:03,400
我们系统内部有不同的桥接器和路由器。

91
00:06:03,400 --> 00:06:06,667
我们还能够连接并且~!@#$%^&*()

92
00:06:06,667 --> 00:06:12,830
桥接功能使得支持NDN的手机能够与非NDN网络连接。

93
00:06:12,830 --> 00:06:15,480
这就是你在右下角看到的内容。

94
00:06:15,480 --> 00:06:18,280
我们可以连接共享启用

95
00:06:18,280 --> 00:06:22,920
可以将战术突击工具包客户端与仅运行静态客户端的NDN连接起来。

96
00:06:22,920 --> 00:06:27,680
稍后在幻灯片上您可以看到我们已经

97
00:06:27,680 --> 00:06:32,790
为了适应这种动态环境，我们定制了一些数据同步技术。

98
00:06:32,790 --> 00:06:38,142
所以在后续的讨论中，您将会听到更多关于我们所采用的ICT汇聚点的信息。

99
00:06:38,142 --> 00:06:43,104
以及我们在NDN方面所做的额外改进。

100
00:06:47,304 --> 00:06:49,080
这其实只是一个总结。

101
00:06:49,080 --> 00:06:53,900
这其实只是一个总结。

102
00:06:53,900 --> 00:06:58,851
总结了我们对现有情况所做的不同改动。

103
00:06:58,851 --> 00:07:02,710
将NDN代码库修改使其适用于战术通信。

104
00:07:02,710 --> 00:07:07,904
我特别提到了不同的同步方式。

105
00:07:07,904 --> 00:07:11,330
我们所做的另一件事情涉及到

106
00:07:13,260 --> 00:07:19,350
我们采取分层方法来广播流量，以避免过度负荷网络，尤其是在非常动态的网络环境中。

107
00:07:19,350 --> 00:07:24,650
以免过度负担网络，尤其是在非常动态的网络环境中。

108
00:07:24,650 --> 00:07:29,280
为了应对单线程NFT实现，

109
00:07:29,280 --> 00:07:32,320
我们已经实施了技术手段来进一步实现负载均衡，以免过度拥堵网络中潜在的单一瓶颈点。

110
00:07:32,320 --> 00:07:36,620
不会拖慢网络中潜在的单一瓶颈点。

111
00:07:40,010 --> 00:07:44,710
我简要提到过我们确实有配置管理软件。

112
00:07:44,710 --> 00:07:49,070
这就是为了确保部署的便捷性和最终用户的易用性。

113
00:07:51,441 --> 00:07:54,421
我们最近举办了测试评估活动。

114
00:07:54,421 --> 00:07:57,361
作为第三阶段的一部分，Temar提到这是

115
00:07:57,361 --> 00:07:59,701
SHARE项目已经进行了好几年。

116
00:07:59,701 --> 00:08:02,431
我们正处于该项目的最后阶段。

117
00:08:03,440 --> 00:08:06,950
七月份的时候我们去了现场，

118
00:08:06,950 --> 00:08:11,580
我们有这种概念上的看法或者这种概念上的

119
00:08:11,580 --> 00:08:15,510
图表展示了我们在实地进行的实验。

120
00:08:15,510 --> 00:08:22,530
在我们外出的时候，我们不仅展示了SHARE与NDN结合使用的价值，

121
00:08:22,530 --> 00:08:26,400
但后来我们将SHARE从我们在网络上使用的手机上取下来，

122
00:08:26,400 --> 00:08:29,500
我们只是运行了一个不带SHARE的标准实现。

123
00:08:29,500 --> 00:08:33,411
当然，你也没有获得那种缓存带来的好处。

124
00:08:33,411 --> 00:08:37,872
同步功能已在SHARE NDN实现中为您提供。

125
00:08:40,348 --> 00:08:45,078
SHARE项目内还有另一个努力正在进行中，以

126
00:08:45,078 --> 00:08:49,390
探索将SHARE项目能力与5G技术结合起来。

127
00:08:49,390 --> 00:08:53,330
更具体地来说，研究我们如何能进一步隔离

128
00:08:53,330 --> 00:08:57,030
数据在不同敏感性级别上使用网络分片技术进行隔离。

129
00:08:57,030 --> 00:09:02,110
这是一个非常令人兴奋的项目，DARPA与国防部研究与工程副部长办公室联合进行。

130
00:09:02,110 --> 00:09:07,930
国防部研究与工程副部长办公室。

131
00:09:07,930 --> 00:09:12,768
我们在新的财政年度有一些演示即将举行。

132
00:09:12,768 --> 00:09:14,783
展示这种能力。

133
00:09:17,421 --> 00:09:19,397
我只想结束并且~!@#$%^&*()

134
00:09:19,397 --> 00:09:22,730
有点像是给你展示SHARE影响力的一种方式。

135
00:09:24,030 --> 00:09:28,670
那么对于每个DARPA项目来说，真正的目标是要将技术转化并应用到实际中。

136
00:09:28,670 --> 00:09:32,140
DARPA项目所产生的能力。

137
00:09:32,140 --> 00:09:36,860
我们与许多过渡合作伙伴建立了良好的伙伴关系，这些合作伙伴位于

138
00:09:36,860 --> 00:09:43,970
战术边缘社区，特别是第75游骑兵团

139
00:09:43,970 --> 00:09:47,940
以及远程医疗和先进技术研究中心。

140
00:09:47,940 --> 00:09:50,910
我们一直在根据他们的使用案例定制SHARE。

141
00:09:52,460 --> 00:09:54,620
当然，还有命名数据网络，

142
00:09:54,620 --> 00:09:58,700
提供弹性网络是这些努力的核心。

143
00:10:00,510 --> 00:10:05,660
这是一个NIST会议，感谢Lotfy因为

144
00:10:05,660 --> 00:10:10,680
与我们合作，我们将继续推动以确保这种兼容性。

145
00:10:10,680 --> 00:10:16,035
在政府、工业和学术界的使用案例中，对NDN的潜力感到特别兴奋。

146
00:10:16,035 --> 00:10:21,190
我们特别对公共安全使用的潜力感到兴奋。

147
00:10:21,190 --> 00:10:26,950
我们今天展示的除了军事用例之外，还有其他情况也同样适用。

148
00:10:28,520 --> 00:10:32,388
接下来，我将话筒交回给你，塔默。

149
00:10:32,388 --> 00:10:33,790
谢谢你，舒尔格特博士。

150
00:10:33,790 --> 00:10:35,270
恰到好处，真令人印象深刻。

151
00:10:36,660 --> 00:10:39,970
那么我们看看，我认为我们有时间来回答问题。

152
00:10:39,970 --> 00:10:42,310
我没有看到有人举手。

153
00:10:42,310 --> 00:10:44,054
有谁有问题吗？

154
00:10:51,748 --> 00:10:53,070
>> 我可能会快速问一个问题。

155
00:10:55,180 --> 00:10:59,340
程序的状态如何，下一步是什么？

156
00:11:01,150 --> 00:11:02,760
当然，这是个好问题。

157
00:11:02,760 --> 00:11:07,190
所以我刚才展示的最后一张幻灯片是关于SHARE过渡的。

158
00:11:07,190 --> 00:11:10,020
所以我们现在接近节目的尾声了。

159
00:11:10,020 --> 00:11:15,570
我们已经开发出了很多基础功能，

160
00:11:15,570 --> 00:11:16,800
我们的系统已经组建好了。

161
00:11:16,800 --> 00:11:21,750
现在真正的任务是定制SHARE解决方案，使其与

162
00:11:21,750 --> 00:11:26,650
潜在的过渡伙伴确保它适合他们的使用案例。

163
00:11:26,650 --> 00:11:31,046
我们现在真的很专注于定制SHARE。

164
00:11:34,085 --> 00:11:35,580
太棒了，我这边也有一个简单的问题。

165
00:11:35,580 --> 00:11:39,740
我是说，我认为SHARE正在进行的练习可能是我们已经达到了一个基于NDN的可部署解决方案最接近的。

166
00:11:39,740 --> 00:11:42,290
我们已经得到了一个基于NDN的可部署解决方案。

167
00:11:42,290 --> 00:11:46,438
很高兴看到DARPA的项目考虑了NDN。

168
00:11:46,438 --> 00:11:47,092
你看到了吗？在SHARE之后的NDN，其他DARPA项目也需要你考虑这项技术。

169
00:11:47,092 --> 00:11:52,120
SHARE之后的NDN，其他DARPA项目也需要你考虑这项技术。

170
00:11:53,140 --> 00:11:55,290
不，但还是谢谢你的提问。

171
00:11:55,290 --> 00:11:59,880
是的，我认为SHARE仅仅触及了价值的表面，以及

172
00:11:59,880 --> 00:12:05,420
NDN的能力使得在非常动态的网络环境中实现弹性网络。

173
00:12:05,420 --> 00:12:09,900
符合国防部使用案例的情景。

174
00:12:09,900 --> 00:12:16,500
我认为我们正在进行的5G工作也同样预示着这一未来。

175
00:12:18,610 --> 00:12:23,240
未来的国家宽带网络特别是在国防部内部，但是在商业世界里也可能。

176
00:12:23,240 --> 00:12:28,630
也可能在商业世界中。

177
00:12:28,630 --> 00:12:29,360
>> 非常感谢，我很感激。

178
00:12:29,360 --> 00:12:31,270
非常感谢，舒尔戈特博士。

179
00:12:36,910 --> 00:12:42,761
那么，让我们继续下一位演讲者。

180
00:12:42,761 --> 00:12:45,800
我们下一位演讲者是康斯坦丁·瑟班。

181
00:12:45,800 --> 00:12:49,450
他是Perspecta Labs的首席科学家。

182
00:12:49,450 --> 00:12:54,970
他是Perspecta Labs DARPA SHARE非常重要网络项目的共同首席研究员。

183
00:12:54,970 --> 00:12:57,980
康斯坦丁·塞尔班在网络领域拥有十多年的经验，

184
00:12:57,980 --> 00:12:59,510
尤其专注于无线网络，

185
00:12:59,510 --> 00:13:03,640
网络协议以及网络堆栈各层的安全性。

186
00:13:05,100 --> 00:13:06,408
康斯坦丁，轮到你发言了。

187
00:13:06,408 --> 00:13:09,491
好的，太好了。

188
00:13:09,491 --> 00:13:13,660
所以今天我想谈谈PLI-Sync，

189
00:13:13,660 --> 00:13:18,080
这是一种对于NDN群组流媒体的预取损失不敏感同步协议。

190
00:13:19,100 --> 00:13:26,121
这是我们在DARPA SHARE项目期间开发的一种同步协议，

191
00:13:26,121 --> 00:13:31,694
我们专门为Schurgot博士之前提到的，上一次演讲中的条件而开发它。

192
00:13:31,694 --> 00:13:36,833
Schurgot博士之前提到的，上一次演讲中的。

193
00:13:36,833 --> 00:13:39,305
这是与……的联合工作，

194
00:13:39,305 --> 00:13:44,975
这是与我们的学术合作伙伴Lan、Alex和Lixia的联合工作，

195
00:13:46,750 --> 00:13:50,290
我将直接深入讲话的主题。

196
00:13:50,290 --> 00:13:53,240
我们在这里尝试解冑的问题是

197
00:13:53,240 --> 00:13:59,110
我们在这里尝试解冑的问题是如何提供群组多方流数据传输。

198
00:13:59,110 --> 00:14:03,970
所以我们都知道NDN非常适合~!@#$%^&*()

199
00:14:03,970 --> 00:14:10,408
提供静态内容或预生成的内容。

200
00:14:11,660 --> 00:14:18,430
提供预先生成的内容，可以从不同的生产者那里获取，

201
00:14:18,430 --> 00:14:23,990
并且基本上利用了所有的缓存功能

202
00:14:23,990 --> 00:14:29,626
并且在检索此类内容时考虑了网络群组和兴趣聚合。

203
00:14:29,626 --> 00:14:34,795
然而，当我们观察群组

204
00:14:34,795 --> 00:14:41,080
我们观察多方数据流传输时，会关注动态内容的生成。

205
00:14:41,080 --> 00:14:48,550
所以基本上是即时动态生成的数据，没有类似于

206
00:14:48,550 --> 00:14:54,140
批量生成，你有一种像是一个大文件或一个大数据块的东西

207
00:14:54,140 --> 00:14:59,440
一次性生成然后在一定时间内逐块提供服务。

208
00:14:59,440 --> 00:15:03,160
而且内容是动态生成的，

209
00:15:03,160 --> 00:15:08,280
但是数据生成的间隔可能是随机的。

210
00:15:08,280 --> 00:15:13,010
您可以将其视为事件驱动而非排序。

211
00:15:13,010 --> 00:15:18,060
像定期数据生成这样的。

212
00:15:18,060 --> 00:15:22,710
像定期数据生成这样的，基本上是我们需要解决的关键工具。

213
00:15:22,710 --> 00:15:27,720
基本上是我们需要解决的关键工具。

214
00:15:27,720 --> 00:15:33,130
而这项工作的目标不仅仅是要

215
00:15:33,130 --> 00:15:38,170
提供针对这种动态和随机数据生成的解决方案，

216
00:15:38,170 --> 00:15:43,060
但也要在断开连接的情况下运行

217
00:15:43,060 --> 00:15:48,330
间歇性连接环境中，操作视频需要减少带宽。

218
00:15:49,600 --> 00:15:55,150
因此这自然要求解决方案必须具有非常低的开销。

219
00:15:55,150 --> 00:16:00,500
在低延迟，相对较低的延迟中，这就是事件驱动的通信。

220
00:16:00,500 --> 00:16:05,050
这种传输的时机会产生很大的差异。

221
00:16:06,160 --> 00:16:12,730
这基本上是要在网络上操作，其中的连接时而建立时而中断。

222
00:16:12,730 --> 00:16:18,660
这基本上是要在网络上操作，其中的连接时而建立时而中断。如果你经常遇到网络部分或永久性的中断，那么你就会面对频繁的网络故障。

223
00:16:18,660 --> 00:16:23,222
这可能是指网络分区，无论是暂时的还是永久性的。

224
00:16:23,222 --> 00:16:27,605
它可能是一般的退化情况，其中

225
00:16:27,605 --> 00:16:31,987
它可能是一般的退化情况，其中网络被命名为永不收敛以具有某种意义，square network path available at any given time.

226
00:16:31,987 --> 00:16:35,757
任何给定时间都可用的方形网络路径。

227
00:16:35,757 --> 00:16:40,377
所以你总是有一组子链接集合。

228
00:16:40,377 --> 00:16:48,230
所以我基本上已经完成了，而且主要的割可能是网络图的零割。

229
00:16:48,230 --> 00:16:53,210
所以这就是我们在这个环境中试图解决的问题类型。

230
00:16:55,100 --> 00:17:01,310
所以，我们特别关注同步协议是因为

231
00:17:01,310 --> 00:17:07,740
通常情况下，事件驱动的动态数据生产是通过同步协议来解决的。

232
00:17:07,740 --> 00:17:12,060
在MDM中传统的同步协议方法中，

233
00:17:12,060 --> 00:17:17,750
你有同步协议和数据平面协议之间的清晰分离。

234
00:17:17,750 --> 00:17:21,550
基本上，生产者通过同步协议通知消费者当数据通过同步协议产生时。

235
00:17:21,550 --> 00:17:25,170
消费者在数据通过同步协议生成时得到通知。

236
00:17:25,170 --> 00:17:30,408
所以同样的协议就是用来通知消费者数据已经

237
00:17:30,408 --> 00:17:35,477
已经生成，而且，当然，如果你想要低延迟因为事情

238
00:17:35,477 --> 00:17:40,140
在sink协议中需要立即通知消费者。

239
00:17:40,140 --> 00:17:44,776
然后数据平面中的消费者基本上获取主要数据。

240
00:17:44,776 --> 00:17:48,820
从同一协议中提取数据。

241
00:17:48,820 --> 00:17:54,110
而这种方法的问题在于，你会在某种意义上产生大量额外开销。

242
00:17:54,110 --> 00:17:58,260
你必须为你获取的每一条数据单独发送通知。

243
00:17:58,260 --> 00:18:04,340
获取产品后，你必须通知消费者。

244
00:18:04,340 --> 00:18:08,350
此外，基本上转移数据问题利益和

245
00:18:08,350 --> 00:18:09,820
转移数据。

246
00:18:09,820 --> 00:18:14,680
这通常在你批量生产数据时不会成为问题。

247
00:18:14,680 --> 00:18:17,520
同步只适用于某种程度上类似的情况。

248
00:18:17,520 --> 00:18:23,150
但是批量数据通知会

249
00:18:23,150 --> 00:18:28,857
当你逐件生产数据时，开销会变得非常

250
00:18:28,857 --> 00:18:33,360
显著且。

251
00:18:33,360 --> 00:18:39,650
考虑到这些限制和需求，我们提出的方法是，

252
00:18:39,650 --> 00:18:43,680
采用一种数据平面和 控制平面之间的混合方法，

253
00:18:43,680 --> 00:18:49,280
采用乐观内容预取的同一数据平面。

254
00:18:50,410 --> 00:18:54,583
采用乐观内容预取的方式，

255
00:18:54,583 --> 00:19:00,561
采用低延迟和低开销，或者基本没有开销的方式，

256
00:19:00,561 --> 00:19:05,750
采用基于向量的同步协议来补充用户。

257
00:19:05,750 --> 00:19:10,599
该方法修复了乐观策略中的一些问题。

258
00:19:10,599 --> 00:19:15,899
内容预取引入了一个小的，

259
00:19:15,899 --> 00:19:21,570
固定开销是这种网络中必需的。

260
00:19:21,570 --> 00:19:26,195
转到下一张幻灯片，基本上我们的方法是

261
00:19:26,195 --> 00:19:30,160
由于乐观预取和

262
00:19:30,160 --> 00:19:35,224
节点模型中的状态向量同步协议可以被看到

263
00:19:35,224 --> 00:19:40,570
图中右下角实际上是一个应用程序。

264
00:19:40,570 --> 00:19:45,430
我的意思是一个节点包含了一个应用程序。

265
00:19:45,430 --> 00:19:50,550
NDN部分基本上是流媒体，NDN应用程序和

266
00:19:50,550 --> 00:19:55,510
NFT及其在应用中的存在本身构成

267
00:19:55,510 --> 00:19:59,660
的部分同步协议一个消费者和

268
00:19:59,660 --> 00:20:04,030
生产者、消费者以及生产者在数据平面中驻留。

269
00:20:04,030 --> 00:20:06,770
基本上是发送兴趣包并接收数据包，

270
00:20:08,280 --> 00:20:13,530
负责将其发送至应用层和同步平面。

271
00:20:13,530 --> 00:20:18,600
负责发现数据生成和

272
00:20:18,600 --> 00:20:23,270
负责通知数据可用性的。

273
00:20:24,930 --> 00:20:30,144
因此，在乐观预取中，我们采用了这种团队导向的方式。

274
00:20:30,144 --> 00:20:36,878
在这个命名空间中，数据被建模为带有前缀的生产者身份的数据。

275
00:20:36,878 --> 00:20:42,110
每条数据的身份和序列号。

276
00:20:42,110 --> 00:20:46,012
在消费者接收到一条数据后

277
00:20:46,012 --> 00:20:50,979
积极地对下一个序列号表示出兴趣，并且

278
00:20:50,979 --> 00:20:54,450
这就是我们所说的乐观预取。

279
00:20:57,000 --> 00:21:03,150
这种互动发生之前

280
00:21:03,150 --> 00:21:08,150
甚至在未收到任何通知或完全没有通知的情况下。

281
00:21:09,310 --> 00:21:13,620
在数据产生之前，就发出了对其的关注。

282
00:21:13,620 --> 00:21:15,390
在数据产生之后。

283
00:21:15,390 --> 00:21:20,590
生产者要生产的或者生产者要生成的下一个事件。

284
00:21:22,360 --> 00:21:27,520
考虑到数据并非生产物

285
00:21:28,580 --> 00:21:33,720
我们只是定期地使用一个固定且众所周知的周期。

286
00:21:33,720 --> 00:21:39,240
我们需要使用启发式和学习方法来设定兴趣，

287
00:21:39,240 --> 00:21:45,420
我们需要使用启发式和学习方法来设定兴趣，这种乐观的预取方法即便没有任何同步协议也能工作得很好。

288
00:21:45,420 --> 00:21:51,290
这种乐观的预取方法即便没有任何同步协议也能工作得很好。

289
00:21:51,290 --> 00:21:55,450
然而，它存在引导程序的问题，以及

290
00:21:55,450 --> 00:21:59,380
在有损环境中的操作。

291
00:21:59,380 --> 00:22:06,450
为了解决这个问题，我们使用了一个状态向量同步协议，该协议在有损环境中的操作，supplements the optimistic prefetching and。

292
00:22:06,450 --> 00:22:12,395
补充了乐观预取技术。

293
00:22:12,395 --> 00:22:15,225
状态向量同步协议产生了

294
00:22:15,225 --> 00:22:18,975
定期基于状态向量的兴趣通知。

295
00:22:18,975 --> 00:22:22,565
状态向量包含每个流的最新序列号。

296
00:22:23,885 --> 00:22:29,012
对于每个用户，该向量

297
00:22:29,012 --> 00:22:34,033
对于每个节点生成的，不管它是否产生数据。

298
00:22:34,033 --> 00:22:38,740
无论它是否产生数据。

299
00:22:38,740 --> 00:22:40,380
再次确定范围。

300
00:22:40,380 --> 00:22:46,930
确定数据状态向量路由协议的目的是

301
00:22:46,930 --> 00:22:52,540
在丢包环境中提供引导和操作。

302
00:22:55,390 --> 00:23:03,979
转到下一张幻灯片，我们将提供有关我们方法的更多细节。

303
00:23:03,979 --> 00:23:09,046
在我们的付费操作中重要的是

304
00:23:09,046 --> 00:23:16,680
向量同步协议的事实在于状态因子更新了状态。

305
00:23:16,680 --> 00:23:21,316
但是生产者，以及消费者和消费者以及

306
00:23:21,316 --> 00:23:25,753
数据平面以及汇聚层中的消费者，以及

307
00:23:25,753 --> 00:23:30,782
消费者数据平面中状态向量的更新是其中之一

308
00:23:30,782 --> 00:23:37,110
影响我们解决方案和海岸的最大因素的组件。

309
00:23:37,110 --> 00:23:42,522
在数据检索的低延迟方面，所以，

310
00:23:42,522 --> 00:23:48,230
特别是中间的那两个部件

311
00:23:48,230 --> 00:23:53,939
向量状态更新代表了最关键的

312
00:23:53,939 --> 00:23:59,520
考虑到PLI同步的性能因素。

313
00:24:02,970 --> 00:24:06,870
重新组织，消费者急切地获取数据。

314
00:24:06,870 --> 00:24:16,100
这确保了数据遵循八向量传播模式。

315
00:24:16,100 --> 00:24:20,780
消费者节点的本地NFD基本上缓存了数据。

316
00:24:20,780 --> 00:24:26,288
因此，PLI Sync允许在断开的网络中进行数据获取。

317
00:24:26,288 --> 00:24:31,174
并将图形放置在右侧基本上描述了功能。

318
00:24:31,174 --> 00:24:34,649
在这样一个断开连接的网络中，节点A，为了

319
00:24:34,649 --> 00:24:39,069
例如，生成最新数据的SQL命令是第15号。

320
00:24:40,300 --> 00:24:46,634
每当它与节点B建立某种形式的链接连接时，

321
00:24:46,634 --> 00:24:52,400
节点B得知节点A的序列号为15。

322
00:24:52,400 --> 00:24:58,614
并且之后每当节点B与节点C取得联系时，

323
00:24:58,614 --> 00:25:04,180
它还会通知节点C，A处于序列15。

324
00:25:04,180 --> 00:25:10,660
到节点C主动获取数据的时候

325
00:25:10,660 --> 00:25:15,910
被通知关于状态，节点A相同的状态，

326
00:25:15,910 --> 00:25:19,950
在那时，它也可以直接从

327
00:25:19,950 --> 00:25:25,554
节点B的NFD缓存内容存储。

328
00:25:25,554 --> 00:25:32,341
所以这带来了非常稳健的运作。

329
00:25:32,341 --> 00:25:36,590
讨论一些结果。

330
00:25:36,590 --> 00:25:41,280
讨论一些结果。在左边，左上方，我们评估了这个网络拓扑的实施情况。

331
00:25:42,380 --> 00:25:47,060
评估了这个实施情况

332
00:25:47,060 --> 00:25:51,660
某种程度上可重复的环境。

333
00:25:51,660 --> 00:25:58,160
我们在许多场景中在自然的物理手机上运行它，

334
00:25:58,160 --> 00:26:02,940
在各种情况下。

335
00:26:02,940 --> 00:26:09,070
在这里展示的结果仅仅是环境，是受控环境。

336
00:26:09,070 --> 00:26:16,170
50个节点分为每个接入点5个物理组。

337
00:26:17,340 --> 00:26:21,363
每个节点既是生产者也是消费者。

338
00:26:21,363 --> 00:26:24,269
每个节点之间的链接及

339
00:26:24,269 --> 00:26:29,969
其自身的接入点在上行链路和下行链路中都有20%的丢包率，

340
00:26:29,969 --> 00:26:35,810
所以当你观察端到端路径时，丢包率相当严重。

341
00:26:37,830 --> 00:26:42,986
所以在度量标准方面，我们使用的是整体兴趣到数据比率，

342
00:26:42,986 --> 00:26:47,850
数据兴趣与数据比率，同步兴趣与数据比率，

343
00:26:47,850 --> 00:26:52,730
和整体效率以及- >> [听不清] 如果你想的话，有一分钟时间

344
00:26:52,730 --> 00:26:54,810
离开时间给- >> 你说得对。

345
00:26:54,810 --> 00:26:55,950
>> 问题。

346
00:26:55,950 --> 00:27:01,890
>> 所以仅仅为了强调，效率

347
00:27:01,890 --> 00:27:06,850
与部分同步相比，效率非常高。

348
00:27:06,850 --> 00:27:14,350
与利息比率相比，你可以看到488对比188。

349
00:27:14,350 --> 00:27:19,420
与消费者数据平面的贡献相比，这是最大的贡献。

350
00:27:19,420 --> 00:27:26,580
相比于同步平面，正如表格中间那一行所展示的。

351
00:27:26,580 --> 00:27:31,280
还有许多未来的工作。

352
00:27:31,280 --> 00:27:36,110
拥塞控制，非对称群组，生产的可预测性。

353
00:27:36,110 --> 00:27:38,280
非常感谢你。

354
00:27:38,280 --> 00:27:40,330
寻找问题。

355
00:27:42,390 --> 00:27:43,280
>> 谢谢康斯坦丁。

356
00:27:43,280 --> 00:27:44,870
感谢这次演讲。

357
00:27:44,870 --> 00:27:48,000
我认为我们还有时间快速回答一个问题。

358
00:27:48,000 --> 00:27:49,767
我将会读取聊天中的一个问题。

359
00:27:49,767 --> 00:27:52,700
当然可以，如果你不介意的话，请你快速解释一下。

360
00:27:52,700 --> 00:27:58,110
如何区分乐观预取与自适应池化。

361
00:27:58,110 --> 00:28:01,130
>> 有一种自适应池化的形式。

362
00:28:01,130 --> 00:28:08,705
你会在数据生成之前就消耗掉这些数据。

363
00:28:08,705 --> 00:28:13,404
所以在一个自适应的情况下，如果你考虑的是类似于拥塞控制这样的情况，

364
00:28:13,404 --> 00:28:17,705
算法会根据情况调整你的关注度。

365
00:28:17,705 --> 00:28:21,466
你是基于这里的网络条件被采纳的。

366
00:28:21,466 --> 00:28:24,969
你是在数据生成时就适应了，所以

367
00:28:24,969 --> 00:28:29,230
你甚至在数据生成之前就表现出了兴趣，

368
00:28:29,230 --> 00:28:33,776
你只需等待制作者实际上满足

369
00:28:33,776 --> 00:28:38,795
你只需直接满足兴趣，而不是等待网络去满足或

370
00:28:38,795 --> 00:28:44,410
你只需直接满足兴趣，而不是等待网络去满足那种兴趣。>> Okay, but that sounds good.

371
00:28:44,410 --> 00:28:47,065
好的，听起来不错。

372
00:28:47,065 --> 00:28:51,685
所以我认为大卫在聊天中提了一个问题，如果你可以尝试跟进一下。

373
00:28:51,685 --> 00:28:55,570
所以我建议你跟他进行一次聊天，以确保这听起来不错。

374
00:28:55,570 --> 00:28:57,390
所以我们将继续进行下一个演示。

375
00:28:57,390 --> 00:28:59,220
谢谢康斯坦丁，那太棒了。

376
00:28:59,220 --> 00:28:59,980
是的。

377
00:28:59,980 --> 00:29:03,940
>> 我们下一个报告将由约翰·德哈特进行。

378
00:29:03,940 --> 00:29:08,180
约翰是应用研究实验室的高级研究科学家。

379
00:29:08,180 --> 00:29:10,150
他在圣路易斯的华盛顿大学从事网络原型研究和开发工作。

380
00:29:10,150 --> 00:29:14,134
他一直致力于网络原型的研究与开发工作，

381
00:29:14,134 --> 00:29:18,050
他过去31年一直致力于网络测试平台的部署和管理工作，

382
00:29:18,050 --> 00:29:21,714
他还是Two Six Labs DARPA SHARE团队的一部分。

383
00:29:21,714 --> 00:29:26,215
他目前还管理着Open Network Lab。

384
00:29:26,215 --> 00:29:32,047
华盛顿大学圣路易斯分校，以及一个全球性的NDN测试平台。

385
00:29:32,047 --> 00:29:32,979
轮到你了，约翰。

386
00:29:32,979 --> 00:29:33,634
继续吧。

387
00:29:33,634 --> 00:29:35,260
好的，谢谢。

388
00:29:35,260 --> 00:29:39,060
好的，是的，正如你所说，我是来自华盛顿大学的约翰·德哈特。

389
00:29:39,060 --> 00:29:42,990
标准免责声明，所有这些工作都得到了DARPA的支持，但是

390
00:29:42,990 --> 00:29:45,040
这些是我的观点。

391
00:29:45,040 --> 00:29:50,150
只是简单介绍一下为什么华盛顿大学会参与这个项目。

392
00:29:50,150 --> 00:29:53,135
这是因为开放网络实验室。

393
00:29:53,135 --> 00:29:59,150
ONL是一个我们构建并运营的可通过互联网访问的网络测试平台。

394
00:29:59,150 --> 00:30:04,760
通过它我们可以快速模拟各种网络拓扑结构和

395
00:30:04,760 --> 00:30:06,240
条件。

396
00:30:06,240 --> 00:30:11,290
包括可变的链路带宽、链路丢失、延迟等等。

397
00:30:12,600 --> 00:30:18,270
我们于2016年开始了一个种子基金项目，以支持

398
00:30:18,270 --> 00:30:23,460
乔·埃文斯在那里我们使用了ONL来展示NDN是如何

399
00:30:23,460 --> 00:30:29,870
在这些具有挑战性的战术条件下，能够胜过IP。

400
00:30:29,870 --> 00:30:34,470
然后从2017年开始，我们开始参与DARPA SHARE项目的工作。

401
00:30:34,470 --> 00:30:38,610
项目作为Two Six Labs领导的团队的一部分。

402
00:30:38,610 --> 00:30:43,270
这项工作专注于安全的Android手持设备。

403
00:30:43,270 --> 00:30:46,900
在这些具有挑战性的战术网络中。

404
00:30:46,900 --> 00:30:51,480
网络挑战包括低带宽连接、丢包连接、

405
00:30:51,480 --> 00:30:57,090
间歇性连接以及暂时性分段网络。

406
00:30:57,090 --> 00:31:01,940
该项目最初的重点是通过WiFi在Android上进行。

407
00:31:01,940 --> 00:31:07,850
该项目最初的重点是通过WiFi在Android上进行，后来转向使用战术无线电。

408
00:31:07,850 --> 00:31:13,620
将安卓手机通过战术无线电连接成网状网络。

409
00:31:13,620 --> 00:31:19,380
问题再次是，NDN是否能提供更可靠的传输方式？

410
00:31:19,380 --> 00:31:23,960
那么对于这些战术应用程序来说，NDN是否能提供比现有的底层网络更可靠的传输方式呢？

411
00:31:25,850 --> 00:31:30,480
所以只是为了感谢DARPA团队，我们已经有了三位项目经理，分别是Joe Evans、Paul Zablocky，现在是Mary Schurgot。

412
00:31:30,480 --> 00:31:35,115
从Joe Evans、Paul Zablocky开始，到现在的Mary Schurgot，都是项目经理。

413
00:31:35,115 --> 00:31:40,710
他们的支持团队在支持这个项目方面做得非常好。

414
00:31:40,710 --> 00:31:44,960
我们的主要承包商，Two Six Labs 和

415
00:31:44,960 --> 00:31:49,855
许多分包商，我只想强调其中的两个实体，

416
00:31:49,855 --> 00:31:54,730
Two Six Labs和Eucleo完成了大部分的NDN开发工作。

417
00:31:54,730 --> 00:32:02,370
我们在华盛顿大学的角色就是进行这种情景模拟。

418
00:32:02,370 --> 00:32:06,730
因此，我认为这是一个关键点，它在某种程度上与此次讨论小组的内容相关联。

419
00:32:06,730 --> 00:32:12,890
早上，我们也是印度项目团队的一部分。

420
00:32:12,890 --> 00:32:16,180
我们并不是负责这个项目的印度开发工作。

421
00:32:16,180 --> 00:32:20,490
是这些承包商在做这个工作，这是一个重大的步骤。

422
00:32:20,490 --> 00:32:22,351
我认为对于国家宽带网络(NBN)来说。

423
00:32:23,889 --> 00:32:29,060
所以我们从Android进行的转变的那个物理架构，

424
00:32:29,060 --> 00:32:33,953
通过Wi-Fi和蜂窝网络到Android手机进行通信

425
00:32:33,953 --> 00:32:39,219
通过这些战术无线电设备造成了更为严酷的基础

426
00:32:39,219 --> 00:32:44,090
这些战术无线电设备造成了比我们项目早期更为严酷的网络条件。

427
00:32:44,090 --> 00:32:49,070
在这两种情况下，总是存在着这样的状况，

428
00:32:49,070 --> 00:32:53,980
在这两种情况下，总是存在着这样的状况，随着人员携带这些手机在现场移动，它们之间的导电性在变化。

429
00:32:53,980 --> 00:32:58,440
在现场移动的手机之间，它们的相互导电性在变化。

430
00:32:58,440 --> 00:33:05,380
这些网状网络将会发生变化，我们的应用程序又将如何适应这种变化呢？

431
00:33:05,380 --> 00:33:10,110
我们的网络如何适应这种变化？

432
00:33:10,110 --> 00:33:11,720
所以MDN和DARPA共享。

433
00:33:11,720 --> 00:33:16,690
我们目前仍然使用MDN 066作为我们的代码基础，但是

434
00:33:16,690 --> 00:33:21,320
我们正在考虑更新当前版本。

435
00:33:21,320 --> 00:33:25,600
我们利用的NDN的一些优势包括同步功能，

436
00:33:25,600 --> 00:33:28,260
策略层和安全模型。

437
00:33:28,260 --> 00:33:32,720
这些对于我们取得的成功都非常重要。

438
00:33:33,740 --> 00:33:38,180
起初，我们确实对NDN的性能有些抱怨。

439
00:33:38,180 --> 00:33:42,790
但随着我们的转变，这已经不再是一个大问题。

440
00:33:42,790 --> 00:33:48,610
尝试在大约25个节点的拓扑结构上使用这些低带宽网络。

441
00:33:50,430 --> 00:33:56,560
我们所做的NDN修改可以说是一种进化。

442
00:33:56,560 --> 00:34:00,320
所以我们将找到网络问题的原因或者

443
00:34:00,320 --> 00:34:03,370
所以我们将找到网络问题的原因或者一个过载然后解决它。

444
00:34:03,370 --> 00:34:08,350
今天早上我再次被那个小组击中了，你可以认为这其中的一些内容是...

445
00:34:08,350 --> 00:34:13,370
在Jeff Burke提到的混乱活力方法方面。

446
00:34:14,510 --> 00:34:18,660
我们作为这个项目，不需要

447
00:34:20,230 --> 00:34:24,440
维护与印度项目其他部分的代码库。

448
00:34:24,440 --> 00:34:28,240
我们可以做出改变，而不必担心满足其他所有人。

449
00:34:28,240 --> 00:34:30,610
因此我们可以有点杂乱无章，做我们想做的事情。

450
00:34:31,850 --> 00:34:36,200
我将在接下来的幻灯片中讨论其中的一些修改。

451
00:34:38,240 --> 00:34:40,190
So ICT 同步。

452
00:34:40,190 --> 00:34:43,250
它是由华盛顿的希拉·范·亚伯拉罕开发的。

453
00:34:43,250 --> 00:34:46,360
她作为她博士论文工作的一部分，

454
00:34:46,360 --> 00:34:51,980
它是一个包含参与者的多生产者同步协议。

455
00:34:51,980 --> 00:34:57,280
它在同步兴趣名中查看同步树状态的视图。

456
00:34:57,280 --> 00:35:00,920
所以当一个参与者收到一个同步兴趣时，

457
00:35:00,920 --> 00:35:06,330
它可以立刻从那个兴趣中的同步名称中得知，

458
00:35:06,330 --> 00:35:12,030
它如何将其他人所看到的树的状态与自己所看到的进行比较，以及

459
00:35:12,030 --> 00:35:17,240
立即知道是否有新数据需要检索。

460
00:35:19,370 --> 00:35:23,960
显然，这里存在一个潜在的名称大小缩放问题。

461
00:35:23,960 --> 00:35:28,900
但就我们在DARPA共享的工作当前范围而言，它还没有

462
00:35:28,900 --> 00:35:29,830
成为一个问题。

463
00:35:29,830 --> 00:35:34,110
所以它还没有上升到我们觉得需要解决那个问题的程度，但是

464
00:35:34,110 --> 00:35:36,530
它是未来工作的内容。

465
00:35:39,210 --> 00:35:44,120
因此，下一个修改是优先考虑本地的多播策略。

466
00:35:44,120 --> 00:35:51,110
在这些网状拓扑中我们发现，将多播作为策略来进行

467
00:35:51,110 --> 00:35:54,510
同步兴趣增加了网络中的大量流量。

468
00:35:54,510 --> 00:35:58,510
这和康斯坦丁刚才讨论的同步兴趣是类似的，

469
00:35:58,510 --> 00:36:02,150
这会给网络增加很多数据，导致网络过载。

470
00:36:02,150 --> 00:36:04,550
所以我们开始研究减少这种情况的方法。

471
00:36:04,550 --> 00:36:09,280
我们提出了一种我们称之为本地优先多播的策略。

472
00:36:09,280 --> 00:36:12,310
因此，在我们的每一个节点中，都有一个NFT和

473
00:36:12,310 --> 00:36:15,960
所以，在我们的每一个节点中，都有一个NFT和一个应用程序在使用同步。

474
00:36:15,960 --> 00:36:22,300
如果一个兴趣到达了那个本地接口的NFT，

475
00:36:22,300 --> 00:36:28,420
如果已经注册了一个匹配的前缀，那么NFT将只发送到那个本地接口。

476
00:36:28,420 --> 00:36:30,570
如果没有匹配的本地接口，

477
00:36:30,570 --> 00:36:33,469
那么兴趣就会被多播到所有远程接口。

478
00:36:34,690 --> 00:36:37,450
将会从本地同步应用中产生兴趣。

479
00:36:37,450 --> 00:36:41,460
将始终被多播到所有远程接口。

480
00:36:41,460 --> 00:36:47,150
这样做的目的是给本地同步应用程序一个机会来合并它的状态

481
00:36:47,150 --> 00:36:52,140
在发送多播给所有邻居之前，先与任何传入的状态合并。

482
00:36:52,140 --> 00:36:57,190
那么让我们看一下下一张幻灯片，它是如何为我们展现性能的。

483
00:36:57,190 --> 00:37:03,930
那么我们这里的测试配置有25个完全连接的节点。

484
00:37:03,930 --> 00:37:09,650
每个同步应用将以每秒五个数据块的速度产生100个数据块的数据。

485
00:37:09,650 --> 00:37:14,470
底部的图表展示了实时监控图表。

486
00:37:14,470 --> 00:37:19,480
它们显示了我们网络上的即时链接带宽。

487
00:37:20,490 --> 00:37:25,820
这些你看到的每个脉冲的宽度是一种快速衡量多长时间的方法

488
00:37:25,820 --> 00:37:32,290
对于一个非常成功的实验，所有节点接收所有数据所需的时间应该是大约20秒，对于我们发送的数据来说。

489
00:37:32,290 --> 00:37:38,810
对于我们发送的数据来说，一个非常成功的实验，所有节点接收所有数据所需的时间应该是大约20秒。

490
00:37:38,810 --> 00:37:44,300
在这些图表中，我们比较的是标准MDM和Sharon dn。

491
00:37:44,300 --> 00:37:50,780
在这些图表中，我们还比较了使用多播与首先本地多播进行同步的情况。

492
00:37:50,780 --> 00:37:54,550
在所有这些情况下的数据策略是多播，

493
00:37:54,550 --> 00:37:58,770
链路带宽是每秒八兆比特。

494
00:37:58,770 --> 00:38:04,410
从这些图表中我们可以清楚地看到，仅仅通过对一小时的实验数据分析，

495
00:38:05,440 --> 00:38:11,530
我们从使用本地优先多播中获得的改进，但即便如此，

496
00:38:11,530 --> 00:38:17,070
我们仍然受限于那个每秒八兆比特的链路速度。

497
00:38:17,070 --> 00:38:19,743
因此我们仍然在丢失数据传输。

498
00:38:19,743 --> 00:38:23,603
因此我们在数据检索时可能仍会遇到一些延迟问题。

499
00:38:26,038 --> 00:38:30,603
因此，我们接下来研究的是减少网络流量的方法。

500
00:38:30,603 --> 00:38:31,880
在数据方面。

501
00:38:31,880 --> 00:38:36,810
会在一个25节点的网状网络中向所有节点使用多播

502
00:38:36,810 --> 00:38:39,410
产生了大量额外的流量。

503
00:38:39,410 --> 00:38:44,290
所以我们研究了如果将节点划分为重叠的

504
00:38:44,290 --> 00:38:45,494
社区。

505
00:38:45,494 --> 00:38:49,341
这里我们有一个包含25个节点的社区范围。

506
00:38:49,341 --> 00:38:52,953
两个由13个节点组成的邻域直至一个雏菊链。

507
00:38:52,953 --> 00:38:56,264
由两个节点组成的邻域。

508
00:38:56,264 --> 00:39:00,928
对于这组实验，我将向您展示的是我们让每个节点产生

509
00:39:00,928 --> 00:39:03,368
在这组实验中，我将向您展示的是我们让每个节点产生1000个数据块，速度为每秒5个，而且连接速度再次限制为每秒八兆比特。

510
00:39:03,368 --> 00:39:06,916
连接速度再次限制为每秒八兆比特。

511
00:39:06,916 --> 00:39:11,427
在接下来的幻灯片中，ol监控图正在监控那些节点。

512
00:39:11,427 --> 00:39:14,672
在这些邻域图中，它们被编上了色码。

513
00:39:14,672 --> 00:39:20,408
对于这组实验，我们预先配置了静态的邻域。

514
00:39:20,408 --> 00:39:24,205
这并不一定是一个现实的情况，但是

515
00:39:24,205 --> 00:39:29,035
我们会在我们谈论过的下一次修改中解决这个问题。

516
00:39:29,035 --> 00:39:34,621
所以这又是一个用于在拓扑结构上运行实验的在线监控图表。

517
00:39:34,621 --> 00:39:37,239
具有不同边的邻域，

518
00:39:37,239 --> 00:39:42,321
我们在最左边有一个25个节点的邻域，然后是13个，6个，4个，以及

519
00:39:42,321 --> 00:39:47,557
我们在每个实验中向右侧有两个节点的邻域使用

520
00:39:47,557 --> 00:39:52,410
本地首先使用多播策略进行同步，然后使用多播策略进行数据传输。

521
00:39:52,410 --> 00:39:56,268
您可以看到，正如您所预期的那样，当我们减小邻域的大小时，

522
00:39:56,268 --> 00:39:58,230
交通负载减少了。

523
00:39:58,230 --> 00:40:02,850
我们还看到，正如你所预期的，那些连接的节点

524
00:40:02,850 --> 00:40:07,910
到邻居的节点比其他节点有更高的负载。

525
00:40:07,910 --> 00:40:15,677
所以这个结果促使我们开发了我们所称的随机投递和策略。

526
00:40:15,677 --> 00:40:20,336
所以随机投递N是我们用于数据流量的一种策略。

527
00:40:20,336 --> 00:40:24,649
所以我们有节点，它们有M个面，而M的数值很大，

528
00:40:24,649 --> 00:40:30,012
多播和广播经常使网络过载。

529
00:40:30,012 --> 00:40:34,089
对于每个兴趣点，我们想要做的是选择N个

530
00:40:34,089 --> 00:40:38,800
从这M个面孔中随机选择N个面孔，并进行多播调整。

531
00:40:40,010 --> 00:40:43,570
我们发现的典型的有效末端包括

532
00:40:43,570 --> 00:40:46,150
我们发现的典型的有效末端包括us are in the three to five range. This has shown itself to be a very useful strategy for~!@#$%^&*()

533
00:40:47,300 --> 00:40:51,236
这已经证明是一个非常有用的策略，用于

534
00:40:51,236 --> 00:40:55,718
这已经证明是一个非常有用的策略，用于数据流量，并且是目前实际应用中所使用的。

535
00:40:57,564 --> 00:41:02,105
好的，持续的兴趣是之前提出过的一个概念。

536
00:41:02,105 --> 00:41:05,804
菲利普·莫尔曾经谈论过这个话题，还有可能是其他人也研究过这个概念。

537
00:41:05,804 --> 00:41:09,885
或许其他人也研究过这个问题。

538
00:41:09,885 --> 00:41:14,467
这是我们正在研究的一个实验性事物，当然，

539
00:41:14,467 --> 00:41:20,161
可能有点争议，因为它确实打破了NDN流量平衡原则。

540
00:41:20,161 --> 00:41:25,248
但是，这又是一个我们一直在试验的机制，用来减少

541
00:41:25,248 --> 00:41:30,345
开销，用于检索大型数据项，如文件或地图。

542
00:41:30,345 --> 00:41:33,166
所以持久性兴趣是一个前缀，

543
00:41:33,166 --> 00:41:37,672
或许是一个没有序列号或块编号的文件名。

544
00:41:37,672 --> 00:41:39,781
It might be a file name without a serial number or block number. >> If that's of interest to you.

545
00:41:39,781 --> 00:41:41,940
如果这对你有兴趣的话。

546
00:41:41,940 --> 00:41:46,293
如果你想了解更多关于

547
00:41:46,293 --> 00:41:50,963
Python在这次会议上[无法听清]。

548
00:41:50,963 --> 00:41:55,594
好的，所以当NFD收到一个持久性兴趣时，

549
00:41:55,594 --> 00:42:00,325
如果它有任何数据以及与之匹配的内容存储，

550
00:42:00,325 --> 00:42:02,756
它会返回所有这些数据。

551
00:42:02,756 --> 00:42:06,208
利息将在其生命周期内一直留在坑中，并且

552
00:42:06,208 --> 00:42:09,860
将持续导致任何新数据的返回。

553
00:42:09,860 --> 00:42:13,530
如果持久的兴趣一直延伸到生产者那里，

554
00:42:13,530 --> 00:42:16,070
生产者会响应其所有匹配的数据。

555
00:42:17,230 --> 00:42:22,070
当持久兴趣在消费者处超时时，消费者可以发送

556
00:42:22,070 --> 00:42:27,190
一个带有最后一次看到的序列号指示器的新的

557
00:42:27,190 --> 00:42:32,830
发送针对丢失序列号的非持久性单独兴趣请求。

558
00:42:34,150 --> 00:42:39,370
好的，总之，DARPA SHARE 已经对NDN进行了测试和

559
00:42:39,370 --> 00:42:42,390
一些新的且非常具有挑战性的方式，但是

560
00:42:42,390 --> 00:42:47,029
我们觉得我们已经证明了NDN能够在这些条件下成功地执行任务。

561
00:42:48,180 --> 00:42:53,673
我们确实计划开始将我们的一些代码和修改反馈到NDN的代码库中，在过渡的来年还有更多的工作要做。

562
00:42:53,673 --> 00:42:59,352
代码库中，而且在过渡的来年还有更多的工作要做。

563
00:42:59,352 --> 00:43:03,663
所以如果我们还有时间提问的话，我就结束了。

564
00:43:05,561 --> 00:43:06,587
>> 谢谢约翰。

565
00:43:06,587 --> 00:43:09,350
我认为我们时间差不多了，但为了对所有发言者公平。

566
00:43:10,460 --> 00:43:11,544
我们来看看有没有人有问题。

567
00:43:11,544 --> 00:43:13,240
我看到很多关于大陆的聊天。

568
00:43:13,240 --> 00:43:15,373
有谁对约翰有问题吗？

569
00:43:21,810 --> 00:43:23,308
或者我会迅速抛出一个问题。

570
00:43:23,308 --> 00:43:26,298
是的，对于持续兴趣的概念无疑是有争议的。

571
00:43:26,298 --> 00:43:32,233
那么，这是如何与能力相结合的呢？

572
00:43:32,233 --> 00:43:36,946
实际上，在野外传输文件时效果非常好。

573
00:43:36,946 --> 00:43:41,989
实际上，我们使用它的目的就是如果有人有一张地图或者一张照片或者

574
00:43:41,989 --> 00:43:47,887
实际上，如果有人有一张地图或者一张照片或者某些要传输的东西，你可以发送一个持续的兴趣，而不是不发送。

575
00:43:47,887 --> 00:43:53,345
通常情况下，你不会得到100%的数据，但是典型的做法是

576
00:43:53,345 --> 00:43:58,889
尝试只对缺失的部分发送单独的兴趣请求。

577
00:43:58,889 --> 00:44:03,766
它确实大大减少了兴趣流量的数量。

578
00:44:03,766 --> 00:44:06,049
这真是太离谱了。

579
00:44:06,049 --> 00:44:07,358
>> 谢谢约翰。

580
00:44:07,358 --> 00:44:09,560
感谢所有的发言者，这是一个非常激动人心的环节。

581
00:44:09,560 --> 00:44:11,033
所以我将交给Look来处理。

582
00:44:11,033 --> 00:44:11,650
谢谢大家。

583
00:44:13,629 --> 00:44:17,480
好的，谢谢Tamer。

584
00:44:17,480 --> 00:44:21,237
下一环节是关于物联网和边缘计算的。

585
00:44:21,237 --> 00:44:26,582
Ken Calvert 是肯塔基大学的一位教授，

586
00:44:26,582 --> 00:44:29,322
他将主持这个会议。

587
00:44:29,322 --> 00:44:30,702
>> 好的，谢谢。

588
00:44:30,702 --> 00:44:34,659
是的，我叫Ken Calvert，

589
00:44:34,659 --> 00:44:38,500
本次会议的主题是物联网和边缘计算。

590
00:44:38,500 --> 00:44:44,668
但我们这里确实汇集了一系列多样化的主题。

591
00:44:44,668 --> 00:44:45,950
我认为这将会非常有趣。

592
00:44:45,950 --> 00:44:49,961
我们的第一位演讲嘉宾是Marie-Jose Montpetit，

593
00:44:49,961 --> 00:44:54,975
她是康考迪亚大学的兼职教授，并且

594
00:44:54,975 --> 00:45:01,110
她是智能控制器领域初创企业的顾问。

595
00:45:01,110 --> 00:45:05,195
她目前的研究集中在架构、设计和

596
00:45:05,195 --> 00:45:10,966
实施分布式智能系统在物联网中使用ICN原则和

597
00:45:10,966 --> 00:45:12,825
在网络中计算。

598
00:45:12,825 --> 00:45:16,110
她是两个IRTF工作组的联合主席。

599
00:45:16,110 --> 00:45:20,020
她是网络编码和网络计算或COIN工作组的联合主席。

600
00:45:20,020 --> 00:45:24,824
她是下一代互联网服务的FlexNGIA社区的成员，

601
00:45:24,824 --> 00:45:27,652
她将会讲述关于决策者的话题。

602
00:45:27,652 --> 00:45:30,825
那就由你来接手吧，Maria Jose。

603
00:45:30,825 --> 00:45:35,075
>> 嗨，我是Marie，我认为这更像是一个概念，而不是一个完全成形的项目，就像

604
00:45:35,075 --> 00:45:39,952
一个概念，而不是一个完全成型的项目，就像

605
00:45:39,952 --> 00:45:45,095
一些其他的演讲是在今天早些时候进行的。

606
00:45:45,095 --> 00:45:49,686
这实际上来自于三年前。

607
00:45:49,686 --> 00:45:54,705
现在我尝试看看我们是否能做NDN和

608
00:45:54,705 --> 00:45:58,590
ICN在真实应用程序中。

609
00:45:58,590 --> 00:46:01,721
所以是自下而上而不是自上而下地做这件事。

610
00:46:01,721 --> 00:46:06,450
所以从人们已有的应用程序开始，

611
00:46:06,450 --> 00:46:13,116
尝试着去看看我们能做什么，他们需要什么以及正在发生什么。

612
00:46:13,116 --> 00:46:17,761
我们非常幸运，而且我接下来要讲的是

613
00:46:17,761 --> 00:46:23,270
关于那个稍后再说，现在的一切都是数据驱动的。

614
00:46:23,270 --> 00:46:27,605
在物联网的世界里，这一点尤其正确，

615
00:46:27,605 --> 00:46:32,739
在那个分层架构中，曾经是数据的部分。

616
00:46:32,739 --> 00:46:37,548
在那个分层架构中，你负责获取数据的部分。

617
00:46:37,548 --> 00:46:43,450
而你基本上是因为这些东西过去通常是非常简单的，

618
00:46:43,450 --> 00:46:49,451
物联网，它由一些非常简单、功率非常小的传感器组成，

619
00:46:49,451 --> 00:46:54,452
唯一能让它们正常工作的方法是将它们连接起来。

620
00:46:54,452 --> 00:46:59,054
将它们连接到某种网关，这种网关相当简单，只负责发送数据。

621
00:46:59,054 --> 00:47:04,200
将一切都传送到云端，并且所有的事情都在那里完成。

622
00:47:04,200 --> 00:47:09,022
在过去几年中，我们所见证的是这个数据获取层

623
00:47:09,022 --> 00:47:12,820
现在催生了一系列非常非常不同的数据集。

624
00:47:12,820 --> 00:47:17,435
我开始从多媒体世界的角度考察这个问题，但它更多地涉及到工业领域。

625
00:47:17,435 --> 00:47:19,660
更多地涉及到工业领域。

626
00:47:19,660 --> 00:47:21,695
我们听说了有关汽车的事情。

627
00:47:21,695 --> 00:47:25,853
我有一个在福特的朋友，他负责那个联网汽车项目，还有联网汽车也会产生各种不同的数据集，

628
00:47:25,853 --> 00:47:30,559
联网汽车也会产生各种不同的数据集，以及

629
00:47:30,559 --> 00:47:33,470
问题在于数据集还是永恒的天才。

630
00:47:33,470 --> 00:47:38,345
那么比特率就从，好的，我将要测量

631
00:47:38,345 --> 00:47:43,639
温度我会每小时测量一次，我还会有一些数据位需要记录。

632
00:47:43,639 --> 00:47:49,749
我将会连续拍摄一系列照片，

633
00:47:49,749 --> 00:47:57,317
我将会产生几百兆字节的信息。

634
00:47:57,317 --> 00:47:59,100
那么我应该怎么办？

635
00:47:59,100 --> 00:48:04,251
在此之上，还有很多这类信息是时间敏感的。

636
00:48:04,251 --> 00:48:09,153
所以我可能没有时间折回去我的

637
00:48:09,153 --> 00:48:15,390
决策者需要在网络或云端进行这些操作。

638
00:48:15,390 --> 00:48:20,370
但与此同时，我需要我的云基础设施来训练我的算法，如果

639
00:48:20,370 --> 00:48:23,070
我将要研究智能系统。

640
00:48:23,070 --> 00:48:29,560
我需要了解，然后我们开始研究与NDN的联系。

641
00:48:29,560 --> 00:48:34,400
我需要知道我想要查看哪些数据。

642
00:48:34,400 --> 00:48:38,335
在这里我说的不是一个人，

643
00:48:38,335 --> 00:48:42,355
我在这里所说的是一个控制者，我所说的是一个过程。

644
00:48:42,355 --> 00:48:46,735
我在这里所说的是系统中某个地方的一个智能机器人，它需要那些信息，不需要所有的信息，只需要其中的一部分。

645
00:48:46,735 --> 00:48:51,205
它需要那些信息，不需要所有的信息，只需要其中的一部分。

646
00:48:51,205 --> 00:48:58,700
这些传感器本质上是在为这些问题提供答案。

647
00:48:58,700 --> 00:49:04,016
显然我们在谈论的是有时非常小的系统，

648
00:49:04,016 --> 00:49:09,738
所以你可能不想在所有地方复制所有的功能。

649
00:49:09,738 --> 00:49:15,024
你可能会想从隔壁借用一些功能。

650
00:49:15,024 --> 00:49:20,330
门系统如果可以的话，或者甚至，我把5G宽带放在那里。

651
00:49:20,330 --> 00:49:23,920
因为我们实际上已经讨论了很多

652
00:49:23,920 --> 00:49:28,070
加拿大的5G服务提供商讨论了这样一个项目。

653
00:49:28,070 --> 00:49:32,390
加拿大的5G服务提供商讨论了这样一个项目：我们如何能将所有这些智能系统连接起来。

654
00:49:32,390 --> 00:49:34,350
这些智能系统一起。

655
00:49:34,350 --> 00:49:38,920
所以我想稍微讲解一下其中的一些基本构件。

656
00:49:38,920 --> 00:49:41,860
我知道我没有那么多时间，而且

657
00:49:41,860 --> 00:49:43,820
我大概可以谈这个话题三个小时。

658
00:49:43,820 --> 00:49:45,930
所以在某个时刻，Ken，我希望你打断我。

659
00:49:48,380 --> 00:49:53,330
我正在看露西亚的评论，

660
00:49:53,330 --> 00:49:56,250
我不应该那样做，我应该继续进行我的演讲。

661
00:49:56,250 --> 00:49:59,099
那么这里的挑战，我想我提到过，

662
00:49:59,099 --> 00:50:04,590
这是多源多目的地数据捕获和决策制定。

663
00:50:04,590 --> 00:50:09,870
我有一堆传感器，我有一堆摄像头，我有一堆麦克风。

664
00:50:09,870 --> 00:50:12,570
它们都在倾听，它们都在做一些事情。

665
00:50:12,570 --> 00:50:16,950
他们可能想去不同的目的地。

666
00:50:16,950 --> 00:50:21,970
现在做决定还是稍后做决定。

667
00:50:21,970 --> 00:50:26,530
这就是一些NDN概念发挥作用的地方。

668
00:50:26,530 --> 00:50:32,294
这显然都是异构的，包括异构环境和

669
00:50:32,294 --> 00:50:36,935
异构传感器，显然还包括异构数据集。

670
00:50:36,935 --> 00:50:41,004
所以我看到的是某种正在建设中的东西，以及

671
00:50:41,004 --> 00:50:45,173
你将会看到，某种正在建设中的基础部分。

672
00:50:45,173 --> 00:50:49,687
所以很明显，这里有NDN和ICN，

673
00:50:49,687 --> 00:50:54,467
所以因为它非常依赖数据，需要去

674
00:50:54,467 --> 00:50:59,002
处理正确类型的信息。

675
00:50:59,002 --> 00:51:03,603
我还会谈论首先要计算好网络是如何运作的。

676
00:51:03,603 --> 00:51:08,435
从一种计算和网络的方式来看。

677
00:51:08,435 --> 00:51:12,741
这整个架构利用了优势，

678
00:51:17,225 --> 00:51:21,725
我明白了，我稍后会回来查看答案。

679
00:51:21,725 --> 00:51:25,300
我应该停止看那个东西。

680
00:51:25,300 --> 00:51:30,400
Anyway, so there's also this heritage of COIN, because COIN has 处理了很多本地计算的问题，

681
00:51:30,400 --> 00:51:35,740
处理了很多本地计算的问题，

682
00:51:35,740 --> 00:51:39,020
尤其是在边缘计算领域，同时也包括数据中心和云计算。

683
00:51:39,020 --> 00:51:44,260
所以在某种程度上，尽管这个环节被称为边缘计算，我想说的是什么

684
00:51:44,260 --> 00:51:50,040
我在介绍的是一个云支持的边缘。

685
00:51:50,040 --> 00:51:52,960
所以它们并不真正协同工作，我很抱歉，

686
00:51:52,960 --> 00:51:56,454
这里街上有一辆卡车，它是下一代物联网技术。

687
00:51:56,454 --> 00:52:02,499
我提到它是边缘计算和云计算的结合，这显然是数据相关的。

688
00:52:02,499 --> 00:52:07,550
驱动系统，这在物联网中越来越普遍。

689
00:52:07,550 --> 00:52:11,686
语义网，因为我们需要为这些东西命名并且

690
00:52:11,686 --> 00:52:18,087
确保它们可以被发现，同时它也是分布式网络。

691
00:52:18,087 --> 00:52:22,345
所以我称它为决策制定的基石。

692
00:52:22,345 --> 00:52:23,671
所以它们是什么？

693
00:52:23,671 --> 00:52:28,144
嗯，我们已经开始了，我希望Eve还在通话中，

694
00:52:28,144 --> 00:52:32,636
我们开始研究某种公共数据层。

695
00:52:32,636 --> 00:52:36,956
这是与芬兰爱立信研究院的同事们一起进行的工作。

696
00:52:36,956 --> 00:52:41,100
这是在普林斯顿大学做博士后的某人。

697
00:52:41,100 --> 00:52:45,023
我们开始认为，在所有这些系统中，

698
00:52:45,023 --> 00:52:50,691
我们在讨论有许多功能是共通的。

699
00:52:50,691 --> 00:52:55,512
它们不是一个网络层，它们是一个数据层。

700
00:52:55,512 --> 00:53:00,485
我们想要用这个数据层做的是发现和链接。

701
00:53:00,485 --> 00:53:04,535
我想知道哪些信息是重要的。

702
00:53:04,535 --> 00:53:08,061
增加了显而易见的安全级别。

703
00:53:08,061 --> 00:53:12,544
我们想要做一些过滤工作，这实际上源自一些工作，在

704
00:53:12,544 --> 00:53:17,414
我们想要做一些过滤工作，这实际上源自一些工作，在一个网络计算环境中，那里有越来越多的可编程交换机。That can go to very high speed but can also be very useful in filtering the type.

705
00:53:17,414 --> 00:53:22,947
这可以达到非常高的速度，但在过滤我们想要的信息类型方面也可以非常有用。

706
00:53:22,947 --> 00:53:28,690
它可以筛选我们想要的信息，并将其发送到我们需要进行处理的其他流程中。

707
00:53:28,690 --> 00:53:31,410
它实际上涉及大量的处理和协调工作，

708
00:53:31,410 --> 00:53:35,850
尤其是当我在那里放置了两个元素，而实际上可能远不止这些。

709
00:53:35,850 --> 00:53:39,990
因此我们想要进行这个处理和这个协调工作，

710
00:53:39,990 --> 00:53:44,400
同时进行发现和链接工作，

711
00:53:44,400 --> 00:53:48,930
能够创造更好的功能。

712
00:53:48,930 --> 00:53:54,985
但我是基于你能够创造更好的功能来说的，

713
00:53:54,985 --> 00:53:58,782
在逗号中，借用其他地方。

714
00:53:58,782 --> 00:54:02,699
显然我在那里放置了数据采集，但其实它可以是任何东西，

715
00:54:02,699 --> 00:54:05,389
它们实际上可以是一般的数据生产者。

716
00:54:05,389 --> 00:54:09,874
我们希望能够实现本地决策。

717
00:54:09,874 --> 00:54:14,690
这实际上说明了为什么我们想要进行本地处理的原因。

718
00:54:14,690 --> 00:54:19,070
我们希望在数据采集处进行本地处理。

719
00:54:19,070 --> 00:54:23,940
我们希望在边缘处做出本地决策，这可能意味着在边缘位置。

720
00:54:23,940 --> 00:54:29,220
的工业设施边缘。

721
00:54:29,220 --> 00:54:35,760
它可能位于城市的边缘，也可能位于汽车的边缘。

722
00:54:35,760 --> 00:54:40,602
但这意味着到处都有分布式智能，

723
00:54:40,602 --> 00:54:43,564
所以这实际上是我们的共享数据层。

724
00:54:43,564 --> 00:54:47,454
我们也希望同时拥有一个嵌入式的决策层。

725
00:54:47,454 --> 00:54:50,786
这就是那个智能层，再次，

726
00:54:50,786 --> 00:54:55,298
正在被许多人推动做出本地决策。

727
00:54:55,298 --> 00:55:01,101
而实际上对我或其他人来说，并不是本地的，

728
00:55:01,101 --> 00:55:04,542
它其实是云支持的。

729
00:55:04,542 --> 00:55:11,740
没有人会在树莓派上训练神经网络。

730
00:55:11,740 --> 00:55:15,370
但是树莓派实际上能做很多事情，这些事情是通过在云端训练你的数据集得来的。

731
00:55:15,370 --> 00:55:20,700
是通过在云端训练你的数据集得来的。

732
00:55:20,700 --> 00:55:24,100
这显然涉及大量的人工智能和机器学习。

733
00:55:24,100 --> 00:55:29,522
这又回到了前一张幻灯片的内容，也与一些

734
00:55:29,522 --> 00:55:36,250
这又回到了前一张幻灯片的内容，也与一些目前在NDN和COIN中的概念相关，即资源和数据发现。

735
00:55:36,250 --> 00:55:38,797
我们需要知道智能所在的位置。

736
00:55:38,797 --> 00:55:42,349
我们需要知道哪些算法需要开启和关闭。

737
00:55:42,349 --> 00:55:48,760
再次提到，还有这个兴趣消息的ID和

738
00:55:48,760 --> 00:55:57,176
对兴趣消息的响应实际上标记了数据包。

739
00:55:57,176 --> 00:56:02,009
在我们看来，我们希望将数据包与之关联

740
00:56:02,009 --> 00:56:05,500
在我们看来，我们希望将数据包与之关联，在这些可编程交换机和数据平面上实现的程度甚至，>> That could be implemented

741
00:56:05,500 --> 00:56:08,010
在这些可编程交换机和数据平面上。

742
00:56:08,010 --> 00:56:12,934
所以我知道Dave在线上，我认为有很多

743
00:56:12,934 --> 00:56:18,147
讨论在这里关于存在于...之间的差异意味着什么

744
00:56:18,147 --> 00:56:23,100
在网络内部和网络上，我认为这两者都包括了。

745
00:56:23,100 --> 00:56:29,323
所以这是一个当前正在实施中的某种东西的ID，或者

746
00:56:29,323 --> 00:56:33,990
实际上是它的一个版本，以及智能

747
00:56:33,990 --> 00:56:38,750
网关实现了通用数据层。

748
00:56:38,750 --> 00:56:44,440
以及智能层进行本地决策

749
00:56:44,440 --> 00:56:47,750
然后感知对网络来说必要的信息。

750
00:56:47,750 --> 00:56:55,750
这个东西的本质功能是尽可能地实现，

751
00:56:55,750 --> 00:57:01,100
所需的决策

752
00:57:01,100 --> 00:57:09,830
通过数据采集系统进行决策以过滤信息，

753
00:57:09,830 --> 00:57:14,750
为了从一些较低层面上获得实际利益，

754
00:57:14,750 --> 00:57:20,590
层发布/订阅协议，如MQTT和COAP。

755
00:57:20,590 --> 00:57:24,750
实际上，我们将开始在那里部署智能技术。

756
00:57:24,750 --> 00:57:26,900
有很多理由这么做，

757
00:57:26,900 --> 00:57:31,260
我们想要开始拥有非常自主的系统，

758
00:57:31,260 --> 00:57:35,650
我们不能总是认为它们会一直保持连接状态，

759
00:57:35,650 --> 00:57:41,600
尤其是如果我们想要进入一个偏远地区。

760
00:57:41,600 --> 00:57:43,190
而在我们无法做到的地方，

761
00:57:43,190 --> 00:57:46,500
尽管那些支持5G的人会说到处都会有5G网络。

762
00:57:46,500 --> 00:57:51,390
嗯，我知道北魁北克不幸地进入了冬天。

763
00:57:51,390 --> 00:57:52,480
我不会对此抱有太大希望。

764
00:57:53,542 --> 00:58:01,020
因此必须如此，我认为从这个非常简单的视角你可以看出

765
00:58:01,020 --> 00:58:05,820
这里有不同类型的数据生产者，他们拥有非常简单的控制器。

766
00:58:05,820 --> 00:58:07,550
他们做错了，只有开和关。

767
00:58:07,550 --> 00:58:09,900
他们只能读一些东西。

768
00:58:09,900 --> 00:58:14,260
有很多模拟系统仍然存在，以及物联网或者……

769
00:58:14,260 --> 00:58:19,250
物联网相关小组 >> 总共不到三分钟。

770
00:58:19,250 --> 00:58:22,340
好的，我实际上会讲得非常快，

771
00:58:22,340 --> 00:58:23,720
那么你就有了所有这些不同的东西。

772
00:58:23,720 --> 00:58:24,950
那么让我开始吧。

773
00:58:24,950 --> 00:58:27,880
所以关于使用案例，我会非常快速地介绍。

774
00:58:27,880 --> 00:58:28,680
我只有几个。

775
00:58:29,690 --> 00:58:32,150
设计和制造，这些是目标。

776
00:58:32,150 --> 00:58:35,110
物联网数字孪生，数据驱动方法。

777
00:58:35,110 --> 00:58:38,140
再次提到，你有触觉，有dotnet。

778
00:58:38,140 --> 00:58:41,850
这就是FlexNGIA及其构建模块发挥作用的时候。

779
00:58:41,850 --> 00:58:45,596
所以我想说的是，你想要创建这些大型的构建模块。

780
00:58:45,596 --> 00:58:49,760
你可能想要使用边缘或信息中心网络来进行分发，

781
00:58:49,760 --> 00:58:50,799
服务质量。

782
00:58:50,799 --> 00:58:55,020
你想要ARVR功能，因为你想要拥有那些图像和

783
00:58:55,020 --> 00:58:58,430
你想要能够叠加图像，即使是为了

784
00:58:58,430 --> 00:59:02,640
一些其他的系统，我没有真正提到那里有一点

785
00:59:04,060 --> 00:59:08,340
安全性问题贯穿于整个架构，而这实际上就是区块链。

786
00:59:08,340 --> 00:59:12,970
目前，将区块链与人工智能相结合的想法非常酷。

787
00:59:12,970 --> 00:59:18,090
这已经让我忙碌了18个月了。

788
00:59:18,090 --> 00:59:23,390
这些想法是关于相互连接的垂直农业环境。

789
00:59:23,390 --> 00:59:26,230
本质上你想要的是自动化的抗气候影响的生产。

790
00:59:26,230 --> 00:59:27,676
你希望它们具备智能。

791
00:59:27,676 --> 00:59:32,810
你希望能够使它们具有自主性并发现它们的数据。

792
00:59:32,810 --> 00:59:34,410
他们的资源。

793
00:59:34,410 --> 00:59:39,210
边缘传感器的大量数据是否能够支持云端做出决策。

794
00:59:39,210 --> 00:59:45,380
我知道B之后的人们在提出一些关于我们进行编码的想法。

795
00:59:45,380 --> 00:59:48,370
嗯，这里实际上有一些关于网络编码的想法用来保护

796
00:59:48,370 --> 00:59:49,250
保护信息。

797
00:59:49,250 --> 00:59:53,300
您想再次拥有区块链以及本地智能。

798
00:59:53,300 --> 00:59:57,340
在其他事情中，还包括检测疾病，但我本应该补充那一点的。

799
00:59:57,340 --> 01:00:00,160
所以，找出你想要做的事情并收获成果。

800
01:00:00,160 --> 01:00:03,660
多媒体，这正是让我开始投入并全身心投入的东西。

801
01:00:03,660 --> 01:00:08,040
再一次，相同的构建模块，却有着非常不同的应用。

802
01:00:09,500 --> 01:00:14,030
在那种情况下，区块链上的小型合约也会

803
01:00:14,030 --> 01:00:18,920
在你分发信息时实现货币化，

804
01:00:18,920 --> 01:00:23,590
我们听说了关于自动驾驶车辆，自动驾驶车辆的保险。

805
01:00:23,590 --> 01:00:24,970
这些是平台的汽车。

806
01:00:24,970 --> 01:00:28,200
这些是平台的汽车，再次来自于我的朋友，他在福特工作。

807
01:00:28,200 --> 01:00:30,110
他不是昨天介绍的那个人。

808
01:00:30,110 --> 01:00:32,450
积木又来了，还是同样的东西。

809
01:00:32,450 --> 01:00:35,522
所以你看，我认为我们想要的是什么。

810
01:00:40,584 --> 01:00:43,435
我还在看问题。

811
01:00:43,435 --> 01:00:48,760
我不应该这么做，我需要结束了，请。

812
01:00:48,760 --> 01:00:50,483
好的，那我结束了。

813
01:00:50,483 --> 01:00:51,905
好的。>> 结束。

814
01:00:51,905 --> 01:00:53,984
>> [笑声] >> 就这样，我们完成了。

815
01:00:53,984 --> 01:00:58,010
>> 好的，我认为我们将继续进行下一件事。

816
01:00:58,010 --> 01:01:01,270
>> 不，等等，等一下，等一下，等一下，给我30秒。

817
01:01:01,270 --> 01:01:02,860
>> 好的。>> 这实际上是所有人

818
01:01:02,860 --> 01:01:06,550
谁控制了贡献，我真的非常希望人们能关注这个。

819
01:01:08,040 --> 01:01:09,890
>> 好的，太棒了，非常感谢。

820
01:01:09,890 --> 01:01:14,810
我们将把问题留到聊天环节，我建议下一位发言者不要看聊天内容，因为那里可能正在进行讨论。

821
01:01:14,810 --> 01:01:18,070
我们将在聊天环节讨论，因为那里可能正在进行讨论。

822
01:01:19,880 --> 01:01:22,960
这是关于之前的讲话，也就是这次发生的事情。

823
01:01:22,960 --> 01:01:27,680
但我们的下一位演讲者是Hirah Malik。

824
01:01:27,680 --> 01:01:30,260
她是法国国家信息与自动化研究所(Inria)的一名研究员。

825
01:01:30,260 --> 01:01:35,560
她正在法国巴黎-萨克雷大学攻读博士学位，并且

826
01:01:35,560 --> 01:01:40,590
她在巴黎高科电信学院获得了多媒体网络硕士学位。

827
01:01:40,590 --> 01:01:45,820
她的研究兴趣包括多媒体传输和数据集同步。

828
01:01:45,820 --> 01:01:50,840
她现在在印第安纳州研究网络编码，并且她的研究涉及到ICN和NDN。

829
01:01:50,840 --> 01:01:57,000
她的演讲是关于MICN的，这是对网络编码的一种新视角。

830
01:01:57,000 --> 01:01:58,100
那么请开始吧。

831
01:01:58,100 --> 01:01:59,060
谢谢。

832
01:01:59,060 --> 01:02:00,950
>> 谢谢你的友好介绍。

833
01:02:00,950 --> 01:02:01,980
大家好。

834
01:02:01,980 --> 01:02:03,670
我是Hirah Malik。

835
01:02:03,670 --> 01:02:05,500
首先，我想感谢组织者给予我

836
01:02:05,500 --> 01:02:08,970
这次机会在NDN com上发表演讲。

837
01:02:08,970 --> 01:02:11,200
今天我将在NDN com上发表演讲，介绍一种ICN，

838
01:02:11,200 --> 01:02:16,840
它是一种将网络编码与命名数据网络结合的协议。

839
01:02:16,840 --> 01:02:19,050
我们将从一些背景知识开始讲起。

840
01:02:19,050 --> 01:02:24,960
解释一下将这两者结合起来的动机。

841
01:02:24,960 --> 01:02:29,920
所以在一个客户端想要检索大量内容的场景中

842
01:02:29,920 --> 01:02:35,460
在不了解网络、不知道网络拓扑的情况下。

843
01:02:35,460 --> 01:02:38,795
利用多条路径是一个自然的解决方案。

844
01:02:38,795 --> 01:02:43,440
NDN允许我们这样做，但是

845
01:02:43,440 --> 01:02:46,780
在这个例子中展示的典型印度情境中。

846
01:02:46,780 --> 01:02:53,558
如果一个客户需要恢复内容，比如有两个部分，P1和P2。

847
01:02:53,558 --> 01:02:55,850
它将自然开始请求内容P1。

848
01:02:55,850 --> 01:02:59,520
如果它在我们这里看到的两条可用路径上发送兴趣，

849
01:03:01,010 --> 01:03:05,580
它最终会从这两个链接中获取两次相同的内容。

850
01:03:05,580 --> 01:03:07,990
这只是重复的内容。

851
01:03:07,990 --> 01:03:11,476
解决这个问题的一个方法是网络编码。

852
01:03:11,476 --> 01:03:17,630
我将首先简要介绍一下网络编码。

853
01:03:17,630 --> 01:03:22,250
所以网络编码允许在网络中组合数据包。

854
01:03:22,250 --> 01:03:24,760
它们可以通过几种方式组合起来。

855
01:03:24,760 --> 01:03:26,430
它们可以被吸收。

856
01:03:26,430 --> 01:03:31,628
它们可以被添加，或者节点可以对源数据包进行线性组合。

857
01:03:31,628 --> 01:03:36,200
编码和记录可以在网络的任何地方完成，

858
01:03:36,200 --> 01:03:37,540
解码很简单。

859
01:03:37,540 --> 01:03:42,372
解码很简单。一旦客户端收到足够的编码数据包，它就可以执行逆向

860
01:03:42,372 --> 01:03:46,858
已经收到足够的编码数据包，它就可以执行逆向操作

861
01:03:46,858 --> 01:03:50,060
操作以恢复源数据包。

862
01:03:50,060 --> 01:03:54,960
因此，为了说明NDN如何从网络编码中受益，

863
01:03:54,960 --> 01:03:58,680
我们可以看到，在同样的情景下。

864
01:03:58,680 --> 01:04:04,170
我们可以看到，在同样的情景下，如果客户端请求相同内容的编码数据包，two sort of segments And sends over these two over the multiple variable paths.

865
01:04:04,170 --> 01:04:09,600
两种类型的数据段，并通过多个可变路径发送这两个数据段。

866
01:04:09,600 --> 01:04:14,840
源一发送了一个编码数据包，它是两个数据包p1和p2的混合。

867
01:04:14,840 --> 01:04:19,070
源二发送了一个不同的源数据包混合。

868
01:04:19,070 --> 01:04:23,730
客户端可以通过解码这些线性独立的编码数据包来检索源数据包。

869
01:04:23,730 --> 01:04:28,198
解码这些线性独立的编码数据包。

870
01:04:28,198 --> 01:04:33,520
网络编码的概念已经存在一段时间了，它

871
01:04:36,450 --> 01:04:41,850
给了我们动力去开发一种我们称之为MICN的协议。

872
01:04:41,850 --> 01:04:45,620
它通过避免冗余内容来确保高吞吐量。

873
01:04:45,620 --> 01:04:51,730
所以我们从在NDN上实现网络编码的经典方式开始，

874
01:04:51,730 --> 01:04:52,950
其他人也是这样做的。

875
01:04:52,950 --> 01:04:54,740
所以我们有相同的信息基础。

876
01:04:54,740 --> 01:04:59,320
我们有内容存储、PIT和FIB，以及相同的消息。

877
01:04:59,320 --> 01:05:04,190
但现在的一切都说明了我们正在请求、处理和

878
01:05:04,190 --> 01:05:06,560
转发编码内容。

879
01:05:06,560 --> 01:05:12,550
为了使其工作，必须在NDN中进行重大的语义更改。

880
01:05:12,550 --> 01:05:17,650
为了在这里测试一切，我们在Python模拟器中实现了它。

881
01:05:20,120 --> 01:05:23,550
为了解释NDN语义，正如我已经说过的，

882
01:05:23,550 --> 01:05:28,450
我们的核心目标是通过多条路径实现高吞吐量，

883
01:05:28,450 --> 01:05:30,920
我们百分之百地专注于这个目标。

884
01:05:30,920 --> 01:05:34,560
在这个假设下，节点之间没有协调。

885
01:05:36,090 --> 01:05:40,743
因此，聚焦于我们的目标，首先要做的是提升或者

886
01:05:40,743 --> 01:05:45,700
增加网络中的兴趣传播。

887
01:05:45,700 --> 01:05:49,220
而做出这个选择的第一步很简单，

888
01:05:49,220 --> 01:05:51,750
你选择了一个允许你这样做的转发策略。

889
01:05:51,750 --> 01:05:54,380
所以我们选择了一种多播转发策略，

890
01:05:54,380 --> 01:05:56,157
它通过所有可用的路径发送兴趣。

891
01:05:57,440 --> 01:06:04,170
我们做出的另一个设计选择是为了补充多播，

892
01:06:04,170 --> 01:06:08,560
我们做出的另一个设计选择是修改了兴趣处理方式，以改善兴趣传播，

893
01:06:08,560 --> 01:06:13,640
这也并不是很难，但对我们的问题来说是重要且至关重要的。

894
01:06:13,640 --> 01:06:19,070
并且第三个也是最重要的是，我们实现了多个处理过程。

895
01:06:19,070 --> 01:06:25,810
在NDN中的并行兴趣点，我稍后会详细解释。

896
01:06:27,180 --> 01:06:31,930
所以，第一个是NIC，兴趣处理，

897
01:06:31,930 --> 01:06:34,090
修改后的兴趣处理。

898
01:06:34,090 --> 01:06:39,430
因此，在传统的NDN中，它限制了兴趣的扩散。

899
01:06:39,430 --> 01:06:43,710
因此，正如我们在这个例子中看到的，如果客户端一发送兴趣，

900
01:06:43,710 --> 01:06:46,840
因为我们使用的是多播策略，所以它会在所有可用的~!@#$%^&*()

901
01:06:46,840 --> 01:06:52,040
它会在源头一和源头二的所有可用路径上创建这个多播树。

902
01:06:52,040 --> 01:06:56,926
当客户端二稍后进入并发送其对内容的兴趣时，

903
01:06:56,926 --> 01:07:00,912
它们会因为客户端一的兴趣而被抑制。

904
01:07:00,912 --> 01:07:05,132
它们只能到达靠近客户端一的这台路由器，但是

905
01:07:05,132 --> 01:07:09,350
它们将无法到达源头一和源头二，客户端二也不能

906
01:07:09,350 --> 01:07:14,970
有效地使用它通往源头的所有可用路径。

907
01:07:14,970 --> 01:07:20,560
因此，解决这个问题的方法是不压制相似的兴趣。

908
01:07:20,560 --> 01:07:26,750
我们就是这么做的，MICN不会压制相似的兴趣。

909
01:07:28,130 --> 01:07:32,150
所以这实际上增加了网络中的兴趣数量，但是

910
01:07:32,150 --> 01:07:38,360
因此这实际上增加了传播，让兴趣触及源头。

911
01:07:39,370 --> 01:07:44,770
另一个重要的点是，我之前说过的，就是拥有多个并行的

912
01:07:44,770 --> 01:07:48,310
兴趣流，以实现我们所说的多个并行兴趣，即管道化。

913
01:07:50,150 --> 01:07:54,555
根据它的名字，这似乎微不足道，因为NDN允许发送

914
01:07:54,555 --> 01:07:58,501
但这允许在网络中发送多个并行的兴趣。

915
01:08:02,535 --> 01:08:07,395
~!@#$%^&*()

916
01:08:07,395 --> 01:08:12,137
一个编码段或一组源段和

917
01:08:12,137 --> 01:08:16,664
它从一个源接收到这个编码段。

918
01:08:16,664 --> 01:08:20,767
当它再次发送对同一编码段集的兴趣请求时，

919
01:08:20,767 --> 01:08:25,593
相同的编码内容可以作为对这一兴趣请求以及所有后续兴趣请求的响应。

920
01:08:25,593 --> 01:08:31,090
因为它请求的是同一组源数据包的编码片段。

921
01:08:32,580 --> 01:08:36,095
这是一个特殊案例，但实际上它可能发生在网络的任何地方。

922
01:08:36,095 --> 01:08:40,857
在这里，我们可以看到右边的图示，同样的内容可以流回来，

923
01:08:40,857 --> 01:08:44,667
来自不同的来源，网络中的不同路由器，

924
01:08:44,667 --> 01:08:48,790
鉴于他们从一个类似的来源接收到了这个内容。

925
01:08:50,670 --> 01:08:52,340
这是一个主要问题。

926
01:08:52,340 --> 01:08:58,640
这是我们需要解决的一个重要问题，因为要让客户解码，

927
01:08:58,640 --> 01:09:04,240
这是我们需要解决的一个重要问题，因为要让客户解码，内容必须包含足够的线性独立信息。为了解决这个问题，我们提出了一个我们称之为MILIC的解决方案，这是为了

928
01:09:05,660 --> 01:09:14,660
为了解决这个问题，我们提出了一个我们称之为MILIC的解决方案，这是为了

929
01:09:14,660 --> 01:09:19,810
为了结束源段落，我们发送了n个索引兴趣，

930
01:09:19,810 --> 01:09:25,590
因此，这些兴趣能够从预定义的子集中带回内容。

931
01:09:25,590 --> 01:09:30,040
因此，兴趣 I1 将带回内容

932
01:09:30,040 --> 01:09:35,005
从子集 A1 中，I1 将带回内容，同样地，I2 从 A2 中带回内容，

933
01:09:35,005 --> 01:09:39,660
I3 从 A3 中带回内容，以确保它们始终是线性独立的。

934
01:09:39,660 --> 01:09:42,340
因此，定义这样的子集

935
01:09:42,340 --> 01:09:46,600
它们总是线性独立的是一个数学问题。

936
01:09:46,600 --> 01:09:49,510
我们解决了这个数学问题，

937
01:09:49,510 --> 01:09:53,940
我们解决这个问题的方法是这样定义我们的子集。

938
01:09:53,940 --> 01:09:55,930
我将用这个例子来解释它。

939
01:09:55,930 --> 01:10:00,090
该兴趣I1只能得到响应以用于

940
01:10:00,090 --> 01:10:05,165
该兴趣I1只能得到响应以用于包含三个源数据包的内容，

941
01:10:05,165 --> 01:10:11,256
可以响应一个编码段，该编码段应该包含第一个段落和

942
01:10:11,256 --> 01:10:15,256
可以包含第二和第三个编码段。

943
01:10:15,256 --> 01:10:20,120
同样对于I2，它不应该包含第一个编码段。

944
01:10:20,120 --> 01:10:24,220
它肯定应该包含第二个编码段，并且可能包含第三个编码段。

945
01:10:24,220 --> 01:10:27,910
通过观察这个三段示例，我们可以看到如果，

946
01:10:27,910 --> 01:10:33,170
如果一个节点接收到I1、I2和I3的响应，它们都是线性独立的。

947
01:10:35,430 --> 01:10:40,090
因此，这是MILIC构造的一个重要特性。

948
01:10:40,090 --> 01:10:43,290
这是因为还有两个其他的特性，

949
01:10:43,290 --> 01:10:47,300
正如我已经说过的，我们使用多条路径，并且我们是在信任中发送。

950
01:10:47,300 --> 01:10:53,010
通过多条路径，我们希望能收到对一个索引的多个回复。

951
01:10:53,010 --> 01:10:57,650
在我们收到多个回复的情况下，这两个其他属性确保了

952
01:10:57,650 --> 01:11:03,570
收到这些兴趣响应的内容仍然是有用的。

953
01:11:03,570 --> 01:11:09,110
如果一个节点对一个兴趣收到不止一个回复，

954
01:11:09,110 --> 01:11:13,890
它可以利用它为其他子集创建内容，因此如果其他

955
01:11:13,890 --> 01:11:19,380
它可以根据后来产生的兴趣做出响应。

956
01:11:19,380 --> 01:11:23,410
为了使协议更好地工作，我们不得不做了一些

957
01:11:23,410 --> 01:11:28,490
为了增强协议的功能，我将简要介绍一下。

958
01:11:28,490 --> 01:11:31,500
其中之一便是即时重新编码。

959
01:11:31,500 --> 01:11:36,820
这实际上是一种队列管理技术。

960
01:11:36,820 --> 01:11:41,900
为了在网络中拥有更多样化的内容来管理队列。

961
01:11:41,900 --> 01:11:45,180
第二个是取消兴趣，正如我所说的那样

962
01:11:45,180 --> 01:11:49,500
在我的设计选择中，我们有效地在网络中引起了很多兴趣。

963
01:11:49,500 --> 01:11:53,290
为了应对这个问题，我们引入了这个机制。

964
01:11:53,290 --> 01:11:57,721
为了解决这个问题，我们引入了兴趣消除机制，用于取消不必要的兴趣，在客户端接收到内容后，可以减少网络中的兴趣。

965
01:11:57,721 --> 01:12:02,650
在客户端接收到内容之后，可以减少网络中的兴趣。

966
01:12:02,650 --> 01:12:06,470
内容重定向，它允许

967
01:12:06,470 --> 01:12:10,090
不太常用的路径在可能的情况下才使用。

968
01:12:11,550 --> 01:12:15,270
这只是协议的介绍。

969
01:12:15,270 --> 01:12:23,330
现在我将通过一些模拟结果来展示协议的性能。

970
01:12:23,330 --> 01:12:28,760
所以在这里，我们有一个网络，其中有一个源头和

971
01:12:28,760 --> 01:12:35,350
五个客户端以灰色显示，它们正在请求相同的内容。

972
01:12:35,350 --> 01:12:39,150
内容包含一百个源段落。

973
01:12:39,150 --> 01:12:42,470
在右边我们可以看到这个。

974
01:12:42,470 --> 01:12:48,070
这张图表在y轴上展示了线性独立数据包的数量。

975
01:12:48,070 --> 01:12:53,277
该图表的x轴代表了用户在任何时间点接收的数据。

976
01:12:53,277 --> 01:12:57,826
我们可以看到所有的曲线都是线性的。

977
01:12:57,826 --> 01:13:02,206
但是当我们仔细观察时，我们实际上可以看到所有用户

978
01:13:02,206 --> 01:13:07,065
都在以其最大可能的吞吐量接收内容。

979
01:13:07,065 --> 01:13:12,125
它基本上是MICN主要设计目标，

980
01:13:12,125 --> 01:13:16,798
首先，另一个我已经解释过的重要方面是具有高吞吐量，

981
01:13:16,798 --> 01:13:20,886
已经解释过的是，具有高吞吐量，

982
01:13:20,886 --> 01:13:25,752
我们冒着用大量的兴趣来过载网络的风险，

983
01:13:25,752 --> 01:13:31,009
内容，并为此我们引入了兴趣取消机制，

984
01:13:31,009 --> 01:13:35,386
我们可以看到，我们已经基本上解决了这个问题。

985
01:13:35,386 --> 01:13:40,401
这个协议中的额外增强功能存在问题。

986
01:13:40,401 --> 01:13:46,017
总而言之，MICN是一个网络编码协议，它考虑到了记录和

987
01:13:46,017 --> 01:13:50,005
总的来说，NDN基本上依赖于milic结构，

988
01:13:50,005 --> 01:13:55,530
这确保了网络中没有冗余内容流动。

989
01:13:55,530 --> 01:13:59,175
响应我们所发出的兴趣。

990
01:13:59,175 --> 01:14:06,630
我提出了我们必须进行的关键改进，以使其运行得更好。

991
01:14:06,630 --> 01:14:12,542
未来我们希望能改进利益转发策略。

992
01:14:12,542 --> 01:14:17,319
所以我们或许不会再有太多的问题。

993
01:14:17,319 --> 01:14:21,499
毕竟网络上有很多人感兴趣，

994
01:14:21,499 --> 01:14:25,570
虽然如此，仍能保持高吞吐量。

995
01:14:28,520 --> 01:14:29,400
谢谢。就是这样。

996
01:14:30,710 --> 01:14:32,293
好的，谢谢，伟大的英雄。

997
01:14:32,293 --> 01:14:36,001
我们有问题吗？

998
01:14:36,001 --> 01:14:36,980
我有个问题。

999
01:14:38,580 --> 01:14:43,020
所以你说你必须对印度协议进行一些更改，

1000
01:14:43,020 --> 01:14:49,820
那些需要在多大程度上进行修改，你的部署策略或方法是什么样的？

1001
01:14:49,820 --> 01:14:55,220
策略是否可以仅限于发布者，以及

1002
01:14:55,220 --> 01:15:00,450
数据的接收者或者所有网络元素都必须知道这一点吗？

1003
01:15:00,450 --> 01:15:01,380
你能做到这一点吗？

1004
01:15:01,380 --> 01:15:06,240
你能把它们全部塞进命名空间构造中吗？

1005
01:15:06,240 --> 01:15:07,479
是的。

1006
01:15:07,479 --> 01:15:15,540
所以正如我所说，这些更改必须在整个网络中被知晓。

1007
01:15:15,540 --> 01:15:20,000
这些修改中的一部分是我们放在利益中的索引，

1008
01:15:20,000 --> 01:15:23,550
这些信息是被包含在利益之中的，但

1009
01:15:23,550 --> 01:15:28,860
它是协议规范，每个节点都应该知道这些变化。

1010
01:15:28,860 --> 01:15:29,580
这些被称为变化。

1011
01:15:31,000 --> 01:15:32,190
好的。

1012
01:15:32,190 --> 01:15:35,898
我认为这包含了聊天中一个问题的答案，

1013
01:15:35,898 --> 01:15:39,229
我认为这包含了聊天中一个问题的答案，即如何以不同的方式命名利益？

1014
01:15:39,229 --> 01:15:42,500
生产者是否会用编码后的数据进行回应？

1015
01:15:42,500 --> 01:15:48,123
[交叉谈话] 是的，那会不会让她产生兴趣，让她知道该提出请求？

1016
01:15:48,123 --> 01:15:49,822
那些特别的名字？

1017
01:15:49,822 --> 01:15:54,797
是的，所以兴趣在它的名字中承载着

1018
01:15:54,797 --> 01:15:59,263
我们正在请求编码内容，和

1019
01:15:59,263 --> 01:16:06,549
这个MILIC指数指示我们希望响应中包含哪个编码数据包。

1020
01:16:06,549 --> 01:16:11,301
>> 但这可能对于协议栈来说是透明的，我是说，这可能对协议栈是透明的，而且

1021
01:16:11,301 --> 01:16:15,158
这是否仅仅在名称上，还是必须要有实质内容？

1022
01:16:15,158 --> 01:16:19,117
在编码时他们显然必须知道，而在解码时也同样需要知道，但是……

1023
01:16:19,117 --> 01:16:22,120
这可能位于印度层的上方吗？

1024
01:16:23,710 --> 01:16:27,230
>> 是的，确实，>> 我指的是部分运输工具。

1025
01:16:27,230 --> 01:16:30,730
>> 是的，>> 好的。

1026
01:16:30,730 --> 01:16:35,320
MILIC是否依赖于生产者之间的某种同步，以确保他们都会

1027
01:16:35,320 --> 01:16:39,710
知道相同的线性无关子集。

1028
01:16:39,710 --> 01:16:45,558
>> 所以，基本上这仅仅是一个构造实际上

1029
01:16:45,558 --> 01:16:51,148
所以，基本上这仅仅是一个编码向量的子集。

1030
01:16:51,148 --> 01:16:54,990
你看，>> 好的。

1031
01:16:54,990 --> 01:16:58,070
>> 仅仅通过查看索引，我们就可以看出，

1032
01:16:58,070 --> 01:17:02,860
好的，这些是我们必须对代码或内容施加的限制。

1033
01:17:02,860 --> 01:17:07,500
第一个部分需要是非零的，其他的可以随机选择。

1034
01:17:07,500 --> 01:17:11,002
对于第二个，第一个必须是零，第二个，

1035
01:17:11,002 --> 01:17:14,724
肯定不是零，其他的可以随机选择。

1036
01:17:14,724 --> 01:17:19,576
我们只是在混合数据包，这只是对你如何混合的一个限制。

1037
01:17:19,576 --> 01:17:23,900
我们并不是在将内容拆分到不同的组中。

1038
01:17:24,900 --> 01:17:26,610
>> 好的，非常感谢。

1039
01:17:26,610 --> 01:17:27,600
我们没有时间了。

1040
01:17:27,600 --> 01:17:32,780
我认为聊天中还有一个问题，如果你想的话，稍后可以看看。

1041
01:17:32,780 --> 01:17:39,960
但我们将继续下一位发言人，他是赵先生。

1042
01:17:39,960 --> 01:17:43,957
他是加州大学洛杉矶分校计算机科学系的博士研究生。

1043
01:17:43,957 --> 01:17:47,706
并且他还担任研究科学家，

1044
01:17:47,706 --> 01:17:50,546
在智能融合技术领域。

1045
01:17:50,546 --> 01:17:55,166
他将会讨论一些与同事们的合作研究工作。

1046
01:17:55,166 --> 01:17:59,450
来自阿拉巴马大学和纽约市立学院，

1047
01:17:59,450 --> 01:18:02,652
关于水下无线通信。

1048
01:18:02,652 --> 01:18:03,879
那么就开始吧。

1049
01:18:06,229 --> 01:18:07,356
好的，谢谢。

1050
01:18:07,356 --> 01:18:13,877
>> 感谢您今天来参加这次演讲。

1051
01:18:13,877 --> 01:18:17,427
我将要展示我们的合作研究，名为

1052
01:18:17,427 --> 01:18:23,553
数据网络架构设计到水下物联网。

1053
01:18:23,553 --> 01:18:26,151
这是今天演讲的大纲。

1054
01:18:26,151 --> 01:18:32,650
首先问题是什么是水下通信？

1055
01:18:34,000 --> 01:18:36,480
或者回想一下IOUT通信。

1056
01:18:36,480 --> 01:18:39,890
那么一个典型的水下物联网可能会是~!@#$%^&*()

1057
01:18:39,890 --> 01:18:44,340
是一个涉及三层网络系统的，首先是，

1058
01:18:44,340 --> 01:18:49,530
大量的机载传感器，或声学定位系统，

1059
01:18:49,530 --> 01:18:53,340
自主水下航行器，或无人水面航行器。

1060
01:18:53,340 --> 01:18:56,920
第二部分将是声学指示，或者说

1061
01:18:56,920 --> 01:19:02,270
本地射频链接、蜂窝或卫星链接，甚至连接这些东西。

1062
01:19:02,270 --> 01:19:08,168
第三部分将是网络拓扑，如简单的单跳或

1063
01:19:08,168 --> 01:19:12,673
多跳自组网，无论是静态的、移动的还是基于云的。

1064
01:19:12,673 --> 01:19:15,065
最后的部分实际上是用户。

1065
01:19:15,065 --> 01:19:20,654
它可以是附近的传感器、防抱死制动系统（ABS）或者是水面船只，甚至是岸上的设备。

1066
01:19:20,654 --> 01:19:26,394
因此，IOUT的主要任务将是收集数据、共享数据，

1067
01:19:26,394 --> 01:19:31,982
以及包括控制管理，还可能涉及数据分析。

1068
01:19:31,982 --> 01:19:37,230
有时候，我会直接跳过这张幻灯片，不做介绍。

1069
01:19:37,230 --> 01:19:42,155
但是必须在这里提到NDN带来的一些新事物。

1070
01:19:42,155 --> 01:19:46,678
在这些幻灯片中，实际上是数据交换的兴趣所在，

1071
01:19:46,678 --> 01:19:50,958
在这些幻灯片中，实际上是数据交换的兴趣所在，包括了所谓的端到端安全性、数据同步，还有也是实际上依赖于IOUT设计的代码仓库。

1072
01:19:50,958 --> 01:19:55,929
此外，代码仓库实际上也是基于IOUT设计的，极大地依赖于它。

1073
01:19:55,929 --> 01:20:00,863
因此，IOUT实际上与IOT环境类似，

1074
01:20:00,863 --> 01:20:06,180
因为有很多关于印第安纳州物联网的现有研究，

1075
01:20:06,180 --> 01:20:11,107
它们也展现出了良好的效益，这就是为什么我们感兴趣的原因。

1076
01:20:11,107 --> 01:20:14,325
在IoUT环境中再次实施。

1077
01:20:14,325 --> 01:20:19,418
因此，IoUT有其自身的挑战，这使得它并不完全像IoUT。

1078
01:20:19,418 --> 01:20:22,898
首先，它有非常复杂的通信解决方案，

1079
01:20:22,898 --> 01:20:26,927
当前的水下通信系统主要依赖于声学

1080
01:20:26,927 --> 01:20:28,780
通信技术。

1081
01:20:28,780 --> 01:20:32,778
大的传播延迟以及水下高比特误差率

1082
01:20:32,778 --> 01:20:37,120
声学信道仍然影响通信性能的评估。

1083
01:20:37,120 --> 01:20:40,640
此外，我们还获得了一些新的通信技术。

1084
01:20:40,640 --> 01:20:44,740
在近年来，比如光学或磁通通信。

1085
01:20:44,740 --> 01:20:49,578
尽管它们在吞吐量方面提高了性能，

1086
01:20:49,578 --> 01:20:54,990
延迟或可靠性，但是采用这种水下的硬件前端设备，

1087
01:20:54,990 --> 01:21:00,568
通信技术可能有各种各样的无线电设备，如网络接口。

1088
01:21:00,568 --> 01:21:04,805
而且，链接在寻址系统上也可能有所不同，

1089
01:21:04,805 --> 01:21:09,041
IP子网和网络层数据包与~!@#$%^&*()之间的映射机制

1090
01:21:09,041 --> 01:21:11,130
应用数据。

1091
01:21:11,130 --> 01:21:13,470
因此，另一方面，识别和

1092
01:21:13,470 --> 01:21:17,200
跟踪技术与传统无线网络相比有很大的不同，或者

1093
01:21:17,200 --> 01:21:21,520
宽广的IoUT，这导致了复杂的寻址等问题。

1094
01:21:21,520 --> 01:21:27,280
访问IoUT中所有连接设备的最后一项要求是需要通过局部中间件或管理相关的设备。

1095
01:21:27,280 --> 01:21:32,580
访问IoUT中所有连接设备的最后一项要求是需要通过局部中间件或管理相关的设备，或通过远程云服务来处理数据检索和分发。

1096
01:21:32,580 --> 01:21:37,050
远程云服务来处理数据检索和分发。

1097
01:21:37,050 --> 01:21:41,715
在主机到主机通信模型之上开发这样一个覆盖层是

1098
01:21:41,715 --> 01:21:44,560
非常不简单，更不用说维护它了。

1099
01:21:45,570 --> 01:21:50,020
在动态场景中，网络接口中的所有设备和~!@#$%^&*()

1100
01:21:50,020 --> 01:21:52,190
通信渠道可能会不断变化。

1101
01:21:54,950 --> 01:21:58,170
我们还面临着许多其他挑战，例如

1102
01:21:58,170 --> 01:22:03,200
例如，IoUT设备的能源问题，

1103
01:22:03,200 --> 01:22:07,100
由于电池空间限制，操作寿命非常有限。

1104
01:22:07,100 --> 01:22:13,993
而且从能耗方面来看，声波通信非常耗电。

1105
01:22:13,993 --> 01:22:17,353
而且，与IoUT不同，更换这些电池或者

1106
01:22:17,353 --> 01:22:20,429
能量充电可能是一件非常非常困难的事情。

1107
01:22:22,440 --> 01:22:25,545
下一件事是带宽和移动性，所以

1108
01:22:25,545 --> 01:22:30,540
IoUT将把水下相关研究领域带入大数据时代。

1109
01:22:30,540 --> 01:22:34,980
IoUT设备生成和收集数据的能力可以

1110
01:22:34,980 --> 01:22:39,576
在传输过程中容易抑制通信能力。

1111
01:22:41,274 --> 01:22:43,574
还有一些其他方面，比如可靠性，

1112
01:22:43,574 --> 01:22:48,120
这意味着声学通信遭受着非常高的比特错误率。

1113
01:22:48,120 --> 01:22:51,980
并且数据还需要按顺序接收，不得

1114
01:22:51,980 --> 01:22:56,070
丢失即使TCP能够处理这个问题，但它效率不高。

1115
01:22:56,070 --> 01:22:58,402
而且，最后一点是安全性，

1116
01:22:58,402 --> 01:23:02,470
在物联网中，数据对某些应用程序是私有的。

1117
01:23:02,470 --> 01:23:07,285
而设备通常成本高昂，同时，现有解决方案并不适用于

1118
01:23:07,285 --> 01:23:10,200
Internet of Underwater Things.

1119
01:23:10,200 --> 01:23:14,751
所以，我们为什么认为NFN适合IoUT，首先，NDN，

1120
01:23:18,580 --> 01:23:23,940
并通过统一的基于数据命名的API来替换这些实体。

1121
01:23:23,940 --> 01:23:28,710
因此，这导致了对领域使用需求的重大转变。

1122
01:23:29,730 --> 01:23:33,787
因此，第二点是NDN架构通过以下方式带来了效率：

1123
01:23:33,787 --> 01:23:35,337
在网络缓存和

1124
01:23:35,337 --> 01:23:40,294
在网络缓存和平衡带宽、延迟、能源以及移动性等多个因素方面，And also, NDN enables security binding to data self, unifying and

1125
01:23:40,294 --> 01:23:45,039
同时，NDN实现了数据自身的安全绑定，统一并且

1126
01:23:45,039 --> 01:23:50,795
简化了数据和网络操作的访问和信任管理。

1127
01:23:53,334 --> 01:24:00,104
这里是我们提出的面向IoUT的NDN架构概览的图示。

1128
01:24:00,104 --> 01:24:04,834
因此为了处理各种底层通信技术，它们与TCP/IP协议栈兼容，

1129
01:24:04,834 --> 01:24:08,094
因此，为了处理各种底层通信技术，它们与TCP/IP协议栈兼容，

1130
01:24:08,094 --> 01:24:12,344
因此，一个实用的方法是创建一个NDN（命名数据网络）覆盖网络作为中间件。

1131
01:24:12,344 --> 01:24:16,470
该覆盖网络将负责处理网络映射的功能。

1132
01:24:16,470 --> 01:24:21,795
接口连接到水下设备，管理预定数据的命名空间和

1133
01:24:21,795 --> 01:24:24,732
管理通信的安全性。

1134
01:24:24,732 --> 01:24:28,761
需要在这里也做出额外的努力，例如，

1135
01:24:28,761 --> 01:24:33,597
需要在这里也做出额外的努力，例如，二层配置以确保不同类型的流量能够相互流通，IoUT子网、IP地址和端口号的分配管理。

1136
01:24:33,597 --> 01:24:38,432
IoUT子网、IP地址和端口号的分配管理用于

1137
01:24:38,432 --> 01:24:43,850
网络连接，甚至是安全数据的收集和转发。

1138
01:24:45,720 --> 01:24:49,610
那么，让我们快速看一下我们提议实施的一些部分。

1139
01:24:51,350 --> 01:24:57,490
首先是数据和命名，因此NDN使用有意义的名称来表示

1140
01:24:57,490 --> 01:25:02,220
应用数据而不是在网络层的主机地址。

1141
01:25:02,220 --> 01:25:07,920
所以，这里展示的例子中，使用了分层的、人类可读的名称来

1142
01:25:07,920 --> 01:25:11,070
水温数据响应一个表层节点。

1143
01:25:11,070 --> 01:25:17,010
在NDN中，用户也可以使用兴趣数据来表达控制命令。

1144
01:25:17,010 --> 01:25:21,050
该机制是将控制命令作为参数字段携带。

1145
01:25:21,050 --> 01:25:23,800
在兴趣数据中，在兴趣包中，

1146
01:25:23,800 --> 01:25:27,460
将兴趣发送到设备，而无需预先对命令表示兴趣。

1147
01:25:27,460 --> 01:25:31,832
所以，这样的兴趣可以包含一个目标名称、目标节点名称前缀以及

1148
01:25:31,832 --> 01:25:36,002
相应的命令需要传送给目标节点，为了

1149
01:25:36,002 --> 01:25:39,247
例如，向左移动表面，移动50米。

1150
01:25:42,523 --> 01:25:48,738
（咳嗽声）所以这个展示的是基于名称的基本路由和转发。

1151
01:25:48,738 --> 01:25:53,355
我想在这里补充一点，现有的水下路由

1152
01:25:53,355 --> 01:25:56,329
协议实际上可以被修订并使用于

1153
01:25:56,329 --> 01:26:00,724
数据发布者在NDN架构中宣传名称前缀。

1154
01:26:00,724 --> 01:26:05,748
例如，一些传感数据可以由海上的传感器发布。

1155
01:26:05,748 --> 01:26:09,120
而用户也可以在水面上。

1156
01:26:09,120 --> 01:26:13,970
而这些传感器可以根据哪种路由协议在深水中使用，以便在水面上更好地传输数据和传递信息。

1157
01:26:13,970 --> 01:26:16,270
更好地数据转发和传递。

1158
01:26:16,270 --> 01:26:20,560
同样，空中位置信息是名称的一部分并且

1159
01:26:20,560 --> 01:26:23,863
基于水路路由协议的地理路由

1160
01:26:23,863 --> 01:26:28,497
可以用来帮助填充数据的前缀。

1161
01:26:32,562 --> 01:26:36,713
下一部分是网络内存储，IoUT应用可以同时利用所有类型的网络内存储。

1162
01:26:36,713 --> 01:26:40,760
同时利用所有类型的网络内存储。

1163
01:26:40,760 --> 01:26:43,930
例如，水下传感器可以传输，

1164
01:26:43,930 --> 01:26:47,550
立即切断数据，将仓库部署在附近。

1165
01:26:47,550 --> 01:26:51,170
由于在这些传感器上加密大容量存储成本很高。

1166
01:26:51,170 --> 01:26:55,720
然后，地面用户可以从存储库中检索数据，而不是直接从传感器中获取。

1167
01:26:55,720 --> 01:26:59,430
传感器会在可用带宽充足时进行数据传输。

1168
01:26:59,430 --> 01:27:02,885
当多个用户请求收集的数据时，

1169
01:27:02,885 --> 01:27:07,330
网络中的机会性缓存也可以帮助高效地转发数据。

1170
01:27:07,330 --> 01:27:10,120
通过减少传输跳数和传播距离。

1171
01:27:10,120 --> 01:27:14,650
因此，由于IoUT的稀疏性和移动性特征，

1172
01:27:14,650 --> 01:27:18,550
因此，网络连接可能并不总是保持连续的。

1173
01:27:18,550 --> 01:27:23,020
因此，通信必须能够容忍延迟，在网络存储中结束。

1174
01:27:23,020 --> 01:27:24,313
可以完美地适应。

1175
01:27:27,812 --> 01:27:33,401
接下来的两张幻灯片中，我们将会看一些需要的功能。

1176
01:27:33,401 --> 01:27:35,520
同时也由NDN提供。

1177
01:27:35,520 --> 01:27:40,100
我们实际上借鉴了NDN IoUT工作中的一些想法。

1178
01:27:40,100 --> 01:27:44,600
所以这里，第一个是关于启动和服务发现。

1179
01:27:44,600 --> 01:27:48,570
So in traditional IP network devices, bootstrapping and

1180
01:27:48,570 --> 01:27:52,740
通常涉及复杂和繁琐的操作。

1181
01:27:52,740 --> 01:27:56,770
在处理不同的网络和通信媒介时，情况甚至更糟。

1182
01:27:56,770 --> 01:27:59,610
因此，在NDN中，引导和~!@#$%^&*()

1183
01:27:59,610 --> 01:28:04,900
服务发现可以通过简化地使用兴趣数据来实现。

1184
01:28:04,900 --> 01:28:09,680
请求的响应允许为设备提供三个关键配置。

1185
01:28:09,680 --> 01:28:14,840
第一个是为生成的数据命名的适当前缀。

1186
01:28:14,840 --> 01:28:18,330
第二个是适当分配和加密密钥以用于

1187
01:28:18,330 --> 01:28:20,060
加密所生成的数据。

1188
01:28:20,060 --> 01:28:23,540
以及最后一个是信任锚和用于解密的密钥

1189
01:28:23,540 --> 01:28:25,320
消耗资源以检索数据。

1190
01:28:25,320 --> 01:28:27,990
所以这个图实际上展示了一个非常简单的例子

1191
01:28:27,990 --> 01:28:30,000
所以这个图实际上展示了一个非常简单的例子，它说明了引导程序是如何工作的。And also the next slides is showing the service discovery.

1192
01:28:30,000 --> 01:28:33,990
接下来的幻灯片将展示服务发现。

1193
01:28:35,420 --> 01:28:40,520
所以基本上我们要从控制器那里学习现有的服务。

1194
01:28:41,520 --> 01:28:44,410
接着我们将通过广播方式宣传这项服务，

1195
01:28:44,410 --> 01:28:47,490
启动之后进行广播广告。

1196
01:28:47,490 --> 01:28:52,010
然后当服务发生变化时，再次进行广播。

1197
01:28:52,010 --> 01:28:52,620
重新启动。

1198
01:28:54,780 --> 01:29:00,100
我们想说的最后一件事是关于适应层。

1199
01:29:00,100 --> 01:29:03,760
适应性对于给物联网用户带来全面的NDN好处是非常重要的，而且只需付出最小的努力。

1200
01:29:03,760 --> 01:29:07,870
为了让物联网用户以最小的努力获得NDN的全部好处。

1201
01:29:07,870 --> 01:29:12,510
因此，我们的设计中放置了两个适配层。

1202
01:29:12,510 --> 01:29:14,640
第一个发生在较低层。

1203
01:29:14,640 --> 01:29:17,630
它实际上只是抽象了不同的链路层协议。

1204
01:29:17,630 --> 01:29:21,960
它将NDN的兴趣包和数据包封装进链路层帧中。

1205
01:29:21,960 --> 01:29:27,190
所以基本上是将名字前缀转换成接口映射。

1206
01:29:27,190 --> 01:29:29,930
而另一个发生在上层，

1207
01:29:29,930 --> 01:29:32,970
它实际上正在进行翻译工作的将会进行翻译

1208
01:29:32,970 --> 01:29:37,330
应用层信息转换为NDN更有意义的数据名称。

1209
01:29:37,330 --> 01:29:42,730
在进行名字前缀转换到数据映射之后。

1210
01:29:44,090 --> 01:29:46,900
所以，我们来到了结论部分。

1211
01:29:46,900 --> 01:29:51,280
我不打算全部阅读，但有一点我想要提出的是我们正在

1212
01:29:51,280 --> 01:29:56,660
我们目前正在基于ndnSIM进行真实仿真完成工作。

1213
01:29:56,660 --> 01:30:00,720
还有另一个类似的水下较低层，称为获取层。

1214
01:30:00,720 --> 01:30:03,220
我们仍在进行一项模拟工作，

1215
01:30:03,220 --> 01:30:06,750
我们预计今年晚些时候会有一些结果出现。

1216
01:30:06,750 --> 01:30:09,660
我们非常感谢任何评论、建议以及

1217
01:30:09,660 --> 01:30:12,060
也得到了NDN社区的一些帮助。

1218
01:30:12,060 --> 01:30:15,210
这就是我今天演讲的全部内容。

1219
01:30:15,210 --> 01:30:15,760
谢谢。

1220
01:30:17,150 --> 01:30:19,420
好的，谢谢你，Qi。

1221
01:30:19,420 --> 01:30:21,760
我们收到了Kathy Nichols的一个问题。

1222
01:30:21,760 --> 01:30:24,380
如果你通过兴趣发送指令，

1223
01:30:24,380 --> 01:30:27,852
这不就意味着你必须仔细地定位兴趣，因为它会

1224
01:30:27,852 --> 01:30:32,820
意味着它会被第一个能够响应的节点捕获？

1225
01:30:32,820 --> 01:30:38,950
对，这是真的，就像我说的，我们只是简单地借鉴了这个

1226
01:30:38,950 --> 01:30:44,800
是的，这是真的，就像我说的，我们只是简单地借鉴了NDN（命名数据网络）的设计思想，因为兴趣包可以携带命令。但这是真的，我们需要谨慎使用这一点，因为

1227
01:30:44,800 --> 01:30:49,342
但这是真的，我们需要谨慎使用这一点，因为

1228
01:30:49,342 --> 01:30:53,136
这将与安全有关，是的。

1229
01:31:00,899 --> 01:31:07,170
>> 对不起，Pawan 有个问题，传感器有多频繁地广播前缀？

1230
01:31:07,170 --> 01:31:10,770
他们每次产生新数据都这样做吗？

1231
01:31:10,770 --> 01:31:16,510
如果不是这样，那么消费者怎么知道新数据的产生呢？

1232
01:31:16,510 --> 01:31:18,720
是的，这是一个好问题。

1233
01:31:18,720 --> 01:31:24,565
实际上这完全取决于预配置的类型，因为我们说过，

1234
01:31:24,565 --> 01:31:29,480
在水下通信环境中，

1235
01:31:29,480 --> 01:31:33,020
所有那些实际上非常耗电的设备。

1236
01:31:33,020 --> 01:31:36,960
那么，如果我们一直在数据可用时进行广告推广，

1237
01:31:36,960 --> 01:31:40,980
那么，这对那些设备来说将会是一场噩梦。

1238
01:31:42,880 --> 01:31:47,650
因此，在实施这一点时可能会有不同的策略。

1239
01:31:48,840 --> 01:31:54,540
因此，我们实际上想要做的是，我们可以在某种程度上

1240
01:31:54,540 --> 01:31:59,030
根据不同类型的设备制定一些不同的策略。

1241
01:31:59,030 --> 01:32:03,170
根据某些优先级事项来决定数据的类型。

1242
01:32:05,310 --> 01:32:10,720
区分不同数据的紧急优先级或尝试

1243
01:32:10,720 --> 01:32:16,770
为消费者甚至生产者提供灵活性。

1244
01:32:19,090 --> 01:32:19,900
好的，谢谢。

1245
01:32:19,900 --> 01:32:23,350
好的，谢谢。

1246
01:32:23,350 --> 01:32:28,040
我们现在转到本环节的最后一位演讲者，Randall King。

1247
01:32:28,040 --> 01:32:32,850
他目前是Operant Networks的首席技术官。

1248
01:32:32,850 --> 01:32:36,930
一家专注于提供安全且弹性通信的商业初创公司，服务于多种市场和行业。

1249
01:32:36,930 --> 01:32:41,790
弹性通信服务覆盖了多种市场和行业。

1250
01:32:41,790 --> 01:32:45,810
他的职业生涯专注于将技术从学术界和行业研究人员转移到商业化引入和

1251
01:32:45,810 --> 01:32:48,660
行业研究人员到商业引进和

1252
01:32:48,660 --> 01:32:52,050
他希望在最后重现这一模式。

1253
01:32:52,050 --> 01:32:56,610
在惠普公司从事多年光纤和无线通信工作后，

1254
01:32:56,610 --> 01:32:59,460
他将注意力转向了可再生能源，并且

1255
01:32:59,460 --> 01:33:02,830
帮助建立了一家成功的太阳能行业初创企业。

1256
01:33:02,830 --> 01:33:07,090
Operant是由一群有着那些经历的人组成的团队。

1257
01:33:07,090 --> 01:33:12,470
对于使用NDN来过渡我们的能源系统成为其中的一部分感到兴奋。

1258
01:33:12,470 --> 01:33:17,050
转向未来更清洁、更有弹性和更安全的智能电网。

1259
01:33:17,050 --> 01:33:19,475
那么，我就把话筒交给Randall。

1260
01:33:20,910 --> 01:33:22,190
谢谢，Kim。

1261
01:33:22,190 --> 01:33:25,005
让我开始共享屏幕。

1262
01:33:30,840 --> 01:33:36,780
所以，我今天将主要介绍我们在过去一年中完成的一些工作。

1263
01:33:36,780 --> 01:33:43,000
合作之间的Operant Networks和Pollere Kathleen Nichols公司。

1264
01:33:44,100 --> 01:33:49,030
这次演讲的特别重点是我们如何能够对现有的大型应用程序代码库进行改造，以便从NDN中获益。

1265
01:33:49,030 --> 01:33:53,710
我们如何能够对现有的大型应用程序代码库进行改造，以便从NDN中获益。

1266
01:33:55,020 --> 01:33:58,610
在这一点上，您可能会有两个合理的疑问，那就是为什么

1267
01:33:58,610 --> 01:33:59,940
我们怎样做这件事？

1268
01:33:59,940 --> 01:34:01,880
那么我们该如何做这件事呢？

1269
01:34:01,880 --> 01:34:06,840
这些就是我希望在演讲结束时能回答的问题。

1270
01:34:06,840 --> 01:34:10,950
那么，操作者，这完全是关于商业化NDN的事情。

1271
01:34:10,950 --> 01:34:16,810
我今天早上真的很喜欢那个关于NDN接下来需要什么的讨论小组。

1272
01:34:16,810 --> 01:34:20,310
从我们的角度来看，我们的CEO昨晚告诉我

1273
01:34:20,310 --> 01:34:25,580
所需的是一个真正的客户，用真金白银购买真正的产品。

1274
01:34:25,580 --> 01:34:30,251
这正是Operant专注寻找的那种重要客户。

1275
01:34:31,868 --> 01:34:35,912
但是每当我们与潜在客户交谈时，我们必须告诉他们NDN的运作方式与众不同，并开始讨论关于兴趣数据交换等事宜。

1276
01:34:35,912 --> 01:34:40,220
运作方式与众不同，并开始讨论关于兴趣数据交换等事宜。

1277
01:34:40,220 --> 01:34:43,560
但在引入新技术的背景下，

1278
01:34:43,560 --> 01:34:46,720
我们现在已经突出了一个采纳障碍。

1279
01:34:46,720 --> 01:34:49,870
因为顾客不想要新的，他们想要更好的。

1280
01:34:49,870 --> 01:34:53,850
因此，特别是要采用新技术，

1281
01:34:53,850 --> 01:34:55,750
他们必须有强烈的动力。

1282
01:34:55,750 --> 01:34:57,010
它不能只好上10%。

1283
01:34:57,010 --> 01:34:58,480
它必须要好上10倍。

1284
01:35:00,030 --> 01:35:02,950
所以我们在过去几年里一直在了解什么

1285
01:35:02,950 --> 01:35:07,160
将是促使人们转向基于NDN的解决方案的动因。

1286
01:35:08,300 --> 01:35:10,090
这四种显得尤为突出。

1287
01:35:10,090 --> 01:35:14,000
第一是安全性，这对人们来说至关重要。

1288
01:35:14,000 --> 01:35:16,620
它正成为潮流，每个人都想谈论它，但是

1289
01:35:16,620 --> 01:35:19,975
它非常难以量化和用金钱来评估其价值。

1290
01:35:19,975 --> 01:35:23,865
尝试对安全性进行金钱估值。

1291
01:35:23,865 --> 01:35:27,940
多方通信，我认为这是个大事，但是

1292
01:35:27,940 --> 01:35:31,960
它还不普遍，但它在地平线上，人们想要谈论它，但是

1293
01:35:31,960 --> 01:35:37,360
他们在那里购买解决方案的程度远没有我希望的那么多。

1294
01:35:37,360 --> 01:35:40,400
在串联或并联中运行多个物理层。

1295
01:35:40,400 --> 01:35:43,000
NDN具有很强的能力，但是……

1296
01:35:43,000 --> 01:35:46,850
在工业中有很多解决这些问题的变通办法。

1297
01:35:47,960 --> 01:35:51,770
缓存和数据吞吐量，又是一个很棒的特性，但是

1298
01:35:51,770 --> 01:35:56,590
大型客户已经部署了基于传统网络的解决方案，

1299
01:35:56,590 --> 01:35:59,951
他们目前还没有强烈的动力去做出改变。

1300
01:35:59,951 --> 01:36:03,133
所以，我们还没有找到锁定应用程序，

1301
01:36:03,133 --> 01:36:07,503
如果你不在最后期限之前完成，那你就无法完成了。

1302
01:36:07,503 --> 01:36:09,959
这似乎很难找到。

1303
01:36:09,959 --> 01:36:15,412
相反，我们发现的是具有这些参数多个倍数的。

1304
01:36:15,412 --> 01:36:16,349
激励因素。

1305
01:36:16,349 --> 01:36:21,212
特别要提到的一个是入侵检测系统，

1306
01:36:21,212 --> 01:36:25,612
这是我们大约一年半前开始参与的事情。

1307
01:36:25,612 --> 01:36:30,758
这只是一个简单的背景介绍，我相信在场的每个人都知道，但是

1308
01:36:30,758 --> 01:36:35,753
大多数网络安全保护工具如今都是防火墙，用来保护网络。

1309
01:36:35,753 --> 01:36:41,221
参数通常是在数据包穿越网络边界时查看其有效载荷。

1310
01:36:41,221 --> 01:36:46,207
但是加密流量的增长使得查看这些数据包变得更加困难，

1311
01:36:46,207 --> 01:36:47,433
更难了，我认为。

1312
01:36:47,433 --> 01:36:51,746
超过70%的企业网络流量现在是加密的。

1313
01:36:51,746 --> 01:36:57,554
而且另一个问题是，精通技术的黑客最终总能突破网络边界。

1314
01:36:57,554 --> 01:37:01,099
这几乎是不可能防止的事情。

1315
01:37:01,099 --> 01:37:07,074
因此，入侵检测系统或IDS，为防火墙提供了补充，并且

1316
01:37:07,074 --> 01:37:11,065
他们开始引起了更多的兴趣。

1317
01:37:11,065 --> 01:37:15,213
我们所研究的那种，它们会检查TCP/IP数据包的头部信息并且

1318
01:37:15,213 --> 01:37:19,029
它们监控流量模式并寻找异常情况。

1319
01:37:19,029 --> 01:37:22,415
它们特别有价值，因为黑客，

1320
01:37:22,415 --> 01:37:26,981
一旦他们渗透进大型校园或军事基地的边界，他们就会潜伏下来。

1321
01:37:26,981 --> 01:37:29,703
他们通常会花费超过一个月的时间，

1322
01:37:29,703 --> 01:37:34,702
这些精通技术的黑客在真正发起攻击之前，通常会潜伏在网络中一段时间。

1323
01:37:34,702 --> 01:37:37,811
他们在寻找漏洞。

1324
01:37:37,811 --> 01:37:42,117
所以如果你在你的校园周围分布交通传感器并且

1325
01:37:42,117 --> 01:37:47,466
如果你观察内部流动，你可以了解到很多正在发生的事情。

1326
01:37:47,466 --> 01:37:52,648
我们合作的一位空军人员告诉我，食堂不应该

1327
01:37:52,648 --> 01:37:58,177
应该与雷达罩进行对话，我认为这是一个很好的形象化表达。

1328
01:37:58,177 --> 01:38:02,438
因此，特别是分布式的入侵检测系统，

1329
01:38:02,438 --> 01:38:07,316
因此，特别是分布式的入侵检测系统，是一个我们认为可以展示NDN一些好处的领域。因为它结合了对高安全性的需求，因为这些观察网络，

1330
01:38:07,316 --> 01:38:12,685
因为它结合了对高安全性的需求，因为这些观察网络，

1331
01:38:12,685 --> 01:38:18,130
这些分布在校园各处的传感器的入侵检测系统（IDS）相互通信，以协作检测流量异常并向数据分析服务器提供数据。

1332
01:38:18,130 --> 01:38:23,917
协作检测流量异常并向数据分析服务器提供数据。

1333
01:38:23,917 --> 01:38:28,344
他们必须比他们监控的网络更加安全。

1334
01:38:28,344 --> 01:38:33,423
否则，如果有人黑进了你的网络而你却不知情，那又有什么用呢？

1335
01:38:33,423 --> 01:38:37,937
它们可以停止入侵检测系统，但你实际上并没有提供任何价值。

1336
01:38:37,937 --> 01:38:42,502
你可以看到这也是一个多方通信的事情，

1337
01:38:42,502 --> 01:38:44,870
意味着许多分布式传感器。

1338
01:38:44,870 --> 01:38:47,112
它可以利用多播来获益。

1339
01:38:47,112 --> 01:38:51,952
所以它有很多我在前一张幻灯片上提到的动机因素。

1340
01:38:51,952 --> 01:38:55,935
我们向空军和能源部提出了这个想法，

1341
01:38:55,935 --> 01:39:00,749
他们分别同意了，并且都资助了一个基于印度的分布式

1342
01:39:00,749 --> 01:39:05,508
入侵检测系统，我们已经研究了大约一年时间。

1343
01:39:05,508 --> 01:39:09,510
这就是你开始思考如何推出一款产品的地方。

1344
01:39:09,510 --> 01:39:14,598
因此客户不仅仅购买网络设备，他们购买的是完整的解决方案。

1345
01:39:14,598 --> 01:39:19,405
在我们调查的一个市场中，一位客户告诉我们，他们在完整解决方案和

1346
01:39:19,405 --> 01:39:22,221
他们在完整解决方案上的支出与

1348
01:39:25,055 --> 01:39:29,743
所以如果你只是出售连接服务，你只关注于提供5%的

1349
01:39:29,743 --> 01:39:33,493
价值，这并不能激励一家商业公司。

1350
01:39:33,493 --> 01:39:37,662
但在网络安全领域，存在一个机会，

1351
01:39:37,662 --> 01:39:41,281
因为这里有一个非常强大的工具社区。

1352
01:39:41,281 --> 01:39:46,161
这里有一个商业上和技术上非常复杂的格局，

1353
01:39:46,161 --> 01:39:49,681
还有很多人在使用协作工具进行合作。

1354
01:39:49,681 --> 01:39:53,931
特别是存在一个强大的开源社区。

1355
01:39:53,931 --> 01:39:56,096
我们就是这样参与进来的，

1356
01:39:56,096 --> 01:40:01,278
我们利用的是一个名为Zeek的系统，它之前被称作Bro，

1357
01:40:01,278 --> 01:40:06,245
这是一个基于开源的系统，经过了几十年的发展。

1358
01:40:06,245 --> 01:40:08,651
它本质上是分布式的。

1359
01:40:08,651 --> 01:40:12,417
它是一个基于传感器的系统，能够执行我之前谈论过的那些功能。

1360
01:40:12,417 --> 01:40:13,144
之前。

1361
01:40:13,144 --> 01:40:17,518
它预处理网络流量，并创建日志和

1362
01:40:17,518 --> 01:40:20,744
它会生成您可以用来检测入侵的警报。

1363
01:40:20,744 --> 01:40:26,656
Zeek已经实现了基于代理的发布/订阅通信框架。

1364
01:40:26,656 --> 01:40:31,350
它使用TCP/IP类型的安全性来进行连接。

1365
01:40:31,350 --> 01:40:35,413
多台机器和多个实例。

1366
01:40:35,413 --> 01:40:40,209
我们所做的就是我们放置了基于TCP的代理发布/订阅系统。

1367
01:40:40,209 --> 01:40:45,112
我们使用了一个基于印度安全NBN基础的代理列表发布/订阅传输方式。

1368
01:40:45,112 --> 01:40:50,751
因此，我们保留了现有Zeek世界90%的价值，并且……

1369
01:40:50,751 --> 01:40:55,829
因此，我们通过增加NDN通信组件来对其进行了增强。

1370
01:40:55,829 --> 01:41:01,077
如果你考虑在一个TCP/IP的世界里如何构建一个安全的发布/订阅系统，

1371
01:41:01,077 --> 01:41:04,522
有两种解决方案浮现在我脑海中。

1372
01:41:04,522 --> 01:41:07,971
一种是MQTT，我相信大多数人都熟悉。

1373
01:41:07,971 --> 01:41:13,282
它是一种非常轻量级的TCP协议，主要用于物联网。

1374
01:41:13,282 --> 01:41:18,458
它具有一个代理，所以有一个中央节点，有时这些节点会出现故障。

1375
01:41:18,458 --> 01:41:23,866
分成多个部分，但总有一个概念，即有人知道所有的位置。

1376
01:41:23,866 --> 01:41:29,059
设备位于一个IP空间内，并且会发布主题和消息。

1377
01:41:29,059 --> 01:41:32,047
这个代理是网络攻击的目标，并且

1378
01:41:32,047 --> 01:41:36,193
它是单点故障的源头，而且确实不完美。

1379
01:41:36,193 --> 01:41:40,400
MQTT本身并不内置安全性特性，你

1380
01:41:40,400 --> 01:41:44,501
必须采用类似TLS的方法来提供这种安全性。

1381
01:41:44,501 --> 01:41:49,494
市场上有一种解决方案更专注于这类事务。

1382
01:41:49,494 --> 01:41:53,169
它被称为DDS，即数据分发服务。

1383
01:41:53,169 --> 01:41:58,258
它确实完成了很多你希望一个安全的发布/订阅系统所能做的事情。

1384
01:41:58,258 --> 01:42:00,401
但基本上所有节点地址和

1385
01:42:00,401 --> 01:42:05,250
订阅的主题必须存储在每个节点中，因为没有代理。

1386
01:42:05,250 --> 01:42:08,484
而这非常困难，因为节点在不断地

1387
01:42:08,484 --> 01:42:12,642
试图了解其他节点并跟踪发布/订阅等所有这些内容，以及

1388
01:42:12,642 --> 01:42:15,356
它对网络的负载实在是太大了。

1389
01:42:15,356 --> 01:42:19,766
当你在任何带宽有限的应用中使用它时，

1390
01:42:19,766 --> 01:42:23,964
你很快就会发现，在任何带宽有限的应用中使用它时，它的效率还是不够高，无法完成所有的 that overhead.

1391
01:42:23,964 --> 01:42:24,976
因此，我们所做的是，我会很快跳过这部分，

1392
01:42:24,976 --> 01:42:29,003
因此，我们所做的是，我会很快跳过这部分，

1393
01:42:29,003 --> 01:42:33,837
首先，因为Kathy Nichols完成了这项工作的大部分底层工作，还有

1394
01:42:33,837 --> 01:42:38,673
其次，因为她已经提供了相当多的信息，

1395
01:42:38,673 --> 01:42:40,384
我在那里引用了一个链接。

1396
01:42:40,384 --> 01:42:45,137
但去年秋天，在ACM会议上，她展示了一个名为DNMP的工作，

1397
01:42:45,137 --> 01:42:48,199
这涉及到了一个定制运输的概念。

1398
01:42:48,199 --> 01:42:53,777
这实际上是一套工具，是一个集合

1399
01:42:53,777 --> 01:42:58,544
它由实现NDN传输的模块组成，并且

1400
01:42:58,544 --> 01:43:02,857
它允许你根据特定需求进行调整。

1401
01:43:02,857 --> 01:43:08,671
于是我们与她合作所做的就是构建了一个基于消息的发布/订阅系统，

1402
01:43:08,671 --> 01:43:14,325
这使我们能够基本上使用她已经开发的相同模块。

1403
01:43:14,325 --> 01:43:18,925
并在此基础上实现了一个类似MQTT的API，这样我们现在就拥有了这个功能。

1404
01:43:18,925 --> 01:43:23,645
基于同步的安全代理服务器列表支持发布/订阅模式，并且

1405
01:43:23,645 --> 01:43:28,385
它可以直接与Zeek应用程序一起工作。

1406
01:43:28,385 --> 01:43:33,345
嵌入在那种方法中的是versec工具包，它

1407
01:43:33,345 --> 01:43:36,352
本·雅各布森一直在研究的。

1408
01:43:36,352 --> 01:43:41,770
这将是一种方式，信任模式可以……

1409
01:43:41,770 --> 01:43:47,062
应用于传输层内的出版物。

1410
01:43:47,062 --> 01:43:52,987
层可以通过复杂的信任规则来控制。

1411
01:43:52,987 --> 01:43:57,245
那些信任规则以签名信任方案二进制的形式部署，所以

1412
01:43:57,245 --> 01:44:01,137
它们可以利用NDN中分布式的所有内在优势。

1413
01:44:01,137 --> 01:44:05,969
>> 为了更新和移动信任模式，提供了相应的方法。

1414
01:44:05,969 --> 01:44:11,013
在所有这些基础上，我们构建了一个被称为Sentinel的系统。

1415
01:44:11,013 --> 01:44:15,916
我不打算尝试逐一解释所有这些不同的方框，但是

1416
01:44:15,916 --> 01:44:21,160
这个想法是它会落入红色的方框中，那就是Zeke管理器。

1417
01:44:21,160 --> 01:44:24,345
它是一个具有特殊角色的Zeke实例。

1418
01:44:24,345 --> 01:44:28,810
它在Zeke中有我提到的不同分布式节点的特殊角色。

1419
01:44:29,850 --> 01:44:35,415
而现有的Zeke消息使用这个蓝色盒子，即Sentinel。

1420
01:44:35,415 --> 01:44:41,820
定制传输作为具有嵌入式Versa信任系统的发布/订阅服务，以及

1421
01:44:41,820 --> 01:44:47,710
它基本上可以替代之前使用TCP/IP的Zeke部分。

1422
01:44:47,710 --> 01:44:50,436
所以这是一个成功的项目。

1423
01:44:50,436 --> 01:44:55,531
我们已经能够在大约一年的时间里让这个项目运作起来。

1424
01:44:55,531 --> 01:44:57,739
我想再强调一个方面，

1425
01:44:57,739 --> 01:45:01,793
这就是它基于我们所说的NDN-IND。

1426
01:45:01,793 --> 01:45:06,893
在这个上下文中，IND代表工业，因为我们想要的是

1427
01:45:06,893 --> 01:45:12,179
将NDN社区带入一个工业用户所在的空间，

1428
01:45:12,179 --> 01:45:17,670
将拥有一个标准化、简化、失效的NDN平台。

1429
01:45:18,790 --> 01:45:23,950
我们现在已经为NDN-IND找到了解决方案，我们将会

1430
01:45:23,950 --> 01:45:29,380
暴露这些问题于今年，面向由此群体代表的NDN社区。

1431
01:45:30,420 --> 01:45:34,650
它们正在由国家实验室审查，作为我们某些资助工作的一部分，

1432
01:45:34,650 --> 01:45:37,569
它们正在由国家实验室审查，作为我们某些资助工作的一部分，比如印度和国家可再生能源实验室。I'm happy to talk to anyone about it more and

1433
01:45:38,600 --> 01:45:41,120
我很乐意进一步与任何人讨论这个话题。

1434
01:45:41,120 --> 01:45:44,930
我们将在明年分发更多信息。

1435
01:45:44,930 --> 01:45:49,795
我们希望下一次我们来到这里时，能够将这个推广给更多的...

1436
01:45:49,795 --> 01:45:53,264
一个商业受众，并进行新闻发布会等活动。

1437
01:45:53,264 --> 01:45:56,831
一种更以宣传为导向的方法来吸引边缘受众。

1438
01:45:56,831 --> 01:46:00,263
例如，这可能为一些用途提供帮助，

1439
01:46:00,263 --> 01:46:04,864
其他行业成员，但它也可以为

1440
01:46:04,864 --> 01:46:09,336
像Jeff Burke今天早上谈到的那些黑客。

1441
01:46:09,336 --> 01:46:14,309
我们对NDN-IND进行了一些针对Sentinel的具体更改，这在某种程度上是一个例子。

1442
01:46:14,309 --> 01:46:18,579
我们将谨慎且循序渐进地推进它的发展。

1443
01:46:19,710 --> 01:46:22,900
例如，我们正在添加AEAD加密作为一种选择，

1444
01:46:22,900 --> 01:46:27,890
因为我们认为这是NDN在工业环境中可以使用的一个进步。

1445
01:46:29,790 --> 01:46:36,070
因此，总结来说，我们已经使用Sentinel IDS实现了

1446
01:46:36,070 --> 01:46:42,380
我们在Cathy定制的传输基础上实现了无代理的NDN发布/订阅系统。

1447
01:46:43,420 --> 01:46:48,230
我们在此基础上构建了Sims，专门为用户界面设计。

1448
01:46:48,230 --> 01:46:51,550
我们为空军和太阳能市场构建了两个不同的界面。

1449
01:46:52,590 --> 01:46:55,230
这展示了一种方法

1450
01:46:55,230 --> 01:47:00,150
在最后对现有的复杂应用程序进行改造。

1451
01:47:00,150 --> 01:47:02,470
但在商业上可行的努力范围内，

1452
01:47:02,470 --> 01:47:05,070
我们不需要重写Zeke提供的所有代码。

1453
01:47:07,590 --> 01:47:13,555
作为下一步，我们将考察其他可能的MQTT应用。

1454
01:47:13,555 --> 01:47:17,630
由于我们现在有了这种发布/订阅机制，它可以很容易地嵌入到可能需要使用MQTT的场合，但是不需要经纪人且更加安全。

1455
01:47:17,630 --> 01:47:21,730
期望使用MQTT，但无需经纪人且更加安全。

1456
01:47:23,050 --> 01:47:25,890
接下来的一年，我们真正的重点将是应用这些技术于公用事业通信。

1457
01:47:25,890 --> 01:47:28,900
将这些技术应用于公用事业通信。

1458
01:47:28,900 --> 01:47:30,478
当我明年回来时，

1459
01:47:30,478 --> 01:47:33,894
我希望能在那个领域报告更加激动人心的成果。

1460
01:47:33,894 --> 01:47:34,703
谢谢。

1461
01:47:37,002 --> 01:47:38,803
>> 好的，谢谢兰迪。

1462
01:47:38,803 --> 01:47:40,915
我有一个简短的澄清问题。

1463
01:47:40,915 --> 01:47:48,356
如果我错过了，你能说我很抱歉吗？是哪些SIEMs？

1464
01:47:48,356 --> 01:47:49,810
你让我为难了。

1465
01:47:49,810 --> 01:47:54,880
它可能是一个安全信息和事件管理器。

1466
01:47:54,880 --> 01:47:56,246
好的。

1467
01:47:56,246 --> 01:48:02,154
>> 它基本上是一个图形用户界面，允许人们在他们的世界中使用它来寻找

1468
01:48:02,154 --> 01:48:06,362
它基本上是一个图形用户界面，允许人们在他们的世界中使用它来寻找入侵，这个屏幕上的黑盒子作为一个安全信息和事件管理(SIEM)系统。

1469
01:48:06,362 --> 01:48:09,061
我明白了，好的，很酷。

1470
01:48:09,061 --> 01:48:10,399
有什么问题吗？

1471
01:48:14,736 --> 01:48:16,587
那么你预期吗？

1472
01:48:16,587 --> 01:48:20,527
所以你是为特定市场开发这个产品吗？

1473
01:48:20,527 --> 01:48:25,334
我实际上很想了解更多关于安全审查的信息。

1474
01:48:25,334 --> 01:48:30,237
实际上正在发生的情况是什么，但我的问题是，你认为这会扩展到其他领域吗？

1475
01:48:30,237 --> 01:48:35,445
您提到了能源行业，您认为这会

1476
01:48:35,445 --> 01:48:40,536
对其他类别的应用程序进行改变吗？

1477
01:48:40,536 --> 01:48:45,416
对其他类别的应用程序进行改变吗？

1478
01:48:45,416 --> 01:48:51,044
嗯，我认为这就是这种定制运输方法的本质。

1479
01:48:51,044 --> 01:48:56,335
这就是你有了凯西分离出来的针对特定应用的SIEMs。

1480
01:48:56,335 --> 01:49:01,367
这提供了一个相当有限的环境，需要对此进行改变，

1481
01:49:01,367 --> 01:49:03,437
当然是要在空中。

1482
01:49:03,437 --> 01:49:06,208
你真的想要一些内置的应用知识。

1483
01:49:06,208 --> 01:49:09,269
所以这种变化恰到好处，

1484
01:49:09,269 --> 01:49:13,478
我认为这是我们认为它是免费应用程序的方式。

1485
01:49:13,478 --> 01:49:15,487
是的，这是一个很好的回答。

1486
01:49:15,487 --> 01:49:18,910
好的，非常感谢您。

1487
01:49:18,910 --> 01:49:22,799
非常有趣的演讲，请四位演讲者上台。

1488
01:49:22,799 --> 01:49:29,040
想象一下，为你们的演讲响起一阵热烈的掌声，谢谢你们。

1489
01:49:29,040 --> 01:49:33,298
接下来，我将把话筒交回给洛特菲。

1490
01:49:33,298 --> 01:49:35,695
>> 非常感谢你，肯。

1491
01:49:35,695 --> 01:49:38,951
现在是最后一个休息时间。

1492
01:49:38,951 --> 01:49:42,009
我们应该在3点半回来。

1493
01:49:42,009 --> 01:49:44,101
那我们就这样定了。

1494
01:49:44,101 --> 01:49:46,353
你们都在3:30回来。

1495
01:49:46,353 --> 01:49:48,964
谢谢。

