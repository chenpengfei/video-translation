1
00:00:04,044 --> 00:00:10,260
欢迎大家来到名称数据网络社区会议的第二天。

2
00:00:10,260 --> 00:00:15,280
今天的议程从第三场关于路由和转发的会议开始，由来自佛罗里达国际大学的Alex Athanasian主持。

3
00:00:15,280 --> 00:00:21,190
转发部分，由佛罗里达国际大学的Alex Athanasian主持。

4
00:00:21,190 --> 00:00:23,550
亚历克斯，请开始。

5
00:00:23,550 --> 00:00:28,240
当然，当然，在这个环节中，我们将会有三场演讲。

6
00:00:28,240 --> 00:00:31,595
我猜腾已经可以准备幻灯片进行分享了。

7
00:00:31,595 --> 00:00:38,740
所以腾，我认为他获得了计算机科学的硕士和博士学位。

8
00:00:38,740 --> 00:00:42,580
他从亚利桑那大学获得了计算机科学的硕士和博士学位，而今年是非常具有挑战性的一年。

9
00:00:44,400 --> 00:00:49,180
他的研究兴趣集中在MDN，包括协议应用，

10
00:00:49,180 --> 00:00:55,098
部署设计，目前他作为博士后研究员的研究意图。

11
00:00:55,098 --> 00:00:56,310
唐，请。

12
00:00:56,310 --> 00:00:57,000
>> 大家好。

13
00:00:57,000 --> 00:00:58,350
这是滕亮。

14
00:00:58,350 --> 00:01:01,690
我是彭城实验室的博士后研究员。

15
00:01:01,690 --> 00:01:06,111
今天我将介绍我们在前缀粒度问题上的工作。

16
00:01:06,111 --> 00:01:07,734
NDN自适应转发。

17
00:01:11,296 --> 00:01:15,319
所以在当前的IP网络中，外部平面是无状态的，

18
00:01:15,319 --> 00:01:16,870
没有适应性。

19
00:01:16,870 --> 00:01:18,660
所以它很简单，很稳健。

20
00:01:20,080 --> 00:01:23,950
但这有几个缺点。

21
00:01:23,950 --> 00:01:27,250
我将在这里介绍其中之一，即链路故障。

22
00:01:28,270 --> 00:01:31,880
如果在IP网络中发生了链路故障。

23
00:01:31,880 --> 00:01:38,860
假设链路层没有检测到它并且没有通知网络层。

24
00:01:38,860 --> 00:01:43,630
因此网络层依赖摇晃协议来检测它，

25
00:01:43,630 --> 00:01:47,130
因此是模拟的KeepAlive消息。

26
00:01:47,130 --> 00:01:50,420
因此，这条消息可能需要长达数十秒的时间来检测到这一点。

27
00:01:52,370 --> 00:01:58,026
因此，在NDN中，转发平面可以具有适应性，

28
00:01:58,026 --> 00:02:03,640
因此，由于NDN具有兴趣交换并且是有状态的。

29
00:02:03,640 --> 00:02:06,310
因此，我们接收到一个数据包，

30
00:02:06,310 --> 00:02:12,088
你可以了解到那条特定路径上的数据检索度量。

31
00:02:12,088 --> 00:02:19,130
所以在NDN中，下降平面能够更快地检测到链路故障。

32
00:02:20,720 --> 00:02:24,910
这个想法是基于链式提议来安排的。

33
00:02:24,910 --> 00:02:29,700
后来它被应用于一个NFT ASF策略中。

34
00:02:31,580 --> 00:02:36,370
所以总结一下，NDN自适应转发能够观察过去的

35
00:02:36,370 --> 00:02:41,194
不同方的数据检索测量，

36
00:02:41,194 --> 00:02:46,226
他们可以利用它来改进未来兴趣的转发决策。

37
00:02:46,226 --> 00:02:50,347
这是处理流程

38
00:02:50,347 --> 00:02:54,450
NDN自适应转发。

39
00:02:54,450 --> 00:02:59,090
当兴趣包进来时，

40
00:02:59,090 --> 00:03:03,380
它将被记录在PIT表中，即待定兴趣表，并且

41
00:03:03,380 --> 00:03:09,260
当数据返回时，它也会在PIT表中进行查找。

42
00:03:09,260 --> 00:03:16,540
因此，PIT的状态可以帮助形成计划以实现适应性。

43
00:03:18,800 --> 00:03:24,570
那么什么是前缀粒度问题？

44
00:03:24,570 --> 00:03:29,350
NDN自适应转发假设了所谓的兴趣路由局部性。

45
00:03:29,350 --> 00:03:32,770
NDN自适应转发假设了所谓的兴趣路由局部性。

46
00:03:32,770 --> 00:03:37,740
共享较长名称前缀的数据更有可能采取相同的转发路径。

47
00:03:37,740 --> 00:03:40,110
因此，他们可以使用

48
00:03:41,130 --> 00:03:45,185
因此，他们可以使用路径测量来指示未来的兴趣转发。

49
00:03:46,820 --> 00:03:51,678
例如，这里有两个数据包及其名称。

50
00:03:51,678 --> 00:03:54,260
作为ab段1和段2。

51
00:03:54,260 --> 00:03:56,730
它们只是同一个文件的两个部分，

52
00:03:56,730 --> 00:03:59,630
它们很可能会保持在同一位置。

53
00:03:59,630 --> 00:04:06,380
虽然斜线a斜线c段y是另一个不同文件的段落。

54
00:04:06,380 --> 00:04:09,260
所以他们不太可能停留在同一个位置。

55
00:04:10,810 --> 00:04:15,890
那么这里的真正问题是应该使用哪种长度的名称前缀。

56
00:04:15,890 --> 00:04:18,810
记录路径性能测量数据。

57
00:04:18,810 --> 00:04:23,830
所以我们可以看到，当用y来测量时

58
00:04:23,830 --> 00:04:27,020
兴趣数据在全名上进行交换，对吗？

59
00:04:27,020 --> 00:04:30,370
以及他们的测量数据，比如往返时间，

60
00:04:30,370 --> 00:04:33,240
我们应该将一些测量数据放在哪个名称前缀上。

61
00:04:35,320 --> 00:04:40,540
我们在这里所说的真相是，如果我们将其放在一个更长的名称前缀上，

62
00:04:40,540 --> 00:04:43,870
根据这个假设，这意味着我们拥有更好的路由局部性。

63
00:04:45,030 --> 00:04:51,470
然而，你将覆盖的兴趣点越少，因此它将生成一个更大的FIB表。

64
00:04:53,270 --> 00:04:58,254
我们将其定义为前缀粒度问题。

65
00:04:58,254 --> 00:05:01,330
现有解决方案是什么？

66
00:05:01,330 --> 00:05:05,793
现有设计使用静态名称前缀来记录测量数据。

67
00:05:05,793 --> 00:05:14,155
例如，我们感兴趣的是 /edu/ua/cs/people/teng/ndex.html。

68
00:05:14,155 --> 00:05:20,853
当我们得到测量数据时，这个完整的名称将会记录这些测量数据，

69
00:05:20,853 --> 00:05:27,020
我们的前缀，通常是字段名/edu/ua。

70
00:05:27,020 --> 00:05:32,448
我们记录修改和FIB名称，比如RTT，

71
00:05:32,448 --> 00:05:35,841
我们特定的下一跳，以及

72
00:05:35,841 --> 00:05:40,330
然后我们有一个按优先级排列的下一跳列表。

73
00:05:43,328 --> 00:05:49,250
这在处理部分网络故障时已知存在问题。

74
00:05:49,250 --> 00:05:54,080
例如，我们有一个拥有两个消费者的拓扑结构。

75
00:05:54,080 --> 00:05:59,022
连接到一个路由器，R1 另一个路由器 R2，

76
00:05:59,022 --> 00:06:05,220
R1 还连接到一个延迟更长的生产者仓库3，即P3。

77
00:06:06,820 --> 00:06:12,042
然后连接到另一个生产者P1，即服务于a/b。

78
00:06:12,042 --> 00:06:14,609
P2服务于a/c。

79
00:06:14,609 --> 00:06:19,591
在路由协议中，R1汇总已注册的

80
00:06:19,591 --> 00:06:23,937
前缀 /a/b/a/c 到 /a 并且

81
00:06:23,937 --> 00:06:28,930
传播到 R1 并且 P3 也向 R1 注册 /a。

82
00:06:28,930 --> 00:06:34,285
因此，在 R1 上有一个 FIB 分支 /a，它具有一个排名的下一跳。

83
00:06:34,285 --> 00:06:39,653
它是 R2 和 P3，而且 R2 相对于 R3 更优先于 P3。

84
00:06:39,653 --> 00:06:44,511
C1 正在检索位于 /a/b 下的数据。

85
00:06:44,511 --> 00:06:48,860
C1 正在这里进行蓝色流动。

86
00:06:48,860 --> 00:06:55,340
P1 正在从 P2 处检索数据，对于 C2 来说，也是从 P2 处检索数据。

87
00:06:55,340 --> 00:07:02,799
在某些时候，R2 和 P2 之间的链接会出现故障。

88
00:07:02,799 --> 00:07:07,630
因此，我们期望的行为是 R1 可以转发绿色流量到下方路径，直至 P3。

89
00:07:07,630 --> 00:07:12,740
因此，流量会沿着下方路径直达 P3。

90
00:07:12,740 --> 00:07:15,710
因此，由于存在一条路径，它仍然能够工作。

91
00:07:17,110 --> 00:07:24,230
当前在C2和P2之间的P2上的测量值将记录在斜线a上。

92
00:07:24,230 --> 00:07:30,700
那么如果我们将斜线a更新为P3，R2既有C1也有

93
00:07:30,700 --> 00:07:35,580
C2的流量，无论是蓝色流量还是绿色流量，都将被转发到P3。

94
00:07:36,630 --> 00:07:40,920
因此问题在于，即便如此，C1还是会遭受更长路径的问题。

95
00:07:40,920 --> 00:07:42,600
存在一条更短的路径。

96
00:07:43,780 --> 00:07:48,640
但如果我们不更改FIB排名，因为你无法~!@#$%^&*()

97
00:07:48,640 --> 00:07:53,530
即使存在问题并且存在另一条路径，也要检索任何数据。

98
00:07:53,530 --> 00:07:55,730
所以这是现有设计中的一个问题。

99
00:07:57,210 --> 00:08:02,000
在我们模拟这一场景时，也采用了ASF策略。

100
00:08:02,000 --> 00:08:10,304
当您发现在链路故障后C2无法检索数据时，

101
00:08:10,304 --> 00:08:16,205
这是因为流程持续记录着修改。

102
00:08:16,205 --> 00:08:20,737
R1认为R2能够检索数据

103
00:08:20,737 --> 00:08:27,359
R1一直认为R3不能短时间内检索到。

104
00:08:27,359 --> 00:08:33,968
我们提出的解决这一问题的方案或者想法是动态FIB扩展。

105
00:08:33,968 --> 00:08:40,161
因此，如果FIB能将当前的FIB slash a扩展为slash a，

106
00:08:40,161 --> 00:08:46,883
将排名不同的slash c，即优先考虑P3。

107
00:08:49,024 --> 00:08:54,070
绿色流将选择不同的路径并能够检索它。

108
00:08:55,210 --> 00:08:56,490
所以这就解决了这个问题。

109
00:08:57,570 --> 00:09:01,350
我们还将在ndnSIM中模拟这个场景，

110
00:09:01,350 --> 00:09:06,461
我们将假设R1能够找到这个名称并将其扩展为一个正确的名称。

111
00:09:07,680 --> 00:09:14,705
通过这样做，C2能够在链路故障后从P3检索数据。

112
00:09:19,004 --> 00:09:23,190
那么我们如何进行动态FIB扩展呢？

113
00:09:23,190 --> 00:09:26,070
第一个问题是我们什么时候触发它？

114
00:09:26,070 --> 00:09:31,020
所以我们的想法是，当你做出了一个新的

115
00:09:31,020 --> 00:09:36,320
排名下一跳时，你会触发这个FIB的扩展。

116
00:09:36,320 --> 00:09:37,490
那么你如何触发呢？

117
00:09:37,490 --> 00:09:38,480
你是如何进行扩展的？

118
00:09:38,480 --> 00:09:42,655
有不同的策略，例如，你有这个全名，

119
00:09:42,655 --> 00:09:47,120
你有FIB名称，你可以将它扩展到不同的名字组成部分，对吗？

120
00:09:48,320 --> 00:09:54,160
首先，简单直观的想法是从FIB名称开始，

121
00:09:54,160 --> 00:10:00,000
向下展开一级目录，/edu/ua，然后将其添加到/index中。

122
00:10:00,000 --> 00:10:04,010
可能不准确，可能是因为问题的名称更长所以

123
00:10:04,010 --> 00:10:06,350
你一直在做这个。

124
00:10:06,350 --> 00:10:12,200
你也可以采用自下而上的策略，比如从索引开始。

125
00:10:12,200 --> 00:10:17,130
像从紧凑的名称前缀那样，然后你再上升一层，使用 .html。

126
00:10:18,840 --> 00:10:23,810
在论文中，我们还提到了具有多个排名的最短名称前缀。

127
00:10:24,990 --> 00:10:31,390
获取可能找到最优解，但它也有其他开销。

128
00:10:32,700 --> 00:10:35,530
那么接下来的问题是，我们可以有不同的策略，

129
00:10:35,530 --> 00:10:36,760
我们如何评估它们。

130
00:10:38,520 --> 00:10:43,535
在论文中，我们提出了两个指标，即为什么是一系列的名字来评估它们。

132
00:10:48,440 --> 00:10:53,455
你可能会有不同的速度来准确找到名字的粒度。

133
00:10:53,455 --> 00:11:00,900
所插入的名字数量意味着你能有多快找到它，以及

134
00:11:00,900 --> 00:11:07,510
数量越多意味着会有更多的流量受到次优数据包的影响。

135
00:11:07,510 --> 00:11:10,310
那么你就可以有更好的测量结果，然后你会提出异议。

136
00:11:11,670 --> 00:11:15,746
第二个指标是新插入波段的长度。

137
00:11:21,995 --> 00:11:28,999
所以名字越长，当你进行渐隐最长前缀查找时，

138
00:11:28,999 --> 00:11:32,920
它可能会影响本地性能。

139
00:11:35,390 --> 00:11:39,590
我们还提出了动态FIB折叠机制，因为动态FIB可能会影响本地性能。扩展时会发现它可能不会进行最优的扩展，

140
00:11:39,590 --> 00:11:45,730
在扩展时会发现它可能不会进行最优的扩展，

141
00:11:45,730 --> 00:11:51,310
最终得到的交易可以大幅优化。

142
00:11:51,310 --> 00:11:54,340
我们也不希望交易无限扩大。

143
00:11:54,340 --> 00:11:59,758
因此，我们有机制来控制FIB的大小并优化树结构。

144
00:11:59,758 --> 00:12:04,352
最后，我们还优化了NDN自适应转发处理。

145
00:12:04,352 --> 00:12:09,493
当前的设计是因为每个状态都有一个接收，你将进行更新。

146
00:12:09,493 --> 00:12:14,735
因为测量数据会附加到FIB上。

147
00:12:14,735 --> 00:12:18,726
因此，我们在每次接收数据时都会进行一次FIB查找，这是

148
00:12:18,726 --> 00:12:23,186
因此，我们在每次接收数据时都会进行一次FIB查找，这是最长前缀匹配，它也是另一项开销。And we want to optimize this procedure and

149
00:12:23,186 --> 00:12:26,223
我们希望优化这个过程并且

150
00:12:26,223 --> 00:12:30,580
我们通过将测量数据与PITS条目保持关联来实现这一点。

151
00:12:31,980 --> 00:12:36,230
因此，大多数遵循最佳路径的流量，测量数据将会被附加到

152
00:12:36,230 --> 00:12:42,110
PIT条目和这个单一测量并不影响路由排名。

153
00:12:42,110 --> 00:12:46,270
因此，当PIT条目被移除时，它们也将被删除。

154
00:12:46,270 --> 00:12:50,920
只有当对多个下一跳进行测量并且

155
00:12:50,920 --> 00:12:55,250
制定了一个新的PIT生命周期排名。

156
00:12:55,250 --> 00:12:59,350
这个排名将会更新FIB。

157
00:12:59,350 --> 00:13:03,280
所以大多数更新，大多数测量数据将会被填写完整。

158
00:13:03,280 --> 00:13:04,930
所以FIB更新是有限的。

159
00:13:06,850 --> 00:13:10,760
因此，总结将定义前缀粒度问题。

160
00:13:10,760 --> 00:13:14,687
因此，关键是要平衡兴趣路由局部性和

161
00:13:14,687 --> 00:13:15,220
的大小。

162
00:13:15,220 --> 00:13:20,920
我们的核心思想是动态扩展FIB

163
00:13:20,920 --> 00:13:25,060
我们将对FIB名称进行细分，并且还会执行动态FIB折叠。

164
00:13:26,730 --> 00:13:31,460
我们在数据处理中优化了测量管理。

165
00:13:31,460 --> 00:13:33,320
为了减少FIB查找。

166
00:13:35,220 --> 00:13:40,550
如果您有更多问题，可以在这篇2020年ICN的工作细节中找到更多信息。

167
00:13:40,550 --> 00:13:43,430
谢谢。

168
00:13:43,430 --> 00:13:50,910
下一个报告是m-ASF，报告人是穆克塔迪尔·乔杜里，他是一名研究生研究员。

169
00:13:50,910 --> 00:13:54,630
在孟菲斯大学计算机科学系。

170
00:13:54,630 --> 00:13:57,680
他的研究重点是信息中心。

171
00:13:57,680 --> 00:14:01,190
他从研究生开始就一直致力于网络研究，并且

172
00:14:01,190 --> 00:14:05,480
他一直积极参与NDN中的开源SDN项目。

173
00:14:05,480 --> 00:14:07,412
一直担任开发者、评审员，

174
00:14:07,412 --> 00:14:11,130
一直担任开发者、评审员，负责报告各种与引擎相关项目的问题和漏洞。His own research has focused on various topics related to vehicular ad hoc networks.

175
00:14:11,130 --> 00:14:15,700
他自己的研究主要集中在与车辆自组织网络相关的各种课题上。

176
00:14:15,700 --> 00:14:20,710
他的研究还涉及到基于命名数据网络(NDN)的网络通信以及无线和增益网络中的路由与转发。

177
00:14:20,710 --> 00:14:21,780
好的，是的。

178
00:14:21,780 --> 00:14:24,280
大家好，我叫穆克塔迪尔·乔杜里。

179
00:14:24,280 --> 00:14:26,700
我是孟菲斯大学的一名博士研究生。

180
00:14:26,700 --> 00:14:29,207
今天我将会讨论m-ASF，

181
00:14:29,207 --> 00:14:34,074
一种基于自适应SRTT的移动环境转发策略。

182
00:14:34,074 --> 00:14:36,870
无线网络无处不在。

183
00:14:36,870 --> 00:14:41,020
而且如今大多数的终端节点都是移动和无线设备。

184
00:14:41,020 --> 00:14:46,481
所以NDN相较于传统的TCP/IP协议具有一些独特的优势。

185
00:14:46,481 --> 00:14:50,720
无线和移动通信。

186
00:14:50,720 --> 00:14:55,100
例如，它具有基于名称的转发、普遍存在的内部缓存等特性，

187
00:14:55,100 --> 00:14:58,880
它还提供了网络层的安全性。

188
00:14:58,880 --> 00:15:03,243
项目的目标是为NDN无线网络开发一种转发策略。

189
00:15:03,243 --> 00:15:07,745
在无线网络中，可以使用最少的或无需路由信息，做出智能的转发决策。

190
00:15:07,745 --> 00:15:09,280
无需路由信息。

191
00:15:11,190 --> 00:15:16,630
这里有一些关于NDN转发管道的简要信息。

192
00:15:16,630 --> 00:15:23,700
这里我们有NFD的主要组成部分，即NDN的转发演示。

193
00:15:23,700 --> 00:15:27,340
所以，这里我们有像PIT这样的东西，它记录了外发的兴趣。

194
00:15:27,340 --> 00:15:33,160
这里是内容存储，检索到的数据会被缓存在这里。

195
00:15:33,160 --> 00:15:36,770
这里我们有策略模块，它根据路由和数据平面的信息来做出转发决策。

196
00:15:36,770 --> 00:15:39,200
来自路由和数据平面的信息。

197
00:15:39,200 --> 00:15:46,220
在策略中使用FIB（转发信息基础设施），它将一个前缀映射到一系列接口上。

198
00:15:46,220 --> 00:15:51,130
在NFT中我们有不同的策略，其中之一是

199
00:15:51,130 --> 00:15:59,452
自适应平滑往返时间基础上的转发策略，简称ASF。

200
00:15:59,452 --> 00:16:04,575
ASF定期探测接口

201
00:16:04,575 --> 00:16:12,430
ASF定期探测接口以获取每个接口的SRTT值，

202
00:16:12,430 --> 00:16:17,849
然后它使用这些SRTT值来对转发过程中的各个阶段进行排名。

203
00:16:19,880 --> 00:16:24,200
在设计移动自适应选择转发（m-ASF）时，我们首先考察了其局限性

204
00:16:24,200 --> 00:16:28,740
在无线移动环境中ASF策略的一个限制是。

205
00:16:28,740 --> 00:16:32,530
不同种类的故障。

206
00:16:32,530 --> 00:16:33,770
不同种类的故障。

207
00:16:33,770 --> 00:16:37,370
例如，如果两个面孔都超时，系统会对它们都进行相同的处理。

208
00:16:38,690 --> 00:16:43,590
另一个限制是，在进行周期性探测时，

209
00:16:43,590 --> 00:16:45,910
它一次只探测一个面。

210
00:16:45,910 --> 00:16:51,490
所以，ASF可能需要很长时间才能发现一条新路径。

211
00:16:52,600 --> 00:16:56,960
所以，m-ASF基本上是ASF策略的重新设计。

212
00:16:56,960 --> 00:17:00,420
因此，它在移动无线网络中运行良好。

213
00:17:00,420 --> 00:17:07,350
因此，它可以通过对面部进行细粒度排名来实现这一点，

214
00:17:07,350 --> 00:17:11,000
探测多个面孔，并且

215
00:17:11,000 --> 00:17:14,210
探索必要时的替代面孔。

216
00:17:14,210 --> 00:17:17,140
通过使用振荡预防措施，

217
00:17:17,140 --> 00:17:20,940
我将在后面的幻灯片中逐一讨论这些话题。

218
00:17:20,940 --> 00:17:27,780
首先我们将讨论m-ASF的细粒度人脸排名。

219
00:17:27,780 --> 00:17:31,520
在移动场景中，面部识别可能因为多种原因而失败。

220
00:17:33,020 --> 00:17:37,280
And emissive does this fine grained ranking of faces according to their 在移动场景中，面部识别可能因为多种原因而失败。statuses, as on the left hand side, we can see that on the left hand side

发射性能够根据它们的状态进行面部的细粒度排名，正如我们在左手边可以看到的，在左手边

221
00:17:37,280 --> 00:17:43,180
状态，正如我们在左手边可以看到的，在左手边

222
00:17:43,180 --> 00:17:49,600
我们可以看到在转发过程中，前缀P的面孔排名。

223
00:17:50,840 --> 00:17:54,630
在右手边我们可以看到一个面孔排名的例子。

224
00:17:54,630 --> 00:17:56,550
在探查过程中使用了一个前缀P。

225
00:17:56,550 --> 00:18:02,590
在我们进行粮食转运时，我们优先考虑

226
00:18:02,590 --> 00:18:07,530
对于我们已经了解信息的那些面孔，这意味着对于

227
00:18:07,530 --> 00:18:11,330
我们已经知道的确定性测量，以及在进行探测时，

228
00:18:11,330 --> 00:18:16,040
我们优先考虑那个我们一无所知的面。

229
00:18:16,040 --> 00:18:21,040
所以，对于哪个m-ASF我们没有任何测量信息。

230
00:18:21,040 --> 00:18:24,220
如果我们看一下第三组和第四组，

231
00:18:24,220 --> 00:18:29,490
尽管两者都是超时的面孔，但第三组有

232
00:18:29,490 --> 00:18:33,980
尽管两者都是超时的面孔，但第三组有一个特定的价值，这意味着你

233
00:18:33,980 --> 00:18:39,510
它以前能正常工作，但由于某些原因，现在不行了。

234
00:18:40,670 --> 00:18:45,790
所以，这些是第三组的面孔，将会被优先考虑。

235
00:18:45,790 --> 00:18:50,110
在转发过程中要检查第四组的面孔。

236
00:18:50,110 --> 00:18:55,290
如果两张面孔拥有完全相同的属性，

237
00:18:55,290 --> 00:18:59,260
那么我们就使用面部识别来打破两张面孔之间的平局。

238
00:19:01,910 --> 00:19:06,077
在这里，我谈到了探索模式。

239
00:19:10,202 --> 00:19:15,290
探讨m-ASF策略的探索模式。

240
00:19:16,470 --> 00:19:20,880
在移动环境中，面孔频繁地出现和消失。

241
00:19:20,880 --> 00:19:26,270
因此，我们看到了一种m-ASF策略

242
00:19:26,270 --> 00:19:30,660
需要在主工作面无法工作时迅速发现新的工作面。

243
00:19:32,140 --> 00:19:36,600
m-ASF最初在以下情况下进入探索模式：

244
00:19:36,600 --> 00:19:40,601
它没有任何面部信息。

245
00:19:40,601 --> 00:19:46,860
例如，这就是我们的货代正在运行的情况。

246
00:19:46,860 --> 00:19:49,540
我们的m-ASF策略正在运行中。

247
00:19:49,540 --> 00:19:52,290
这就是面部状态的种类。

248
00:19:52,290 --> 00:19:54,160
所以这就是所有的面部状态种类。

249
00:19:54,160 --> 00:19:56,580
它涉及到前缀和面部。

250
00:19:56,580 --> 00:19:59,800
他对状态一无所知。

251
00:19:59,800 --> 00:20:04,310
所以，所有面孔就像是没有任何关于面孔的信息。

252
00:20:04,310 --> 00:20:07,178
所以，所有面孔就像是没有任何关于面孔的信息。

253
00:20:07,178 --> 00:20:10,571
~!@#$%^&*()

254
00:20:10,571 --> 00:20:15,220
他在没有任何关于各个面的信息时进行探索。

255
00:20:15,220 --> 00:20:19,630
所以，这是最初阶段，当一个失误对任何事情一无所知时

256
00:20:19,630 --> 00:20:23,775
这些面孔，它唯一知道的就是关于前缀和面孔。

257
00:20:24,870 --> 00:20:26,200
这些面孔。

258
00:20:26,200 --> 00:20:30,340
所以，当它给予它们利息时，发射端提供了一个利息用于

259
00:20:30,340 --> 00:20:35,330
一个前缀下的斜杠A，然后它将转发利息

260
00:20:35,330 --> 00:20:39,020
将利息转发给它所知道的所有接口，因此它将会散播出去。

261
00:20:39,020 --> 00:20:44,370
将利息像对待一号、二号和三号接口一样平等对待，然后它将会这样做。

262
00:20:44,370 --> 00:20:47,300
然后它首先从二号接口那里获取数据。

263
00:20:47,300 --> 00:20:49,640
然后它从三号接口那里取回数据。

264
00:20:49,640 --> 00:20:55,745
然后它将更新这些面孔每一个的不确定性值。

265
00:20:55,745 --> 00:21:00,335
这是针对相同前缀的面孔的新排名。

266
00:21:00,335 --> 00:21:04,955
对于相同前缀的兴趣，这个排名将用于下一次。

267
00:21:05,975 --> 00:21:08,915
对于相同前缀的兴趣，这个排名将用于下一次。当排名最高的选项不起作用时，探索就会发生。

268
00:21:08,915 --> 00:21:11,505
探索发生在排名最高的选项不起作用的时候。

269
00:21:11,505 --> 00:21:13,950
例如，如果第二个选项不起作用，那么在那种情况下，

270
00:21:13,950 --> 00:21:20,770
m-ASF将会将利息转发至顶端面。

271
00:21:20,770 --> 00:21:23,560
m-ASF将会将利息转发至面部。

272
00:21:23,560 --> 00:21:26,600
这已经很长时间没有尝试过了。

273
00:21:26,600 --> 00:21:30,070
这里我们将讨论m-ASF的探测行为。

274
00:21:30,070 --> 00:21:32,210
探测由传入的兴趣触发。

275
00:21:32,210 --> 00:21:37,820
如果自上次探测以来已超过T秒钟，

276
00:21:37,820 --> 00:21:42,780
通过更改这个探测间隔，我们可以使探测的频率更频繁或更少。

277
00:21:42,780 --> 00:21:48,900
通过更改这个探测间隔，我们可以使探测的频率更频繁或更少。

278
00:21:48,900 --> 00:21:53,060
在进行探测时，m-ASF会探测一系列面。

279
00:21:54,680 --> 00:21:59,390
所以，它会探测所有没有测量信息的表面。

280
00:21:59,390 --> 00:22:03,300
它还会探测最高的那个面。

281
00:22:03,300 --> 00:22:07,900
根据我在上一张幻灯片中提到的探测排名进行排名。

282
00:22:11,200 --> 00:22:14,090
那么，让我们接着上一个例子继续。

283
00:22:14,090 --> 00:22:19,560
那么，这是目前四个面孔的排名，为四前缀斜杠A。

284
00:22:19,560 --> 00:22:23,260
这里我们可以看到一个新面孔出现了，是面孔编号四。

285
00:22:23,260 --> 00:22:28,875
所以，当一个兴趣项属于这个前缀/A时，那么m-ASF就是

286
00:22:28,875 --> 00:22:35,290
将兴趣转发到排名最高的接口，即接口编号为二。

287
00:22:38,110 --> 00:22:40,650
还将发送探针

288
00:22:40,650 --> 00:22:45,170
~!@#$%^&*()

289
00:22:45,170 --> 00:22:50,370
所以它也想尽快地了解新面孔。

290
00:22:50,370 --> 00:22:54,970
as quickly as possible. This is the mechanism for discovering the new faces by sending a probe.

291
00:22:54,970 --> 00:22:57,970
这是通过发送探测器来发现新面孔的机制。

292
00:22:59,370 --> 00:23:05,120
然后在那之后，它将从第二阶段和第四阶段获取数据。

293
00:23:05,120 --> 00:23:09,330
这将是面部新排名以及它们更新后的SRTT值，所以

294
00:23:09,330 --> 00:23:13,940
这个新排名将用于推进下一个利益。

295
00:23:15,590 --> 00:23:19,670
我们还集成了振荡预防机制以防止

296
00:23:21,130 --> 00:23:23,410
过早的面部切换。

297
00:23:23,410 --> 00:23:24,550
如果你的面部在工作一段时间后，我们就会将其设为主要面孔。

298
00:23:24,550 --> 00:23:27,140
在达到一定的时间阈值后，我们会将其设置为主要面孔。

299
00:23:28,260 --> 00:23:32,050
看一下电梯。

300
00:23:33,550 --> 00:23:39,050
在这个例子中，这是目前面部排名的情况。

301
00:23:39,050 --> 00:23:43,430
我们有，所以面部编号二是排名第一的。

302
00:23:43,430 --> 00:23:47,192
我们有，所以面部编号二是排名第一的。所以，当一个新的兴趣出现时，至少假设我们已经使用面部二号达到了阈值时间。

303
00:23:47,192 --> 00:23:51,412
至少假设我们已经使用面部二号达到了阈值时间。

304
00:23:51,412 --> 00:23:54,782
那么，m-ASF将会使面部二号成为主要面孔。

305
00:23:54,782 --> 00:24:00,950
在这里我们可以看到，目前排名第一的面孔也是面部二号。

306
00:24:00,950 --> 00:24:04,411
所以无国界医生组织将会将这份兴趣发送给面部二号。

307
00:24:04,411 --> 00:24:08,840
如果出于某种原因面部二号无法工作，消费者将会

308
00:24:08,840 --> 00:24:12,710
得到一个超时，然后它将重新传送兴趣。

309
00:24:13,810 --> 00:24:17,830
它将重新传送兴趣，

310
00:24:17,830 --> 00:24:21,838
这是这里面孔的新排名。

311
00:24:21,838 --> 00:24:25,973
这张脸二会因为刚刚被暂停而掉到最底部，

312
00:24:25,973 --> 00:24:27,856
所以它的排名会下降。

313
00:24:27,856 --> 00:24:32,620
所以现在面孔四将成为排名最高的面孔。

314
00:24:32,620 --> 00:24:36,550
所以我们可以看到，我们目前的主要面孔仍然是面孔二，但是

315
00:24:36,550 --> 00:24:39,790
所以我们目前排名最高的面孔是面孔四。

316
00:24:39,790 --> 00:24:42,960
因此，无国界医生组织将要做的是，它将要发送利息

317
00:24:42,960 --> 00:24:44,073
给他们俩。

318
00:24:44,073 --> 00:24:48,515
所以如果一个面孔刚才还在工作，我们就不想快速切换到那个面孔。

319
00:24:48,515 --> 00:24:53,236
所以在我们永久切换到一个面孔之前，

320
00:24:53,236 --> 00:24:58,592
我们想要确保那张脸是稳定的，

321
00:24:58,592 --> 00:25:03,200
只有那样我们才会将那张脸定为主要面孔。

322
00:25:03,200 --> 00:25:05,660
例如，如果面孔四工作了

323
00:25:05,660 --> 00:25:08,690
只有在这个临界时间量之后，我们才将其作为主要面孔。

324
00:25:10,170 --> 00:25:14,590
所以无论我谈到了什么，我们都实施了它并且

325
00:25:14,590 --> 00:25:19,128
我们使用这个简单的拓扑结构进行了一些初步实验。

326
00:25:19,128 --> 00:25:26,558
我们在这里没有进行任何路由操作，所以这些链接的成本都是一。

327
00:25:26,558 --> 00:25:32,940
这是第一级接入点，并且

328
00:25:32,940 --> 00:25:37,470
这是第二级接入点，我们有一个消费者和两个生产者。

329
00:25:37,470 --> 00:25:42,070
那么绿色的是消费者，它将每秒发送一次兴趣请求，以及

330
00:25:42,070 --> 00:25:46,890
紫色的是生产者，它将提供数据。

331
00:25:48,070 --> 00:25:53,498
我们想要在这里刺激生产者流动性的场景。

332
00:25:53,498 --> 00:25:56,355
所以每当节点四处于运行状态时，

333
00:25:56,355 --> 00:26:01,610
节点7将会下线，所以它们会像这样交替改变它们的状态。

334
00:26:01,610 --> 00:26:07,390
所以每当节点4离线时，节点7就会在线，反之亦然。

335
00:26:08,770 --> 00:26:11,820
所以我们想通过类似的事情来了解这一点。

336
00:26:11,820 --> 00:26:16,390
通过在这种情况下进行实验，我们想要看看SF需要多长时间才能以及MSF在主节点出现问题时找到新的路径。

337
00:26:16,390 --> 00:26:20,440
通过实验，我们想要观察在主节点出现问题时，MSF需要多长时间来找到新的路径。

338
00:26:20,440 --> 00:26:27,220
例如，当这个接入点，也就是将要运行MSF的地方，正在使用这个

339
00:26:29,590 --> 00:26:34,490
接入点达到生产者四所需的时间。

340
00:26:34,490 --> 00:26:39,419
When this face goes down, it takes a certain amount of time for the strategy running in this access point to discover that, okay, there is another face along this path.

341
00:26:39,419 --> 00:26:44,596
访问点发现，好的，这条路径上还有另一个接口。

342
00:26:44,596 --> 00:26:51,591
但我们想要看到这个，所以我们在这个NDNSim中运行了实验，

343
00:26:51,591 --> 00:26:58,371
所有接入点都在运行ASF m-ASF和泛洪协议。

344
00:26:58,371 --> 00:27:02,310
我们在其他节点上运行了BestRoute。

345
00:27:02,310 --> 00:27:05,700
我们使用了两个探测间隔，分别是两秒和四秒。

346
00:27:05,700 --> 00:27:09,670
我们将实验运行了60秒，并且进行了10次重复。

347
00:27:09,670 --> 00:27:15,620
这里是十次运行的中位数结果。

348
00:27:15,620 --> 00:27:20,310
在这里，我们可以看到探测间隔为四秒时的结果。

349
00:27:20,310 --> 00:27:22,987
当探测间隔为两秒时。

350
00:27:22,987 --> 00:27:27,170
在这里我们可以看到，m-ASF的兴趣计数更高，以及

351
00:27:27,170 --> 00:27:30,760
以及整体更高的协议开销。

352
00:27:30,760 --> 00:27:34,476
正是因为m-ASF采取了这种积极的探测手段，所以

353
00:27:34,476 --> 00:27:38,610
这就是为什么它比ASF策略有更高的利息次数。

354
00:27:38,610 --> 00:27:43,670
但是以这种更高的利息次数为代价，

355
00:27:43,670 --> 00:27:47,771
它可以满足很多利益，所以

356
00:27:47,771 --> 00:27:54,493
m-ASF能够满足93%的利益。

357
00:27:54,493 --> 00:27:59,675
对于ASF来说，只有63%，因为对ASF而言，每当一个主要的面孔

358
00:27:59,675 --> 00:28:05,340
它下降时，ASF需要很长时间来找到正在工作的面孔。

359
00:28:05,340 --> 00:28:07,880
这也是为什么它有很多超时的关注。

360
00:28:07,880 --> 00:28:12,580
我们也可以在这个探测间隔为2的情况下看到类似的结果。

361
00:28:12,580 --> 00:28:16,910
所以当探测间隔为2时，探测会更加频繁。

362
00:28:16,910 --> 00:28:21,297
所以在那种情况下，ASF的表现比之前的要好一点，

363
00:28:21,297 --> 00:28:23,338
但它仍然低于m-ASF。

364
00:28:25,089 --> 00:28:30,063
好的，总之，这是我们观察到的，ASF是

365
00:28:30,063 --> 00:28:33,990
不适用于不稳定和短暂的连接。

366
00:28:33,990 --> 00:28:38,410
一旦一个工作面关闭，找到另一个工作面需要很长时间。

367
00:28:38,410 --> 00:28:42,124
m-ASF在这种情况下显示出了一些有希望的结果。

368
00:28:42,124 --> 00:28:49,922
这是我们正在继续进行的待办事项清单。

369
00:28:49,922 --> 00:28:53,680
我们想要进行实验，以模拟动态生成新面孔的场景。

370
00:28:53,680 --> 00:28:57,790
所以当我们进行实验时，

371
00:28:57,790 --> 00:29:02,586
我们想要动态地创建面孔。

372
00:29:02,586 --> 00:29:08,130
而m-ASF具有这一特性，它可以探测未被探测的面孔。

373
00:29:08,130 --> 00:29:12,861
因此，在这种情况下，这一特性将会非常有用。

374
00:29:12,861 --> 00:29:17,803
而且由于行业不支持

375
00:29:17,803 --> 00:29:21,853
编写这种情景剧本。

376
00:29:21,853 --> 00:29:26,174
我们正在修复minindn-wifi以支持这一功能。

377
00:29:26,174 --> 00:29:29,290
我们正在修复minindn-wifi以支持这一功能。

378
00:29:30,380 --> 00:29:31,850
我们还想进行实验，

379
00:29:31,850 --> 00:29:35,220
我们还想进行实验，以测试振荡防止机制。

380
00:29:35,220 --> 00:29:38,280
最终我们希望将代码与ASF代码库匹配。

381
00:29:38,280 --> 00:29:38,780
谢谢。

382
00:29:40,230 --> 00:29:44,018
好的，非常感谢，我认为我们没有那么多时间来

383
00:29:44,018 --> 00:29:44,888
质疑。

384
00:29:44,888 --> 00:29:48,896
Technology, Advanced Network Technologies division.

385
00:29:48,896 --> 00:29:52,186
技术，先进网络技术部门。

386
00:29:52,186 --> 00:29:54,013
他是一名核心开发人员，技术，先进网络技术部门。自2013年以来一直在开发NDN网络转发技术。

387
00:29:54,013 --> 00:29:58,338
自2013年以来一直在开发NDN网络转发技术。

388
00:29:58,338 --> 00:30:00,309
Since 2013, we have been developing NDN network forwarding technology. >> Hi, my name is Junxiao Shi, today I'm presenting on the NTP DK and...

389
00:30:00,309 --> 00:30:04,230
>> 大家好，我是史俊霄，今天我要介绍的是NTP DK以及...

390
00:30:04,230 --> 00:30:08,304
Dr转发在普通硬件上以每秒100吉比特的速度进行。

391
00:30:14,243 --> 00:30:17,660
NDN-DPDK是一个高速NDN转发器。

392
00:30:17,660 --> 00:30:22,510
我们的性能目标是在普通硬件上实现线速。

393
00:30:22,510 --> 00:30:25,360
我们正在通过两条途径来实现这一目标。

394
00:30:25,360 --> 00:30:28,730
首先，我们想采用更好的算法和

395
00:30:28,730 --> 00:30:32,540
在过去两年中介绍的数据结构。

396
00:30:32,540 --> 00:30:38,110
我们在FIB中采用了两阶段最长前缀匹配算法。

397
00:30:38,110 --> 00:30:39,952
我们还将PIT和~!@#$%^&*()

398
00:30:39,952 --> 00:30:45,110
我们将CS合并到一个名为PIT-CS Composite Table的单一哈希表中。

399
00:30:45,110 --> 00:30:49,560
第二种方法是减少库和内核中的开销。

400
00:30:49,560 --> 00:30:54,250
在这一方面，我们使用数据平面开发套件，也就是DPDK。

401
00:30:54,250 --> 00:30:58,894
它为我们提供了一个多线程架构以及高效的

402
00:30:58,894 --> 00:31:01,960
它使用巨页内存进行内存分配。

403
00:31:01,960 --> 00:31:05,300
它还使用了空间以太网适配器驱动程序。

404
00:31:08,630 --> 00:31:13,080
这是NDN-DPDK转发器的架构图。

405
00:31:13,080 --> 00:31:18,810
它具有问题框是一个线程，它们分为三个阶段，

406
00:31:18,810 --> 00:31:21,870
输入阶段、转发阶段和输出阶段。

407
00:31:23,470 --> 00:31:27,136
数据包从以太网适配器在输入阶段被接收。

408
00:31:27,136 --> 00:31:32,044
数据包在输入线程中被解码，然后分发至一个

409
00:31:32,044 --> 00:31:36,320
的转发线程，根据它们的名称。

410
00:31:36,320 --> 00:31:40,672
转发线程具有通常的PIT+CS和FIB，

411
00:31:40,672 --> 00:31:43,490
以及转发策略。

412
00:31:43,490 --> 00:31:46,930
然后数据包在输出线程上发送出去。

413
00:31:46,930 --> 00:31:50,345
>> 自去年以来，我们改进了数据包解码器和

414
00:31:50,345 --> 00:31:53,320
我们在输入线程中改善了数据包重组器。

415
00:31:53,320 --> 00:31:56,880
我们重构了FIB以更好地支持转发提示。

416
00:31:56,880 --> 00:31:59,910
我们在转发线程中添加了一些CoDel队列，

417
00:31:59,910 --> 00:32:01,690
我稍后会详细描述。

418
00:32:01,690 --> 00:32:06,060
我们还扩展了前向软件的平台支持。

419
00:32:07,790 --> 00:32:13,230
所以关于编解码器，Oculus CoDel 是一种主动队列管理技术。

420
00:32:13,230 --> 00:32:17,600
通常它被用在出口侧，因为链路带宽是

421
00:32:17,600 --> 00:32:22,380
通常它被用在出口侧，因为链路带宽是瓶颈，但对于Andy和dpdk，我们添加了一个CoDeL

422
00:32:22,380 --> 00:32:27,120
通常它被用在转发线程的入口侧，因为我们最初的基准测试

423
00:32:27,120 --> 00:32:32,050
表明瓶颈是否在前向插入处，而不是链路带宽。

424
00:32:32,050 --> 00:32:36,868
我们为每种数据包类型分配一个单独的队列，然后对数据包进行优先级排序。

425
00:32:36,868 --> 00:32:41,608
因为丢弃数据包浪费了带宽，对于兴趣来说是过度的，

426
00:32:41,608 --> 00:32:46,356
浪费了服务器CPU资源，这些资源已经花在处理兴趣上了。

427
00:32:47,820 --> 00:32:52,388
我们实现了通过解码失去这一动力循环会话。

428
00:32:52,388 --> 00:32:55,870
我们在每个循环中填充了感兴趣的Zen数据数量。

429
00:32:56,970 --> 00:33:00,490
除了CODEL之外，我们还增加了类似于立方体的功能。

430
00:33:00,490 --> 00:33:03,920
交通生成器中的条件控制算法。

431
00:33:03,920 --> 00:33:08,520
那么如果消费者对插入的拥堵标记做出反应

432
00:33:08,520 --> 00:33:09,860
通过CODEL提示。

433
00:33:11,120 --> 00:33:15,550
它还会重新传输基础上的重新传输，不满足利益的需求。

434
00:33:15,550 --> 00:33:23,690
我们在基准测试中使用了假设的codel算法和cubicle。

435
00:33:23,690 --> 00:33:27,190
那么接下来我将展示一些基准测试结果。

436
00:33:27,190 --> 00:33:30,740
我们使用这个简单的三节点拓扑结构进行了基准测试，

437
00:33:31,810 --> 00:33:37,310
生产者和消费者通过转发器相互获取数据。

438
00:33:37,310 --> 00:33:41,010
生产者和他们通过转发器相互获取数据。

439
00:33:42,030 --> 00:33:46,130
转发器机器必须进入Cascadilla CPU并且

440
00:33:46,130 --> 00:33:51,319
多个Mellanox ConnectX5 100吉以太网适配器。

441
00:33:52,920 --> 00:33:57,450
我们的大新闻是我们达到了每秒100吉比特的速度。

442
00:33:57,450 --> 00:34:01,400
为了得到这个数字，我们测量了聚合数据转发速率

443
00:34:01,400 --> 00:34:02,710
来自消费者。

444
00:34:02,710 --> 00:34:08,400
这个指标仅计算数据包，不包括重传。

445
00:34:08,400 --> 00:34:11,160
然后我们将其乘以有效载荷的大小。

446
00:34:11,160 --> 00:34:13,560
有效载荷大小仅指数据有效载荷。

447
00:34:13,560 --> 00:34:18,993
它不包含带有转发的那些签名的名称。

448
00:34:18,993 --> 00:34:24,446
我们的线程可以达到每秒高达108吉字节的聚合吞吐量。

449
00:34:27,071 --> 00:34:30,600
所以我们开始改变了一些转发线程。

450
00:34:30,600 --> 00:34:34,890
因此我们的预期是，如果我们有更多的失败，相反我们应该获得更高的

451
00:34:34,890 --> 00:34:40,000
所以结果显示，如果我们有1，

452
00:34:40,000 --> 00:34:44,560
所以结果显示，如果我们有2或4个线程，数据转发率会呈线性增长，但是当我们有超过8个转发线程时，所以

453
00:34:44,560 --> 00:34:47,540
当我们有超过8个转发线程时，所以

454
00:34:47,540 --> 00:34:50,920
数据转发率在8个转发线程时达到平台期。

455
00:34:50,920 --> 00:34:52,990
性能不再提升。

456
00:34:52,990 --> 00:34:58,400
我们的分析表明，瓶颈可能存在于输入线程中，应该是在输入线程中。

457
00:34:58,400 --> 00:34:58,990
当前或

458
00:34:58,990 --> 00:35:04,660
在我们未来的工作中，前馈架构只允许每个面直接输入一个信号。

459
00:35:04,660 --> 00:35:11,100
我们还测量了非本地内存访问的影响。

460
00:35:11,100 --> 00:35:16,560
正如我之前提到的，我们银行的前置机有两个CPU。

461
00:35:16,560 --> 00:35:20,480
在现代服务器架构中，CPU以及一些内存和~!@#$%^&*()

462
00:35:20,480 --> 00:35:25,620
PCI设备，例如以太网适配器属于我的插槽。

463
00:35:25,620 --> 00:35:28,540
我们甚至可以同时拥有两者

464
00:35:28,540 --> 00:35:32,970
我们可以将这些适配器安装在机器的同一侧，相同编号的插座上。

465
00:35:32,970 --> 00:35:35,700
所以流量只会转移到另一个插座上。

466
00:35:35,700 --> 00:35:38,870
或者我们可以将它们安排在不同的数字插座上，

467
00:35:38,870 --> 00:35:42,680
所有的流量可能需要跨越数字插座的边界。

468
00:35:42,680 --> 00:35:47,010
跨越数字插座边界会导致更高的内存访问延迟。

469
00:35:47,010 --> 00:35:52,140
我们的基准测试表明，如果流量调度者需要跨越新的masahito边界，~!@#$%^&*()

470
00:35:52,140 --> 00:35:55,970
如果流量调度者需要跨越新的masahito边界，~!@#$%^&*(), 数据转发速率将会降低多达20%。因此，我们的主要功能是硬件加速。

471
00:35:58,520 --> 00:36:01,645
因此，我们的主要功能是硬件加速。

472
00:36:01,645 --> 00:36:04,965
我们的目标是消除输入线程的瓶颈。

473
00:36:04,965 --> 00:36:09,075
但在我描述硬件之前，让我先介绍输入线程的工作原理。

474
00:36:09,075 --> 00:36:10,745
显然有效。

475
00:36:10,745 --> 00:36:15,160
因此，输入线程将接收数据包，我们接收以太网帧，帧或

476
00:36:15,160 --> 00:36:18,980
网络接口硬件ID已解码数据包。

477
00:36:18,980 --> 00:36:24,770
如果数据包是DLP片段，将根据需要进行重组。

478
00:36:24,770 --> 00:36:28,140
如果第三层的数据包类型是它所需要的，则会根据情况发送。

479
00:36:28,140 --> 00:36:30,880
兴趣是调度器所关心的内容。

480
00:36:30,880 --> 00:36:35,400
通过名称前缀来计算哈希值。

481
00:36:35,400 --> 00:36:40,270
然后查找这个补丁表中的 MDT 条目所指示的名称。

482
00:36:40,270 --> 00:36:43,310
哪个前向准备好在数据包中显示处理过程。

483
00:36:43,310 --> 00:36:51,080
如果数据包是数据或necco包是为了正确性，那么数据必须是

484
00:36:51,080 --> 00:36:56,200
被派遣到线程中的相同点，数据处理与之对应的兴趣。

485
00:36:56,200 --> 00:37:01,040
为了实现这一点，我们有一个跳跃点对跳跃点的Hydra代码，这是一个PID令牌。

486
00:37:01,040 --> 00:37:05,770
每个数据包都携带了Pitaka，而这个选项将返回相同的PID令牌。

487
00:37:05,770 --> 00:37:09,810
~!@#$%^&*()

488
00:37:09,810 --> 00:37:13,430
线程ID在PE令牌中用于确定调度的目的地。

489
00:37:14,560 --> 00:37:18,890
硬件解决方案的目标是实现

490
00:37:18,890 --> 00:37:23,670
大部分输入在硬件中读取，以便硬件可以分派移动。

491
00:37:23,670 --> 00:37:26,520
大部分数据包直接发送给转发线程。

492
00:37:28,160 --> 00:37:31,870
在硬件中存在着现代的

493
00:37:31,870 --> 00:37:36,020
以太网适配器支持一种称为接收端扩展的功能。

494
00:37:36,020 --> 00:37:41,060
以太网适配器有多个接收队列。

495
00:37:41,060 --> 00:37:43,870
对于每个队列，我们可以配置哪个进程，

496
00:37:43,870 --> 00:37:48,650
可以处理在此队列上接收到的数据包的哪个线程。

497
00:37:48,650 --> 00:37:51,330
我们还可以设置一个内存池，

498
00:37:51,330 --> 00:37:55,970
在硬件将要存储数据包的位置，理想情况下，它应该是

499
00:37:55,970 --> 00:38:00,340
在与处理数据包的线程相同的NUMA插槽上。

500
00:38:00,340 --> 00:38:04,310
然后，传入帧将根据一些接收端缩放规则进行匹配，

501
00:38:04,310 --> 00:38:05,580
分发到队列。

502
00:38:05,580 --> 00:38:09,090
如果字段F的值为beats，则每条规则看起来像这样。

503
00:38:09,090 --> 00:38:13,470
分发到这个队列，那么世界将如何根据这些规则进行匹配，以及

504
00:38:13,470 --> 00:38:17,040
如果一个数据包不符合任何规则，那么这个数据包就会被丢弃。

505
00:38:17,040 --> 00:38:21,340
但是，在F字段中我能使用的选项是有限的。

506
00:38:21,340 --> 00:38:23,130
由硬件功能所支持。

507
00:38:23,130 --> 00:38:27,850
对于ConnectX-5，它仅支持以太网IP、UDP或

508
00:38:27,850 --> 00:38:31,350
对于ConnectX-5，它仅支持以太网IP、UDP或TCP头部，但其他一些卡片则支持一些intercaste。

509
00:38:31,350 --> 00:38:35,010
但它们支持位于IE通用字段偏移量的字节。

510
00:38:35,010 --> 00:38:37,070
该区域也有限制。

511
00:38:39,270 --> 00:38:43,990
但现在我们回顾输入线程架构，是否可以采用

512
00:38:43,990 --> 00:38:47,000
接收端缩放用于重组功能。

513
00:38:47,000 --> 00:38:48,300
不，我们不能。

514
00:38:48,300 --> 00:38:52,500
它对于RSS来说是不可行的，但不幸的是并不是每一个

515
00:38:52,500 --> 00:38:56,349
数据包需要重新组装，希望只有少数几个需要这样做。

516
00:38:57,420 --> 00:39:02,510
为数据和权益患者，我们可以使用一些ISS规则来

517
00:39:02,510 --> 00:39:08,010
尝试在偏移量I处匹配一个偏差，通常情况下应该能够做到

518
00:39:08,010 --> 00:39:12,640
~!@#$%^&*()

519
00:39:14,380 --> 00:39:17,910
对于兴趣来说，这首诗也是不可行的。

520
00:39:17,910 --> 00:39:20,870
RSS一开始的名字变量较少。

521
00:39:23,450 --> 00:39:27,695
那么我们的问题是，适配器上的外壳是否能识别名称？

522
00:39:27,695 --> 00:39:33,085
ICN'16 论文以及在网络接口卡上的 NDN-NIC 基本过滤。

523
00:39:33,085 --> 00:39:36,725
它将提出计算名称的哈希值。

524
00:39:36,725 --> 00:39:41,390
通过一个布隆过滤器来决定是否接受这个数据包。

525
00:39:41,390 --> 00:39:44,840
NTP DK兴趣表达的要求也类似，

526
00:39:44,840 --> 00:39:49,750
我们想要计算名称前缀查找的哈希值，正如NDT所理解的那样，以及

527
00:39:49,750 --> 00:39:52,120
调度员根据那个提示进行操作，但是

528
00:39:52,120 --> 00:39:56,540
尼克尔的论文上只有Python模拟，这是一个很大的不同。

529
00:39:56,540 --> 00:39:59,440
嗯，我们需要一个真正的硬件实现。

530
00:39:59,440 --> 00:40:04,850
在工业领域，有几种方式可以做到这样的硬件实现，

531
00:40:04,850 --> 00:40:08,775
包括扩展的伯克利包过滤器。

532
00:40:08,775 --> 00:40:12,150
P4编程语言和FPGA硬件逻辑。

533
00:40:13,240 --> 00:40:14,610
这就是你们要参与的地方。

534
00:40:14,610 --> 00:40:16,520
我们正在寻求合作。

535
00:40:16,520 --> 00:40:21,190
如果您知道如何进行硬件实现，同时如果您

536
00:40:21,190 --> 00:40:24,990
擅长于算法建模，特别是在拥塞控制方面。

537
00:40:24,990 --> 00:40:29,070
以及我去年提出的基于磁盘的缓存策略。

538
00:40:29,070 --> 00:40:31,750
如果您能够获取一些真实的流量迹象，

539
00:40:31,750 --> 00:40:36,030
为了提升前瞻性评估，请与我们联系。

540
00:40:36,030 --> 00:40:40,180
我们也在寻找合作应用案例，

541
00:40:40,180 --> 00:40:46,410
数据密集型科学已经在使用昨天介绍的NDN-PDK。

542
00:40:46,410 --> 00:40:51,060
同样，实时视频流媒体也适用于高性能转发。

543
00:40:51,060 --> 00:40:54,280
如果您将维护其中一些库，

544
00:40:54,280 --> 00:40:58,350
我们可以帮助您在您的库中获取NDN-DPDK支持。

545
00:40:58,350 --> 00:41:02,310
这些是已经在NDN-DPDK上得到支持的一些库，而您的库可以成为下一个。

546
00:41:02,310 --> 00:41:03,808
您的库可以成为下一个。

547
00:41:03,808 --> 00:41:08,790
NDN-DPDK 代码库在 GitHub 上是开源的。

548
00:41:08,790 --> 00:41:12,300
是一个包含用作流量生成器的转发器的代码库。

549
00:41:12,300 --> 00:41:16,910
图形QL基于的管理工具，以及其中一个库，也就是我们的代码库。

550
00:41:18,860 --> 00:41:23,410
正如我之前提到的，NDN-DPDK已经扩展了平台支持。

551
00:41:23,410 --> 00:41:25,198
作为一种使用哲学的蓝色和青色。

552
00:41:25,198 --> 00:41:30,030
我们支持Ubuntu、Debian、CentOS操作系统，我们增加了对此的支持。

553
00:41:30,030 --> 00:41:31,460
VirtualBox虚拟化。

554
00:41:31,460 --> 00:41:36,792
我们还在考虑使用KVM，我们在inter以太网适配器上进行了测试。

555
00:41:36,792 --> 00:41:38,920
我们现在支持VLAN标记，以及

556
00:41:38,920 --> 00:41:41,760
我们将来会考虑支持隧道功能。

557
00:41:41,760 --> 00:41:44,120
我们还增加了本地应用程序支持，

558
00:41:44,120 --> 00:41:48,910
这意味着你可以在同一个节点上作为转发器运行你的应用程序。

559
00:41:48,910 --> 00:41:52,300
这意味着在应用程序和转发器之间共享内存传输器是非常高效的。

560
00:41:52,300 --> 00:41:53,945
在应用程序和转发器之间。

561
00:41:53,945 --> 00:41:58,080
我们还降低了最低系统要求，以便它在应用程序和转发器之间。would be possible to run the NDN-DPDK on a laptop such as you have 4 cores or

562
00:41:58,080 --> 00:42:02,979
可以在具有至少4核心处理器的笔记本电脑上运行NDN-DPDK。

563
00:42:02,979 --> 00:42:05,264
具有8GB内存或可能更少。

564
00:42:05,264 --> 00:42:09,170
还记得有一个关于fabric测试平台的报告会。

565
00:42:09,170 --> 00:42:13,710
NDN 被选为 fabric 上的一个科学驱动项目。

566
00:42:13,710 --> 00:42:18,550
因此，我们正在考虑开发我们的 NDN-DPDK 实验配置文件。

567
00:42:18,550 --> 00:42:23,290
因此，您将能够启动一个由 NDN-DPDK、转发器和多个位置的流量生成器组成的网络。

568
00:42:23,290 --> 00:42:26,980
和跨多个位置的流量生成器。

569
00:42:26,980 --> 00:42:30,690
然后您可以自定义您的应用程序、路由协议、

570
00:42:30,690 --> 00:42:34,000
转发策略和附加算法。

571
00:42:34,000 --> 00:42:36,540
利用二月提供的工具，

572
00:42:36,540 --> 00:42:40,439
您可以收集诸如数据包时序和统计信息等测量数据。

573
00:42:41,640 --> 00:42:46,750
最后，我们的论文已经发表在了2020年ACM ICN会议上。

574
00:42:46,750 --> 00:42:51,240
将在那次会议上进行NDN-NPDK的演讲，我们的演讲内容将会涵盖已完成设计的更多内容以及基准测试。

575
00:42:51,240 --> 00:42:56,480
我们的演讲内容将会涵盖已完成设计的更多内容以及基准测试。

576
00:42:56,480 --> 00:42:56,980
谢谢。

577
00:42:58,848 --> 00:43:02,780
>> 早上好，Junsho，我认为聊天中有几个问题。

578
00:43:02,780 --> 00:43:05,040
所以，第一个来自伊利亚，

579
00:43:05,040 --> 00:43:09,291
他在问NDN-DPDK文件夹的每核性能是什么。

580
00:43:10,710 --> 00:43:15,120
它是每核千兆位每秒的常用度量单位吗？

581
00:43:16,730 --> 00:43:23,950
>> 如果您将其除以一个事务，即8个转发线程，那么这是108 Gbps。

582
00:43:23,950 --> 00:43:28,893
但是我们每个面也有一个输入和输出速率。

583
00:43:31,840 --> 00:43:36,980
但是如果你只关注一个核心，那么在线程中向前看的话，那么你会

584
00:43:36,980 --> 00:43:43,180
大约每秒可以处理不到24万个数据包。

585
00:43:43,180 --> 00:43:46,590
但再一次，这只是复制转发线程，因为输入和输出是固定的。

586
00:43:46,590 --> 00:43:47,440
输出是固定的。

587
00:43:49,850 --> 00:43:53,190
好的。另一个问题是推断出来的。

588
00:43:53,190 --> 00:43:57,710
问题，你们做了研究关于对……的影响吗？

589
00:43:57,710 --> 00:44:01,300
对搬运工的性能影响的田地大小？

590
00:44:01,300 --> 00:44:05,650
是的，所以我们这样做了，五英镑，我们的参与人数达到了一百万。

591
00:44:05,650 --> 00:44:08,360
它的影响非常小。

592
00:44:08,360 --> 00:44:12,740
我将在ACM会议上展示它，因为这次我没有时间。

593
00:44:14,320 --> 00:44:19,340
>> 来自LAN的最后一个问题是，在英国到底是什么情况？

594
00:44:19,340 --> 00:44:23,770
我也有同样的疑问，当你谈论库支持的时候。

595
00:44:23,770 --> 00:44:27,230
在为DPDK辩护时，你究竟是什么意思？

596
00:44:27,230 --> 00:44:29,190
作为一个库的支持者，Wes，

597
00:44:29,190 --> 00:44:34,750
他的传输效率就像共享内存，或者至少像以太网一样高效。

599
00:44:37,800 --> 00:44:44,680
页面令牌是必须的，因为生产者说它必须返回页面令牌。

600
00:44:44,680 --> 00:44:47,540
Python NDN中没有这个功能。

601
00:44:47,540 --> 00:44:51,340
还有第三个，就是管理集成。

602
00:44:51,340 --> 00:44:54,190
自从有了NDN-DPDK，管理方式就是GraphQL。

603
00:44:54,190 --> 00:45:00,000
目前它是通过HTTP进行领先的，但将来将通过NDN进行。

604
00:45:00,000 --> 00:45:03,840
但是要说在你进行这种管理时Python能做到，那么

605
00:45:03,840 --> 00:45:06,542
它将无法读取你的子前缀。

606
00:45:06,542 --> 00:45:13,831
我们将会因此超出预定的时间安排。

607
00:45:13,831 --> 00:45:18,690
我们将会因此超出预定的时间安排。刚刚结束的那个环节，现在是时候开始小组讨论了。

608
00:45:18,690 --> 00:45:24,540
刚刚结束的那个环节，现在是时候开始小组讨论了。

609
00:45:24,540 --> 00:45:27,020
那我就交给你了，请开始吧。

610
00:45:29,470 --> 00:45:32,850
那好吧，虽然我看不到观众，但是

611
00:45:32,850 --> 00:45:35,926
我想欢迎大家来到，>> 录音开始了，

612
00:45:35,926 --> 00:45:38,780
好的，录音开始了。

613
00:45:38,780 --> 00:45:41,060
欢迎大家参加这个小组讨论。

614
00:45:41,060 --> 00:45:44,640
当时我被邀请主持那个小组讨论。

615
00:45:45,840 --> 00:45:51,340
我认为这要追溯到2009年，当时我组织了网络Ark研讨会，

616
00:45:51,340 --> 00:45:56,060
40年互联网发展历程中，Jacob Van Jacobson 呈现了

617
00:45:56,060 --> 00:45:59,220
在MDN或CCN的最初尝试。

618
00:45:59,220 --> 00:46:00,430
在那个时候。

619
00:46:00,430 --> 00:46:06,350
当时被允许在施乐帕洛阿尔托研究中心（Xerox PARC）休假。

620
00:46:06,350 --> 00:46:11,070
后来在加州大学洛杉矶分校（UCLA）也举办了那个活动，所以我非常感激我能够成为那个社群的一部分，并且我很高兴能够主持那个论坛。

621
00:46:11,070 --> 00:46:16,280
能成为那个社群的一部分，我感到非常高兴，并且能够主持那个论坛。

622
00:46:16,280 --> 00:46:18,940
如果他能快速地看一下下一张幻灯片。

623
00:46:18,940 --> 00:46:23,350
参与者们真的是

624
00:46:23,350 --> 00:46:29,410
参与者们真的是过去10年来在NDN核心工作过的人员精选。Here, they are sorted in alphabetic order.

625
00:46:29,410 --> 00:46:32,200
这里，他们按字母顺序排列。

626
00:46:32,200 --> 00:46:37,190
我们将保持那个顺序，除了Van Jacobson，我认为是

627
00:46:37,190 --> 00:46:42,870
我们将迅速进入几轮讨论，如果我们能快速地翻到下一张幻灯片。

628
00:46:46,300 --> 00:46:51,200
我们首轮将讨论的重点是上一次的亮点是什么。

629
00:46:51,200 --> 00:46:52,290
十年。

630
00:46:52,290 --> 00:46:58,610
我们想听听人们想向世界展示在那里取得了什么成就。

631
00:46:58,610 --> 00:47:00,220
您输入的内容不完整，请提供完整的句子以便翻译。

632
00:47:00,220 --> 00:47:03,590
我认为我们邀请到的小组成员会有不同的观点。

633
00:47:03,590 --> 00:47:06,790
第二轮则是关于哪些方面可以改进的讨论。

634
00:47:08,950 --> 00:47:12,880
回顾过去，有些事情本可以另作决定或者

635
00:47:12,880 --> 00:47:15,700
我们仍然需要做一些工作。

636
00:47:15,700 --> 00:47:19,860
我认为第三轮是关于结束陈述的。

637
00:47:19,860 --> 00:47:24,690
通过尝试评估目前的情况以及之后可能如何继续发展。

638
00:47:25,820 --> 00:47:29,130
那么有了下一张幻灯片，我认为我们也可以开始了。

639
00:47:30,180 --> 00:47:34,300
我要求每个人迅速分配角色或者

640
00:47:34,300 --> 00:47:38,550
他们在项目中扮演了什么角色？

641
00:47:38,550 --> 00:47:41,130
如果我们翻到下一张幻灯片，你会看到。

642
00:47:41,130 --> 00:47:44,170
我认为这是关于Van Jacobson的部分。

643
00:47:44,170 --> 00:47:45,730
我希望他能加入进来。

644
00:47:45,730 --> 00:47:48,950
我添加了精神指导者的角色。

645
00:47:48,950 --> 00:47:53,530
他真的是整个事情的发动机、马达和发起人。

646
00:47:53,530 --> 00:47:56,370
他让我把研究员作为一个角色来安排，

647
00:47:56,370 --> 00:47:59,180
这将在接下来的幻灯片中出现。

648
00:47:59,180 --> 00:48:01,130
所以，我们现在在第一轮。

649
00:48:01,130 --> 00:48:05,640
我们每个人只有几分钟，两三分钟的时间来阐述观点。

650
00:48:05,640 --> 00:48:10,820
然后我们将围绕八位小组成员展开讨论，讨论内容包括他们各自的观点，这些观点可以相互补充，可以相互评论和讨论。

651
00:48:10,820 --> 00:48:14,460
可以相云补充，可以相互评论和

652
00:48:14,460 --> 00:48:19,050
试图总结那第一点，以及过去十年的亮点。

653
00:48:19,050 --> 00:48:22,930
雅各布森，如果可以的话，请你接管发言权。

654
00:48:25,210 --> 00:48:28,734
>> 谢谢你，克里斯蒂安。

655
00:48:28,734 --> 00:48:34,500
我猜，这张幻灯片，几乎就是我们当时的重点。

656
00:48:34,500 --> 00:48:40,400
我们当时的工作重点是多播骨干网，这个骨干网以及音频和

657
00:48:40,400 --> 00:48:45,680
视频和交互工具成为了RTP协议的基础。

658
00:48:46,710 --> 00:48:52,300
它变得非常明显，基础的

659
00:48:52,300 --> 00:48:56,890
它变得非常明显，基础的IP模型在它是一个电话通话之间时真的是非常有限的，endpoints and the goal of the network was to provide a bit pipe.

660
00:48:56,890 --> 00:49:01,560
端点和网络的目标是提供一个比特流管道。

661
00:49:02,750 --> 00:49:09,626
这种通信模型有一个名字，叫做香农-韦弗模型。

662
00:49:09,626 --> 00:49:13,910
它在某种程度上是通信的最低公约数，并且

663
00:49:13,910 --> 00:49:16,940
它的主要优点是它非常容易变现。

665
00:49:20,800 --> 00:49:23,600
端点标识了创建端点的设备，

666
00:49:23,600 --> 00:49:28,246
它们之间的电线，意味着有很多赚钱的方法。

667
00:49:28,246 --> 00:49:32,030
世界上有很多成功的方法，这是真的。

668
00:49:33,130 --> 00:49:38,680
但如果你观察这些发展情况

669
00:49:40,660 --> 00:49:48,220
作为一个物种，我们已经有大约50,000年的时间来演化我们使用语言的方式，

670
00:49:48,220 --> 00:49:52,970
人与人之间以及不同群体之间的沟通模式以及如何

671
00:49:53,990 --> 00:49:58,820
将它们适应性地改变以使沟通有效地达成目标。

672
00:49:58,820 --> 00:50:03,910
这些都不包含在Shannow-Weaver模型中。

673
00:50:03,910 --> 00:50:08,120
在你尝试将无线电当做无线电使用时，这一点变得非常明显。

674
00:50:08,120 --> 00:50:12,630
利用这样一个事实：所有人都可以听到所说的话，所以

675
00:50:12,630 --> 00:50:17,190
利用这样一个事实：所有人都可以听到所说的话，因此你可以更容易地获得情况意识，也可以更容易地达成共识，using the broadcast nature, the channel.

676
00:50:17,190 --> 00:50:19,210
利用这个频道的广播特性。

677
00:50:21,060 --> 00:50:24,010
有更丰富的沟通模式。

678
00:50:24,010 --> 00:50:27,490
当前的黄金标准是宽恕别人。

679
00:50:27,490 --> 00:50:29,300
它包括广播频道，

680
00:50:29,300 --> 00:50:35,140
多方通信，角色不对称，各方执行不同的活动。

681
00:50:35,140 --> 00:50:38,330
多方通信行为，独立单元，

682
00:50:38,330 --> 00:50:41,380
语言行为是调解沟通的工具。

683
00:50:41,380 --> 00:50:45,640
你可以判断他们是成功还是失败，那里有一些相互性。

684
00:50:45,640 --> 00:50:50,930
如果你的应用程序不起作用，你可以适应，沟通。

685
00:50:50,930 --> 00:50:55,270
系统知道足够多的信息来说好吧，那不行，让我试试这个。

686
00:50:55,270 --> 00:50:59,370
我想知道这是否可能。

687
00:50:59,370 --> 00:51:03,790
制作一个低层次的通信框架，类似于IP层次的东西，并且

688
00:51:03,790 --> 00:51:08,450
实现一个类似于farlands的框架的IP的简单性。

689
00:51:10,330 --> 00:51:15,140
并且我认为那个目标在很大程度上已经实现了，那就是印度的

690
00:51:15,140 --> 00:51:19,410
这样的框架可以实现更丰富的通信模型。

691
00:51:20,840 --> 00:51:24,940
下一部分我会说它可以，但大多数情况下它并没有实现。

692
00:51:26,320 --> 00:51:29,800
这是令人悲伤的，我相信。

693
00:51:30,850 --> 00:51:31,440
我就说到这里。

694
00:51:33,030 --> 00:51:34,320
>> 好的，太棒了。

695
00:51:34,320 --> 00:51:35,790
这让我们保持在时间之中。

696
00:51:35,790 --> 00:51:40,010
所以你真的是以一种进化的轨迹来呈现它。

697
00:51:40,010 --> 00:51:41,670
我非常喜欢那个。

698
00:51:41,670 --> 00:51:44,370
我们可以看下一张幻灯片吗？

699
00:51:44,370 --> 00:51:46,870
我认为是Jeff。

700
00:51:46,870 --> 00:51:50,380
他确实给了我一个头衔，现在我也给他指定了一个。

701
00:51:50,380 --> 00:51:54,170
我认为这确实在推动NDN的使用案例和库的发展。

702
00:51:54,170 --> 00:51:57,800
杰夫，请你如果想发言的话。

703
00:51:57,800 --> 00:51:58,870
当然。谢谢你，克里斯蒂安。

704
00:52:00,690 --> 00:52:05,175
所以我主要专注于尝试构建应用程序来覆盖

705
00:52:05,175 --> 00:52:08,410
NDN现在主要在媒体上出现，但

706
00:52:08,410 --> 00:52:13,660
观察移动健康在建筑信息系统和某人中的应用情况。

707
00:52:13,660 --> 00:52:18,660
我认为我对你问题的回应主要是

708
00:52:18,660 --> 00:52:22,130
在这一点上感到情绪化，一些亮点确实是

709
00:52:22,130 --> 00:52:27,660
在黑客马拉松和注重实施的努力中，确实存在一些特定的问题和巧妙的想法。

710
00:52:27,660 --> 00:52:32,850
桌上摆着一些问题和巧妙的想法。

711
00:52:32,850 --> 00:52:37,640
我认为学生和研究人员提出了很多好的解决方案。

712
00:52:37,640 --> 00:52:43,260
我认为车辆网络和各种类型的物联网黑客攻击，

713
00:52:43,260 --> 00:52:47,120
不同的媒体处理方法，当然，这些都是非常 ~!@#$%^&*()

714
00:52:47,120 --> 00:52:51,810
令人兴奋的是，我认为这是由那个人谈论的思维转变所引发的。

715
00:52:51,810 --> 00:52:57,300
令人兴奋的是，我认为这是由那个人谈论的思维转变所引发的。展望未来，那些在更广泛部署的印度背景下看起来会更小巧、更聪明的想法将会如何发展。

716
00:52:57,300 --> 00:53:04,910
在更广泛部署的印度背景下，那些看起来会更小巧、更聪明的想法将会如何发展。

717
00:53:04,910 --> 00:53:09,950
你拥有在艰难通信环境中的强大韧性。

718
00:53:09,950 --> 00:53:12,280
你拥有更多的内在安全性。

719
00:53:12,280 --> 00:53:15,250
所以问题不仅仅在于黑客攻击本身，还在于其背后的情境上下文中。

720
00:53:15,250 --> 00:53:20,550
它们可以使用基于NDN的方法来部署，因此

721
00:53:20,550 --> 00:53:23,650
我认为那些是最令人兴奋的事情之一。

722
00:53:23,650 --> 00:53:27,520
这是一种巧妙改编结合。

723
00:53:27,520 --> 00:53:32,120
具有潜力支持架构的应用程序

724
00:53:32,120 --> 00:53:36,570
一个更加健壮的环境，那些事物最终将在其中运行。

725
00:53:36,570 --> 00:53:40,030
对我来说，这个比喻就像是对罗伯特·文图里。

726
00:53:40,030 --> 00:53:42,970
他在70年代末谈论建筑的方式。

727
00:53:42,970 --> 00:53:46,240
这种摆脱过去的观念

728
00:53:46,240 --> 00:53:51,340
摆脱过去的观念，以一种所谓的纯粹方式思考NDN的问题，这是。

729
00:53:51,340 --> 00:53:56,800
从架构的角度来看，这也许非常重要，并且

730
00:53:56,800 --> 00:54:00,000
当然，从研究团队的视角来看，但是

731
00:54:00,000 --> 00:54:05,660
适应现有情况的部署方式要复杂得多，也更具活力。

732
00:54:05,660 --> 00:54:10,621
通信机制的上方、下方、底下，以及一些真正重要的事物。

733
00:54:10,621 --> 00:54:15,960
适应我们目前拥有的工具，当前

734
00:54:15,960 --> 00:54:21,550
通信基础设施，但利用这些，好处和……

735
00:54:21,550 --> 00:54:26,290
最终，我认为我们仍然对此感到兴奋的那些特性。

736
00:54:26,290 --> 00:54:30,328
所以，我认为为了快速总结一下，

737
00:54:30,328 --> 00:54:35,330
我想也许建议，拥有更多那样的东西会是件好事。

738
00:54:35,330 --> 00:54:40,332
实验性质的探索，跨越了研究的纯粹性

739
00:54:40,332 --> 00:54:45,717
实现建筑目标的真正目的是解决

740
00:54:45,717 --> 00:54:51,419
解决一些有趣的小问题，然后将它们推向世界。

741
00:54:56,347 --> 00:54:59,483
解决一些有趣的小问题，然后将它们推向世界，那正是你应该探索、研究并应用的。

742
00:54:59,483 --> 00:55:04,000
这正是你应该去探索、研究并应用的。

743
00:55:04,000 --> 00:55:06,200
谢谢你的发言。

744
00:55:06,200 --> 00:55:09,110
我们将继续由Dave Clark来进行。

745
00:55:09,110 --> 00:55:09,710
下一张幻灯片。

746
00:55:11,750 --> 00:55:16,240
他发送了一封包含相当多文字的电子邮件，我提取了其中的几句话。

747
00:55:16,240 --> 00:55:20,080
希望这符合他想在这里表达的内容。

748
00:55:20,080 --> 00:55:23,280
戴夫·克拉克作为互联网的原始设计师之一，但是

749
00:55:23,280 --> 00:55:28,280
他还参与了FIA项目，审查了不同的提案。

750
00:55:28,280 --> 00:55:29,110
请注意安全。

751
00:55:37,411 --> 00:55:44,240
早上有什么安排吗？

752
00:55:44,240 --> 00:55:48,510
是的，我认为我开始讨论的是你幻灯片上的第一个要点。

753
00:55:49,960 --> 00:55:52,390
范在这里确实提出了一个大胆的想法。

754
00:55:52,390 --> 00:55:57,710
这是对如何构建网络的整个框架进行了重新思考。

755
00:55:58,760 --> 00:56:02,200
我认为大多数关于火的提议都是有些渐进的，并且

756
00:56:02,200 --> 00:56:03,900
我认为大多数关于火的提议都是有些渐进的，并且这一次是。非常戏剧化的。

757
00:56:03,900 --> 00:56:05,125
极其戏剧化。

758
00:56:05,125 --> 00:56:06,253
这是一个巨大的变化。

759
00:56:06,253 --> 00:56:08,713
现在，请理解我在这里有点像是一个旁观者在评论。

760
00:56:08,713 --> 00:56:12,669
我在审视各个项目。

761
00:56:12,669 --> 00:56:13,970
我没有深入参与这个。

762
00:56:13,970 --> 00:56:18,322
我参加了很多印度工作坊，那非常令人兴奋。

763
00:56:18,322 --> 00:56:22,303
我和Van有了一些非常有趣的对话，这些对话是，

764
00:56:22,303 --> 00:56:25,621
我认为，在这里提取某种洞察非常有用。

765
00:56:25,621 --> 00:56:29,600
但我想说的是，在过去的十年里，我认为在这里提取某种洞察非常有用。你必须做的，当你有了这样一个新想法时，就是去尝试和它玩耍。

766
00:56:29,600 --> 00:56:34,215
你必须做的，当你有了这样一个新想法时，就是去尝试和它玩耍。

767
00:56:34,215 --> 00:56:37,972
并且去理解它的真正力量是什么，它的优势是什么以及

768
00:56:37,972 --> 00:56:39,311
它的弱点是什么。

769
00:56:39,311 --> 00:56:42,129
你得弄清楚问题的范围是什么。

770
00:56:42,129 --> 00:56:45,565
这个的最佳点是互联网那么大的规模吗？

771
00:56:45,565 --> 00:56:47,876
这个的最佳点是更小的规模吗？

772
00:56:47,876 --> 00:56:52,982
在应用方面，正如Jeff所说，你需要投入使用案例。

773
00:56:52,982 --> 00:56:57,653
你需要亲自尝试一下，看看它实际上有什么用，你需要去操作它。

774
00:56:57,653 --> 00:56:59,857
你需要弄清楚它到底有什么用途。

775
00:56:59,857 --> 00:57:02,847
我的意思是，当特氟龙被发现时，没人知道它是什么。

776
00:57:02,847 --> 00:57:04,406
那是一个错误。

777
00:57:04,406 --> 00:57:08,890
但是当GPS提出时，最初的设计者完全没有描述

778
00:57:08,890 --> 00:57:11,588
它实际上会变得有什么好处。

779
00:57:11,588 --> 00:57:15,994
我在这里要发表三点评论。

780
00:57:15,994 --> 00:57:22,865
我认为范可能认为内容分发可能是这个的一个用例。

781
00:57:22,865 --> 00:57:25,360
我认为内容分发是一个用例，但是

782
00:57:25,360 --> 00:57:27,340
因此，实际上，这并不是一个令人信服的过渡理由。

783
00:57:27,340 --> 00:57:30,760
因此，实际上，这并不是一个令人信服的过渡理由。

784
00:57:31,800 --> 00:57:37,400
我认为在这个项目中思维演变的一个情况是

785
00:57:37,400 --> 00:57:42,540
一个非常有效的方法是理解如何将安全性整合进这个系统中。

786
00:57:42,540 --> 00:57:46,310
我认为我们仍在互联网上与安全问题作斗争。

787
00:57:46,310 --> 00:57:50,286
我认为这提供了一个重新思考安全问题的有趣方式，在

788
00:57:50,286 --> 00:57:51,565
我认为这提供了一个重新思考安全问题的有趣方式，在一个非常有力的方式中。I think one of the interesting points, which may not have been obvious in

789
00:57:51,565 --> 00:57:56,308
the beginning, computer scientists like to polish the data plane.

我认为一个有趣的点是，在一开始可能并不明显，计算机科学家喜欢打磨数据平面。

790
00:57:56,308 --> 00:58:00,838
在一开始，计算机科学家喜欢打磨数据平面。

791
00:58:00,838 --> 00:58:02,727
范谈到了数据平面。

792
00:58:02,727 --> 00:58:06,892
但实际上，我认为NDN一个有趣的点是它的~!@#$%^&*()

793
00:58:06,892 --> 00:58:10,394
提高和简化网络管理的能力。

794
00:58:10,394 --> 00:58:13,999
人们常说，管理，那是一个多么无聊的话题。

795
00:58:13,999 --> 00:58:17,639
天哪，如果我写一份关于管理的提案，它不会得到资助，而且我的职业生涯就会结束。

796
00:58:17,639 --> 00:58:18,946
我的职业生涯就会结束。

797
00:58:18,946 --> 00:58:22,188
答案是是的，但这正是我们在这方面真正难以应对的问题之一。

798
00:58:22,188 --> 00:58:25,290
互联网上确实存在一些真正的潜力。

799
00:58:25,290 --> 00:58:28,640
我会回到那个话题，但我们现在尽量要快一点。

800
00:58:28,640 --> 00:58:29,826
那对我来说就够了。

801
00:58:32,760 --> 00:58:35,280
>> 谢谢你，Dave。

802
00:58:35,280 --> 00:58:40,580
那么我们马上跳到Darleen的下一个演讲。

803
00:58:40,580 --> 00:58:48,270
请，Darleen >> 好的，现在你能听到我说话了吗？

804
00:58:49,900 --> 00:58:51,010
>> 是的。

805
00:58:51,010 --> 00:58:51,990
>> 好的，谢谢。

806
00:58:51,990 --> 00:58:57,510
所以我想你可能会对听一些关于NDN的事情感兴趣。

807
00:58:57,510 --> 00:59:02,600
从我在美国国家科学基金会(NSF)内部的视角来看历史，以及我认为是正确发生的事情。

808
00:59:02,600 --> 00:59:08,130
要在研究中取得成功，就是要将其从产品转化为使用技术。

809
00:59:09,230 --> 00:59:11,420
我认为这是NDN社区所期望的。

810
00:59:11,420 --> 00:59:12,950
你必须从一个伟大的想法开始，

811
00:59:12,950 --> 00:59:15,980
你必须从一个伟大的想法开始，我认为这是研究中最困难的部分。

812
00:59:15,980 --> 00:59:20,780
转向NDN就是这样一个想法。

813
00:59:20,780 --> 00:59:23,770
转向NDN就是这样一个想法。

814
00:59:23,770 --> 00:59:27,490
但你也需要资金才能把一个想法变成可使用的技术。

815
00:59:27,490 --> 00:59:31,471
而获得这样的资金只是出于意外的幸运。

816
00:59:31,471 --> 00:59:36,160
最终这一切的发生只是因为在国家科学基金会（NSF）内部存在着利益的汇合。

817
00:59:36,160 --> 00:59:39,089
我们有一位高层主管，他想留下一份遗产，

818
00:59:39,089 --> 00:59:44,014
一位项目主管想要研究基础设施及其上运行的东西。

819
00:59:44,014 --> 00:59:47,007
另一位项目主管，这种情况也发生在我身上，

820
00:59:47,007 --> 00:59:48,784
他们想要一个新的安全互联网。

821
00:59:48,784 --> 00:59:52,200
这导致了GENI，一个研究基础设施和

822
00:59:52,200 --> 00:59:55,826
这导致了GENI，一个研究基础设施和未来互联网架构，FIA计划，我和各种项目主管经营的，这个计划资助了NDN。

823
00:59:55,826 --> 00:59:59,120
各种项目主管经营的，这个计划资助了NDN。

824
00:59:59,120 --> 01:00:04,394
我们需要一篇论文，而这篇论文就是David Clark在2004年发表的New'Arch文章，

825
01:00:04,394 --> 01:00:08,760
它为FIA的最初社区参与提供了思路。

826
01:00:08,760 --> 01:00:13,205
然后，正如大卫所说，他继续帮助我们就FIA概念方面的工作。

827
01:00:13,205 --> 01:00:17,715
并且从社区中协调，进行FIA奖项的工作。

828
01:00:17,715 --> 01:00:21,745
我认为大型成功的创新项目需要一位充满热情的领导者，

829
01:00:21,745 --> 01:00:25,935
NDN在没有Leisha Zhang的情况下，就不会成为今天这个样子。

830
01:00:25,935 --> 01:00:27,235
致力于使其成为现实。

831
01:00:27,235 --> 01:00:29,565
当然，有许多许多的贡献者，

832
01:00:29,565 --> 01:00:32,000
包括来自这个小组的人员。

833
01:00:32,000 --> 01:00:35,620
以及由其他组织提供资金支持，例如NIST、DARPA、Intel等，

834
01:00:35,620 --> 01:00:40,240
其他支持者推动NDN的发展，以实现新技术和新应用的启用。

835
01:00:40,240 --> 01:00:44,709
我认为创建一个超越最初的研究社区也是至关重要的。

836
01:00:44,709 --> 01:00:45,612
研究人员。

837
01:00:45,612 --> 01:00:50,964
我认为ACM ICM会议的设立采用了这样成功的方法。

838
01:00:50,964 --> 01:00:56,328
我认为ACM ICM会议的设立采用了这样成功的方法。正如我们在过去两天所参与的这样的NDN社区研讨会。

839
01:00:56,328 --> 01:00:59,578
我期待NDN未来能取得更多的成功，并且

840
01:00:59,578 --> 01:01:04,554
希望它能够保持今天的活力继续前行。

841
01:01:04,554 --> 01:01:05,320
谢谢。

842
01:01:07,623 --> 01:01:08,291
谢谢。

843
01:01:08,291 --> 01:01:11,730
[INAUDIBLE] 真的为资助了一个项目感到非常自豪。

844
01:01:11,730 --> 01:01:12,380
太好了。

845
01:01:12,380 --> 01:01:13,593
非常感谢你，Darleen。

846
01:01:16,211 --> 01:01:18,780
以及Christos。

847
01:01:18,780 --> 01:01:23,510
他非常谨慎地说，自2010年以来他一直在研究NDN。

848
01:01:23,510 --> 01:01:29,833
这话说得太保守了，请继续，克里斯托斯。

849
01:01:29,833 --> 01:01:30,725
>> 谢谢你，克里斯蒂安。

850
01:01:30,725 --> 01:01:31,949
所以我会简短一些。

851
01:01:31,949 --> 01:01:39,204
我认为在我之前的其他人已经提出了NDN的宽广和大胆的愿景。

852
01:01:39,204 --> 01:01:43,213
对我来说，过去十年的亮点包括，

853
01:01:43,213 --> 01:01:47,499
首先是建立一个强大的印度社区。

854
01:01:47,499 --> 01:01:52,665
我真的很高兴看到美国国家标准与技术研究院采纳了社区会议并且

855
01:01:52,665 --> 01:01:54,691
正在培育社区。

856
01:01:54,691 --> 01:02:00,067
我在NDN社区与人交往的经验是，那些有着

857
01:02:00,067 --> 01:02:05,744
大型网络问题需要解决，例如科学界。

858
01:02:05,744 --> 01:02:10,153
他们一旦看到并理解了NDN能做什么并且

859
01:02:10,153 --> 01:02:14,112
他们意识到自己对IP的挫败感，

860
01:02:14,112 --> 01:02:19,710
他们成为了NDN的热情支持者和坚定信令。

861
01:02:19,710 --> 01:02:24,340
他们已经去撰写提案并争取资金等等了。

862
01:02:24,340 --> 01:02:28,760
我认为我们能够接触到这是一个巨大的成功。

863
01:02:28,760 --> 01:02:33,550
我们将其推广给社区中真正有需求的一群人，

864
01:02:33,550 --> 01:02:37,939
他们认识到NDN可能是解决他们问题的真正方案。

865
01:02:39,960 --> 01:02:45,717
我们还取得了另一个成就，那就是在NFD方面的重大改进。

866
01:02:45,717 --> 01:02:49,429
再次，得到国家标准与技术研究院(NIST)的支持，

867
01:02:49,429 --> 01:02:53,642
观看了紧接在这个之前的演讲，

868
01:02:53,642 --> 01:02:59,172
我认为NFD已经取得了长足的进步，并且它仍然充满了很多潜力。

869
01:02:59,172 --> 01:03:04,019
我们将会看到更多来自该团队的杰出成果。

870
01:03:04,019 --> 01:03:05,950
我们正在研究NFD的团队。

871
01:03:05,950 --> 01:03:10,776
这是一个真正的需求，在这里我看到了它，并且感到非常高兴，我们正在向前迈进。

872
01:03:10,776 --> 01:03:16,417
最后我很高兴看到的是那几个充满活力的公司。

873
01:03:16,417 --> 01:03:21,183
公司们已经意识到了NDN的潜力。

874
01:03:21,183 --> 01:03:25,183
公司们正在采取行动并且继续采纳它，

875
01:03:25,183 --> 01:03:31,343
证明给世界其他地方看，NDN具有真正的商业用途，并且

876
01:03:31,343 --> 01:03:34,819
你实际上可以用它来赚钱。

877
01:03:35,960 --> 01:03:38,320
所以我认为那是一件好事。

878
01:03:38,320 --> 01:03:39,010
好的，谢谢。

879
01:03:39,010 --> 01:03:39,510
我就到这里停止。

880
01:03:40,900 --> 01:03:41,980
>> 谢谢你，克里斯托斯。

881
01:03:43,520 --> 01:03:51,005
兰·王是我们小组讨论的下一位成员。

882
01:03:51,005 --> 01:03:52,488
>> 你能听见我吗？

883
01:03:52,488 --> 01:03:53,428
>> 是的。

884
01:03:53,428 --> 01:03:54,345
好的。

885
01:03:54,345 --> 01:04:01,800
所以我根据自己的经验编写了幻灯片，写的都是有效果的方法。

886
01:04:06,520 --> 01:04:08,310
我只是给出了一些例子。

887
01:04:09,990 --> 01:04:13,030
所以我认为第一件做得好的事情是，

888
01:04:13,030 --> 01:04:18,160
我们以路由协议的设计和实现为例。

889
01:04:18,160 --> 01:04:22,779
然后实际应用到

890
01:04:22,779 --> 01:04:30,420
验证通过同步进行多方通信的想法。

891
01:04:30,420 --> 01:04:37,630
我们还使用它来验证系统化信任的设计。

892
01:04:38,840 --> 01:04:43,533
我们还使用它来帮助改进实现这些功能的库。

893
01:04:43,533 --> 01:04:46,981
同样可以是安全机制。

894
01:04:46,981 --> 01:04:52,653
我认为那是一个很好的例子。

895
01:04:52,653 --> 01:04:57,452
的一个NDN应用程序开发

896
01:04:57,452 --> 01:05:03,124
有助于改善开发

897
01:05:03,124 --> 01:05:08,160
这些主要机制之一。

898
01:05:08,160 --> 01:05:12,700
后来我们发展了这种基本上是静态的双曲路由方案。

899
01:05:14,640 --> 01:05:20,730
后来我们发展了这种基本上是静态的双曲路由方案。

900
01:05:25,220 --> 01:05:33,020
这实际上展示了IP与其他技术之间的主要区别。

901
01:05:33,020 --> 01:05:38,090
转发平面是无状态的，不能执行智能操作。

902
01:05:38,090 --> 01:05:41,930
它只是听从路由的指令去执行，但是

903
01:05:41,930 --> 01:05:47,770
在NDN中，转发平面是固定的，而且可以非常智能。

904
01:05:47,770 --> 01:05:52,600
因此，这种基本上是静态的路由方式，迫使我们在我们自己的设计中使转发平面更加智能。

905
01:05:52,600 --> 01:05:57,460
为了在我们自己的设计中使转发平面更加智能。

906
01:05:57,460 --> 01:06:04,100
并且它实际上运行得非常好，我们在NDN测试床中部署了这种双曲路由，以及一种自适应的转发策略。

907
01:06:04,100 --> 01:06:10,010
我们在NDN测试床中部署了这种双曲路由，以及一种自适应的转发策略。

908
01:06:11,450 --> 01:06:14,600
所以这是我们如何能够的另一个例子。

909
01:06:16,940 --> 01:06:23,650
展示NDN相比于IP的不同之处或优势。

910
01:06:24,700 --> 01:06:31,630
第三个例子，我认为，是去中心化应用程序。

911
01:06:31,630 --> 01:06:35,690
今天很多社交媒体和~!@#$%^&*()

912
01:06:35,690 --> 01:06:40,150
其他应用程序它们是基于中心化的云端的。

913
01:06:40,150 --> 01:06:42,800
用户实际上并不拥有他们自己的数据。

914
01:06:43,865 --> 01:06:50,420
通过去中心化这些应用程序，NDN在那个领域变得更加低调，所以

915
01:06:50,420 --> 01:06:56,610
用户拥有自己的数据，他们可以控制自己的隐私。

916
01:06:56,610 --> 01:07:02,240
所以在这个领域，我认为我们已经开始关注去中心化社交媒体应用程序，去中心化智能家居系统。

917
01:07:02,240 --> 01:07:08,240
媒体应用程序，去中心化智能家居系统。

918
01:07:08,240 --> 01:07:16,610
我认为这些是展示NDN相对于IP的优势的非常好的应用。

919
01:07:16,610 --> 01:07:21,620
所以这些是一些例子。

920
01:07:21,620 --> 01:07:27,514
我认为这确实可以帮助人们更加欣赏如何

921
01:07:27,514 --> 01:07:33,136
NDN在架构上有所不同。

922
01:07:35,374 --> 01:07:39,311
>> 谢谢你展示了涵盖事物的范围

923
01:07:39,311 --> 01:07:42,810
在那个项目中回顾过去十年。

924
01:07:44,170 --> 01:07:48,363
我想邀请北川继续发表他的观点。

925
01:07:53,434 --> 01:07:59,331
是的，所以克里斯蒂安在邮件中给了我们一些指导思想，

926
01:07:59,331 --> 01:08:03,150
建造最终就像建造一座房子。

927
01:08:03,150 --> 01:08:10,130
高光点和改进之处是什么，目前的状态如何？

928
01:08:10,130 --> 01:08:13,770
所以也许只有我一个人在往那个方向前进。

929
01:08:14,810 --> 01:08:19,450
所以，我不是建造房子或建筑的专家。

930
01:08:19,450 --> 01:08:20,910
但想想一座房子吧。

931
01:08:20,910 --> 01:08:27,120
我认为有三个方面，第一个是它的美学方面，

932
01:08:27,120 --> 01:08:31,930
第二个是它的功能性，第三个是它的工程技术。

933
01:08:31,930 --> 01:08:32,728
一切都回归于美。

934
01:08:32,728 --> 01:08:36,670
但是，从这个角度思考的话。

935
01:08:36,670 --> 01:08:44,550
对我来说，NDN最大的亮点真的是它那个非常基础的核心理念，

936
01:08:44,550 --> 01:08:49,320
正如戴夫所说，这是一个非常大胆的想法，远超许多其他的提案。

937
01:08:49,320 --> 01:08:53,370
但我认为这不仅大胆，而且非常简单，对吗？

938
01:08:53,370 --> 01:08:56,320
数据的核心就是你的名字。

939
01:08:56,320 --> 01:08:56,960
~!@#$%^&*()

940
01:08:56,960 --> 01:09:02,090
如果你接受那个作为你的基本起点，而不需要任何其他东西。

941
01:09:02,090 --> 01:09:06,660
你自然还有其他东西，比如网络中的Myspace，

942
01:09:06,660 --> 01:09:09,920
数据中心安全、信任模式和

943
01:09:09,920 --> 01:09:14,770
所以，这是一个非常强大的想法。

944
01:09:14,770 --> 01:09:17,550
所以，我认为对我来说，

945
01:09:17,550 --> 01:09:23,450
我真的很欣赏这个NDN房子的真实特色。

946
01:09:23,450 --> 01:09:26,040
而且亮点是，我认为在过去的10年里。

947
01:09:26,040 --> 01:09:30,200
我们见证了ICN/NDN度假社区的兴起，这实际上意味着更多的人开始欣赏这个观点，并愿意在这个想法上努力。

948
01:09:30,200 --> 01:09:35,490
越来越多的人开始欣赏这个想法，并愿意在这个理念上努力。

949
01:09:35,490 --> 01:09:38,910
所以，对我来说那是最重要的一点。

950
01:09:38,910 --> 01:09:47,210
在功能方面，我认为是用户的应用程序开发。

951
01:09:47,210 --> 01:09:51,880
所以在过去的10年里，我们有相当多的发展。

952
01:09:51,880 --> 01:09:55,090
我们还有像这样的应用用户，

953
01:09:55,090 --> 01:09:59,640
我们还有像这样的应用用户，数据密集型科学家和媒体以及与水晶一起行走的应用。And we have the AR VR application Jeff work has been working on and

954
01:09:59,640 --> 01:10:03,970
我们还有杰夫一直在研究的AR VR应用程序，以及

955
01:10:03,970 --> 01:10:06,210
还有许多其他的应用程序。

956
01:10:06,210 --> 01:10:09,460
在工程方面。

957
01:10:09,460 --> 01:10:14,440
我们设计了一系列协议并实现了它们，在原型中进行了测试，并且已经部署在了TestFlight上。

958
01:10:14,440 --> 01:10:19,150
我们在原型中对它们进行了测试，并且已经在TestFlight上部署。

959
01:10:19,150 --> 01:10:26,660
我们还提出了一种新机制来处理提供新功能的问题。

960
01:10:26,660 --> 01:10:32,196
我们在观察一个NDN房子时，似乎我们

961
01:10:32,196 --> 01:10:38,260
我们似乎已经完成了一些非常基础的事情。

962
01:10:38,260 --> 01:10:40,610
好的。我认为这离完成还远。

963
01:10:40,610 --> 01:10:46,180
但是已经有相当一部分组件到位了。

964
01:10:46,180 --> 01:10:50,430
越来越多的人正在参与其中。

965
01:10:50,430 --> 01:10:54,710
所以，我认为这已经差不多了，我觉得这些是重点。

966
01:10:57,050 --> 01:10:58,530
是的，就是这样。

967
01:10:58,530 --> 01:11:00,310
>> 非常感谢。

968
01:11:00,310 --> 01:11:05,960
这本身就是主题，但确实讲述了故事，而且

969
01:11:05,960 --> 01:11:08,900
这些审美的部分也是方程的一部分。

970
01:11:08,900 --> 01:11:09,780
谢谢。

971
01:11:09,780 --> 01:11:15,600
下一张幻灯片，现在我们来总结一下她的过去。

972
01:11:18,250 --> 01:11:22,250
当被问及角色时，她还说是要保持团队的运转。

973
01:11:22,250 --> 01:11:29,211
当被问及角色时，她还说是要保持团队的运转。那么，请丽霞，你的幻灯片。

974
01:11:31,913 --> 01:11:32,770
>> 谢谢。

975
01:11:32,770 --> 01:11:34,251
我希望你现在能看到我。

976
01:11:34,251 --> 01:11:40,690
作为最后一个发言的人，我可以回顾并重复之前人们已经说过的话。

977
01:11:41,800 --> 01:11:44,060
我认为Darlene说得完全正确。

978
01:11:46,090 --> 01:11:51,032
NDN项目在没有NSF资金支持的情况下提出了这个伟大的想法，

979
01:11:51,032 --> 01:11:56,442
NDN项目在没有帮助的情况下启动，我认为整个NDN团队都应该为此感到骄傲。

980
01:11:56,442 --> 01:12:02,480
我猜社区真的很感激来自NSF的支持。所以

981
01:12:02,480 --> 01:12:04,360
这么多年来。

982
01:12:04,360 --> 01:12:09,280
其次，我想说，在此期间，不仅仅是我坚持下来了。

983
01:12:09,280 --> 01:12:10,290
我认为是团队。

984
01:12:11,370 --> 01:12:19,260
团队尽管遇到了许多意想不到的挑战，但还是坚持了十多年。

985
01:12:19,260 --> 01:12:21,920
所以我们不必再继续走那条路了。

986
01:12:21,920 --> 01:12:26,750
有些时候真的很黑暗、很艰难，几乎就像有人在作恶。

987
01:12:26,750 --> 01:12:27,640
项目。

988
01:12:27,640 --> 01:12:31,370
但是团队相信这个方向。

989
01:12:31,370 --> 01:12:32,940
这就是这个名字。

990
01:12:32,940 --> 01:12:38,680
安全数据是构建未来网络的方向。

991
01:12:38,680 --> 01:12:43,830
所以，虽然道路漫长，但我认为我们做得很好。

992
01:12:45,160 --> 01:12:51,110
回到我认为十年经验这个观点上来

993
01:12:51,110 --> 01:12:57,010
确实证明了使用命名来保护数据是有效的。

994
01:12:57,010 --> 01:13:04,290
作为基础架构的构建模块，这确实是正确的方向。

995
01:13:04,290 --> 01:13:07,560
顾客，我已经提到过那个了。

996
01:13:09,030 --> 01:13:13,890
我记得多年前Dave Clark发表过这篇论文。

997
01:13:13,890 --> 01:13:18,380
那篇论文当天就声明了关于塔珀互联网协议的设计理念的基本架构要求。

998
01:13:19,680 --> 01:13:25,290
requirements for the design philosophy of the Tapper Internet Protocol. The distinctive ~!@#$%^&*()

999
01:13:25,290 --> 01:13:31,170
互联网的一个特点是使用数据报，因为这样，

1000
01:13:31,170 --> 01:13:37,450
修正了构建模块之后，互联网实现了许多当初在TCP/IP规范发布时未被预见的事物。

1001
01:13:37,450 --> 01:13:45,210
在TCP/IP规范发布的时候，这种特性是未被预见到的。

1002
01:13:45,210 --> 01:13:50,260
我认为这正是提到的NDN局域网发生的情况。

1003
01:13:50,260 --> 01:13:56,440
这些天我们正在利用语义命名数据的基本概念，以及

1004
01:13:56,440 --> 01:14:03,160
将安全数据推动这些分布式应用程序的前沿。

1005
01:14:03,160 --> 01:14:10,400
向开发者提供完全分布式的社交应用工具。

1006
01:14:10,400 --> 01:14:15,520
加州大学洛杉矶分校目前正在开发一种名为NDN light的技术，

1007
01:14:15,520 --> 01:14:21,440
这是一套完全由最终用户控制的智能家居系统。

1008
01:14:21,440 --> 01:14:23,750
我们并不是说云服务没有用处。

1009
01:14:23,750 --> 01:14:29,270
云是一个很棒的资源，就像控制权所在的地方一样。

1010
01:14:29,270 --> 01:14:34,860
控制权必须真正地交还到终端用户手中，才能向前迈进。

1011
01:14:34,860 --> 01:14:40,820
互联网进入下一个阶段：分布式和安全系统。

1012
01:14:42,610 --> 01:14:47,820
所以，我还想指出，我认为我给安全数据命名了。

1013
01:14:47,820 --> 01:14:49,660
那是基石，但是

1014
01:14:49,660 --> 01:14:54,660
这个想法并不是有一天突然从天而降的，需要经过验证。

1015
01:14:54,660 --> 01:14:59,590
我与之合作了很多年，从我在麻省理工学院开始。

1016
01:14:59,590 --> 01:15:04,570
那时候他和我经常争论，直到后来，

1017
01:15:04,570 --> 01:15:10,790
我开始欣赏这种技术洞察力。

1018
01:15:10,790 --> 01:15:15,500
是的，我们正在研究以可扩展性为起点的事物，

1019
01:15:15,500 --> 01:15:17,300
可靠的组播。

1020
01:15:17,300 --> 01:15:21,860
他们基本上结合了来自静态理论的组播思想。

1021
01:15:21,860 --> 01:15:25,790
结合了Dave关于应用层框架的想法。

1022
01:15:25,790 --> 01:15:30,750
这就是说，网络并不是关于向国家射击子弹来进行测试的。

1023
01:15:30,750 --> 01:15:33,280
但这实际上是关于塑造数据的。

1024
01:15:33,280 --> 01:15:38,430
莉莎应用程序数据将传递给所有甜点派对的参与者。

1025
01:15:40,640 --> 01:15:47,970
我还想说，由于我参与IETF已经很多年了，

1026
01:15:47,970 --> 01:15:54,760
你可以看到，这种以国家为中心的方向已经被许多人接受。

1027
01:15:54,760 --> 01:15:59,670
其他的努力，只是问题在于我们要推进到什么程度。

1028
01:15:59,670 --> 01:16:04,390
目前的方向大多停留在较高层面。

1029
01:16:04,390 --> 01:16:08,900
我认为这是一个非常好的愿景，它推动了方向性的彻底落实。

1030
01:16:08,900 --> 01:16:13,860
建设基础设施，以便整个系统更加协调一致。

1031
01:16:13,860 --> 01:16:19,310
是的，作为支撑未来网络的基础设施，它必须是安全的。

1032
01:16:21,190 --> 01:16:23,770
如果我把它们放在最后一句话里，

1033
01:16:23,770 --> 01:16:29,835
我认为安全性必须内置于基因之中。

1034
01:16:29,835 --> 01:16:34,160
在所有的系统中，我认为有一部分NDN正在得到

1035
01:16:34,160 --> 01:16:40,200
正确的故事并没有在语义上被命名，安全数据作为一个构建块。

1036
01:16:41,560 --> 01:16:43,250
现在是我的发言结束。

1037
01:16:45,520 --> 01:16:46,930
谢谢你，丽霞。

1038
01:16:46,930 --> 01:16:49,359
现在我们有了全部八位小组讨论成员。

1039
01:16:50,630 --> 01:16:57,280
我想问他们，你们希望如何组织讨论？

1040
01:16:57,280 --> 01:17:02,250
我应该提出一些话题，还是有人想要回应？

1041
01:17:02,250 --> 01:17:06,059
一些小组成员对其他人的评论表示赞美。

1042
01:17:14,111 --> 01:17:17,085
那么，让我先迈出第一步。

1043
01:17:17,085 --> 01:17:22,450
~!@#$%^&*()

1044
01:17:22,450 --> 01:17:28,015
我们听说很多关于应用程序是验证的事情。

1045
01:17:28,015 --> 01:17:32,530
这正是最终明白原因的确切情况。

1046
01:17:33,590 --> 01:17:38,500
你是否有一些关于特定事件的记忆，在这些事件中，这现在变得

1047
01:17:38,500 --> 01:17:43,740
容易，或者说现在有了那个新的构建模块ID，这真的是一个突破。

1048
01:17:43,740 --> 01:17:46,870
您可以报告的基本ID。

1049
01:17:46,870 --> 01:17:51,980
这将是问题的一部分，您还看到其他仍然存在的问题吗？

1050
01:17:51,980 --> 01:17:58,301
我们可能会发现一些很好的发现，现在有了NDN，情况变得更好了。

1051
01:17:58,301 --> 01:18:03,490
我们可能会发现一些很好的发现，现在有了NDN，情况变得更好了。发出信件后，其他人也有了机会。Let me just mention one simple thing, security.

1052
01:18:03,490 --> 01:18:06,070
让我只提一件简单的事情，安全。

1053
01:18:07,470 --> 01:18:10,700
我认为在早期，当那个人跟我谈论把这整个项目放在一起时，

1054
01:18:10,700 --> 01:18:11,940
项目一起进行，

1055
01:18:11,940 --> 01:18:15,630
他一直在强调这主要是为了保护数据目录。

1056
01:18:16,720 --> 01:18:22,720
但从那里开始，这个想法的实用性，

1057
01:18:22,720 --> 01:18:26,280
我只是无边界地扩展它。

1058
01:18:26,280 --> 01:18:32,790
例如，加密密钥不过是给数据命名的一部分而已，

1059
01:18:32,790 --> 01:18:38,500
如果你将其作为证书发送，因此NDN实现了安全性。

1060
01:18:38,500 --> 01:18:44,150
将其作为基因直接内置于系统中是非常直接的。

1061
01:18:44,150 --> 01:18:49,730
证书只是一段数据，因此你可以从任何地方获取它。

1062
01:18:49,730 --> 01:18:54,850
今天如果我们想知道UserWay的加密密钥是什么，

1063
01:18:54,850 --> 01:18:58,930
我真的不知道应该如何找到它。

1064
01:18:58,930 --> 01:19:03,090
在一切中寻找，变得琐碎化了，以至于使用那个词。

1065
01:19:03,090 --> 01:19:07,070
在如此等等中，即是信任政策。

1066
01:19:07,070 --> 01:19:11,290
如果你想知道UserWay对此和对于政策的方式是什么

1067
01:19:11,290 --> 01:19:15,250
~!@#$%^&*()

1068
01:19:15,250 --> 01:19:19,060
注册页面将他引导到了某个支付页面。

1069
01:19:19,060 --> 01:19:21,825
这不是，我们可以分享网站和

1070
01:19:21,825 --> 01:19:26,140
这恰好是一名学生关于安全性的工作。

1071
01:19:26,140 --> 01:19:29,950
他通过了一个特别的他们去那里，对吗？

1072
01:19:29,950 --> 01:19:34,640
这是一个简单的[不可辨识]例子，用来说明你的信任政策是什么，

1073
01:19:34,640 --> 01:19:37,860
你说我们到底信任这个还是那个网站。

1074
01:19:37,860 --> 01:19:41,520
他们指示学生去那里处理付款。

1075
01:19:41,520 --> 01:19:45,510
~!@#$%^&*()

1076
01:19:45,510 --> 01:19:48,990
NDN具有信任模式的概念。

1077
01:19:48,990 --> 01:19:55,670
而且，这又仅仅是一份具有既定的命名约定的命名安全数据。

1078
01:19:55,670 --> 01:19:59,510
命名约定，再次，你可以仅仅刷新那部分数据并且

1079
01:19:59,510 --> 01:20:04,060
构建命名以说，给我使用你的方式安全策略来处理任何事情。

1080
01:20:05,120 --> 01:20:06,010
但那时我们正在工作。

1081
01:20:06,010 --> 01:20:07,002
我会就此打住。

1082
01:20:11,682 --> 01:20:15,079
>> 谢谢，很高兴有人加入这次讨论。

1083
01:20:20,773 --> 01:20:23,178
好吧，我来发表一个评论。

1084
01:20:23,178 --> 01:20:29,280
我认为这可能会引导我们进入你想要提出的第二轮问题，但是

1085
01:20:29,280 --> 01:20:34,610
我认为，在你探索所发现的内容时，你必须要问的一个问题是，这里发现的是什么，正确的思想纠缠是什么？

1086
01:20:34,610 --> 01:20:40,100
在这里发现的是什么，正确的思想纠缠是什么？

1087
01:20:40,100 --> 01:20:43,690
我指的是，我认为，

1088
01:20:45,080 --> 01:20:51,120
拥有一种自我保护状态的数据，即已注册的数据。

1089
01:20:51,120 --> 01:20:56,220
作为一个构建模块，这是一个非常强大的想法。

1090
01:20:59,357 --> 01:21:01,980
这是一个可能会有局限性的想法，

1091
01:21:01,980 --> 01:21:04,770
这是一个可以整合到互联网中的想法。

1092
01:21:05,980 --> 01:21:08,670
我们可以有一个框架来~!@#$%^&*()

1093
01:21:08,670 --> 01:21:13,570
数据允许它被签名等等。

1094
01:21:13,570 --> 01:21:17,770
我认为我们还没有朝那个方向发展

1095
01:21:17,770 --> 01:21:22,560
我们在互联网方面的发展或者我们已经比我们有的更进一步是一个是~!@#$%^&*()

1096
01:21:22,560 --> 01:21:26,869
一个非常有趣的问题去思考。

1097
01:21:26,869 --> 01:21:32,050
但这确实引发了一个问题，即是否

1098
01:21:32,050 --> 01:21:38,030
是否存在一个通用的、用于保护数据的统一框架。

1099
01:21:38,030 --> 01:21:43,160
我认为NDN中的想法是这样的，

1100
01:21:43,160 --> 01:21:46,770
当然，有一个通用的框架。

1101
01:21:46,770 --> 01:21:48,130
因为归根结底，

1102
01:21:48,130 --> 01:21:52,520
每一条信息都可以被简化为一堆比特，而比特就是比特。

1103
01:21:52,520 --> 01:21:56,960
那么如果你把安全措施放在比特级别，

1104
01:21:56,960 --> 01:21:59,610
那么你就得到了一个通用架构。

1105
01:22:01,520 --> 01:22:07,050
我认为那仍然是一个有待讨论的领域。

1106
01:22:07,050 --> 01:22:12,040
可能确实存在这样一种情况，你可能想要应用安全措施。

1107
01:22:12,040 --> 01:22:16,230
在这种程度上，你还没有必要将其简化成一堆二进制数据，你需要更多的东西。

1108
01:22:16,230 --> 01:22:21,150
我认为应该区分的是多样性以及其实现方式。

1109
01:22:21,150 --> 01:22:26,430
这场对话应该与分组转发分开来讨论。

1110
01:22:28,330 --> 01:22:33,860
这个问题是否你想要集成

1111
01:22:33,860 --> 01:22:38,230
将安全模型集成到数据包级别，也就是说，

1112
01:22:38,230 --> 01:22:41,740
在某种意义上，NDN科学数据包，并不对比特包进行签名。

1113
01:22:41,740 --> 01:22:46,690
如果我要求第一个数据包，对于第二个数据包也是如此，那么第三个数据包也是一样。

1114
01:22:46,690 --> 01:22:49,740
我认为这是一个非常有趣的问题。

1115
01:22:49,740 --> 01:22:54,230
这种架构有助于揭示出来的问题，但我认为我们还没有找到答案。

1116
01:22:54,230 --> 01:22:59,870
这些想法结合在一起时其威力之大是我们现在所了解的。

1117
01:22:59,870 --> 01:23:03,070
或者实际上现在我们都明白了，

1118
01:23:03,070 --> 01:23:06,430
你应该重新问一下，它们是否需要被捆绑在一起？

1119
01:23:06,430 --> 01:23:12,530
有一些真正有趣的东西缺失了。

1120
01:23:12,530 --> 01:23:17,330
在某种意义上，这里存在一些深层次的建筑问题。

1121
01:23:17,330 --> 01:23:22,220
你必须拥有一个像这样大胆的项目。

1122
01:23:22,220 --> 01:23:27,230
你必须像NDN那样充满活力，以帮助推动对这些事情的思考。

1123
01:23:31,365 --> 01:23:36,338
>> 我在某种程度上不同意Dave的观点。

1124
01:23:36,338 --> 01:23:41,359
~!@#$%^&*()

1125
01:23:41,359 --> 01:23:46,237
这是Ron Rico关于观光的工作吗？

1126
01:23:46,237 --> 01:23:51,418
一些相关的理论工作。

1127
01:23:51,418 --> 01:23:56,701
所说的，我们所知道的每一个安全工具

1128
01:23:56,701 --> 01:24:01,839
我们能够构想出的每一个构建都是基于

1129
01:24:01,839 --> 01:24:08,264
我们能够构想出的每一个构建都是基于这些具有潜力的单元，on certificates is based on these item potent units, where you bind together a name that has some context a key object,

1130
01:24:08,264 --> 01:24:16,115
在那里，你将一个具有一定上下文的名字与一个关键对象绑定在一起，

1131
01:24:16,115 --> 01:24:21,398
然后是一个声明来源的签名，它说，

1132
01:24:21,398 --> 01:24:26,680
哪个方声明这个名字就是该名字

1133
01:24:26,680 --> 01:24:31,153
这个公钥，这个工件。

1134
01:24:31,153 --> 01:24:36,498
如果你说那部分数据不需要

1135
01:24:36,498 --> 01:24:41,988
不必是一个关键的东西，它可以只是任意的位元。

1136
01:24:41,988 --> 01:24:47,044
你知道这是一个你想要进行的言语行为。

1137
01:24:47,044 --> 01:24:52,392
~!@#$%^&*()

1138
01:24:52,392 --> 01:24:58,920
这些数据被该方认为是不可分割的。

1139
01:25:02,100 --> 01:25:06,230
鉴于这似乎是一种普遍的基础构件，以及

1140
01:25:06,230 --> 01:25:11,130
我们将其作为全球信任体系的基础构件，由此产生了一个问题。

1141
01:25:12,410 --> 01:25:13,910
你能建造其他东西吗？

1142
01:25:15,960 --> 01:25:21,890
安全的限制意味着很多不同的事情。

1143
01:25:21,890 --> 01:25:26,950
通常在互联网环境下它的产品被视为某种全球性

1144
01:25:26,950 --> 01:25:31,990
信任源自全球信任路径和域名系统以及一堆

1145
01:25:31,990 --> 01:25:37,130
如果你想要自下而上地做一些事情，比如在家里呢？

1146
01:25:38,490 --> 01:25:43,290
如果你想要做一些介于两方之间的事情，或者

1147
01:25:43,290 --> 01:25:46,830
小群体有一个共同的兴趣，他们只是想要

1148
01:25:48,590 --> 01:25:53,330
小群体有一个共同的兴趣，他们只是想要拥有隐私和信任，或者仅仅围绕他们的共同兴趣？

1149
01:25:55,740 --> 01:26:00,830
所以有一个理论证明，忘记了那篇论文，但是

1150
01:26:00,830 --> 01:26:05,760
我可以转发给你，话虽如此，好吧，证书到

1151
01:26:05,760 --> 01:26:09,160
我们能够建造那些东西的程度，你的基础构件将会是搜索。

1152
01:26:09,160 --> 01:26:14,300
搜索之间的相互关联方式定义了系统。

1153
01:26:14,300 --> 01:26:18,430
这与你在名称中设置的结构有关。

1154
01:26:18,430 --> 01:26:25,050
因此我希望NDN能拥有那个构建模块，我想要它能够用于许多不同的系统，这些系统大多数还没有被使用。

1155
01:26:25,050 --> 01:26:30,670
它能够用于许多不同的系统，这些系统大多数还没有被使用。

1156
01:26:32,030 --> 01:26:36,930
工作不仅仅存在于神经网络之外。

1157
01:26:36,930 --> 01:26:42,030
所有被称为自主安全的领域目前都在迅速发展。

1158
01:26:42,030 --> 01:26:47,360
部分原因是另一个构成要素的发展，即区块链技术。

1159
01:26:47,360 --> 01:26:51,820
交易安全完全取决于相关各方。

1160
01:26:51,820 --> 01:26:53,530
全球并没有一个统一的信任路径。

1161
01:26:54,721 --> 01:26:57,640
我认为那样的模型。

1162
01:27:00,060 --> 01:27:05,480
凯西·尼科尔斯一直在物联网领域从事诱饵工作，试图表达

1163
01:27:05,480 --> 01:27:10,320
好的，一个家可以是一个自主安全的环境，那么如何实现呢？

1164
01:27:10,320 --> 01:27:12,480
我们如何开始实施呢？

1165
01:27:12,480 --> 01:27:13,920
如何使其自动化？

1166
01:27:13,920 --> 01:27:16,639
如何让它在没有人们大量介入的情况下运作？

1167
01:27:18,200 --> 01:27:20,640
她发现NDN和

1168
01:27:20,640 --> 01:27:24,540
它对信任模式的特定理解非常适用。

1169
01:27:24,540 --> 01:27:28,650
所以我认为那里有很多潜力。

1170
01:27:30,160 --> 01:27:34,860
我认为潜力并不在于全球规模的安全架构中，

1171
01:27:34,860 --> 01:27:37,580
因为它们受到的限制实在是太多了，但是。

1172
01:27:38,650 --> 01:27:44,120
我认为在声音安全性方面有巨大的潜力，

1173
01:27:44,120 --> 01:27:49,772
信任架构可以使用构建模块来实现相当自动化的方式。

1174
01:27:54,226 --> 01:27:58,050
>> 并不清楚Van是否不同意我的观点。

1175
01:27:58,050 --> 01:28:04,414
>> 是的，我当然同意这个观点的回答

1176
01:28:04,414 --> 01:28:08,560
>> 回顾时间，而且现在

1177
01:28:14,489 --> 01:28:20,601
而且现在，当人们开始关注下一步时，我们处于何处？

1178
01:28:21,980 --> 01:28:27,580
让我们快速进行第二轮，在中间切换到幻灯片序列。

1179
01:28:27,580 --> 01:28:32,830
在哪里提出了问题，在哪里我们可以改进。

1180
01:28:32,830 --> 01:28:37,800
我会保持与专家嘉宾的顺序，并且我想邀请Van

1181
01:28:38,800 --> 01:28:42,948
来扩展他发给我的那条信息。

1182
01:28:42,948 --> 01:28:48,397
>> 嗨，正如我浏览那一百

1183
01:28:48,397 --> 01:28:53,505
千行的C++代码，那表示着

1184
01:28:53,505 --> 01:28:58,787
代表了NDN cxx库和

1185
01:28:58,787 --> 01:29:02,895
NFD即转发守护进程。

1186
01:29:05,514 --> 01:29:10,146
我看到的是一堆基本上在复制的代码

1187
01:29:10,146 --> 01:29:15,156
IP在这个功能上试图让NDN成为互联网的实现载体。

1188
01:29:15,156 --> 01:29:18,860
互联网的实现载体。

1189
01:29:21,010 --> 01:29:28,067
Cxx_library 中有两到三个版本的 TCP 拥塞控制。

1190
01:29:28,067 --> 01:29:32,823
好的，但是这

1191
01:29:32,823 --> 01:29:39,930
你谈到的精彩事物

1192
01:29:39,930 --> 01:29:45,461
增加服务于一个巨大的未探索问题领域。

1193
01:29:45,461 --> 01:29:51,640
在那里迫切需要一种不同的做事方式。

1194
01:29:51,640 --> 01:29:56,450
因为IP模式并不是一种很好的做事方式，

1195
01:29:56,450 --> 01:30:00,540
基于协议和广播分发的事物。

1196
01:30:02,800 --> 01:30:07,566
关于基础数据的事物。

1197
01:30:07,566 --> 01:30:12,112
不涉及各方之间的对话，

1198
01:30:16,658 --> 01:30:21,565
我感觉平衡有些不对劲，但还没有，

1199
01:30:25,757 --> 01:30:31,960
研究是由足够的应用需求所驱动的。

1200
01:30:31,960 --> 01:30:39,410
相反，研究在很大程度上是研究人员舒适区内的内容。

1201
01:30:39,410 --> 01:30:44,008
很好，我有很多相关经验，我想应用NDN并且

1202
01:30:44,008 --> 01:30:47,620
看看NDN如何影响域间路由。

1203
01:30:49,390 --> 01:30:56,735
好的，但是通信工具就像NDN这样的或者

1204
01:30:56,735 --> 01:31:01,412
IP是一个解决问题的工具。

1205
01:31:01,412 --> 01:31:07,080
它本身并不是自给自足的，它的价值在于

1206
01:31:07,080 --> 01:31:12,700
它如何帮助人们解决问题，创造新事物。

1207
01:31:12,700 --> 01:31:18,330
特别是在开始的时候，你的注意力似乎应该是可以的，

1208
01:31:18,330 --> 01:31:20,490
谁会愿意冒险尝试使用这个？

1209
01:31:20,490 --> 01:31:23,420
就像杰夫·伯克很早之前报名时说的，嘿，

1210
01:31:23,420 --> 01:31:26,380
这会非常痛苦，因为那里什么都没有。

1211
01:31:26,380 --> 01:31:29,390
我们不知道什么会奏效，但有很多错误的开始。

1212
01:31:29,390 --> 01:31:31,430
这是个差距，但这个想法真的很吸引人。

1213
01:31:31,430 --> 01:31:33,150
所以我会接受这份痛苦。

1214
01:31:34,240 --> 01:31:41,110
它已经足够成熟，因此痛苦会减少，想象一下这次会议。

1215
01:31:41,110 --> 01:31:45,940
很多人对使用它来解决问题感兴趣，但是

1216
01:31:45,940 --> 01:31:49,630
他们必须建立的基础，

1217
01:31:49,630 --> 01:31:52,680
我认为它远没有达到它本可以达到的水平。

1218
01:31:52,680 --> 01:31:57,100
因为它更多地关注内部，而不是向外关注，好的，

1219
01:31:57,100 --> 01:31:59,470
为用户做什么是正确的？

1220
01:31:59,470 --> 01:32:01,370
我们如何能让事情变得简单？

1221
01:32:01,370 --> 01:32:04,140
想要在这个框架上开发应用程序的人？

1222
01:32:07,260 --> 01:32:10,330
我的感觉是

1223
01:32:13,080 --> 01:32:18,570
导致了双方错失了许多机会，

1224
01:32:18,570 --> 01:32:24,500
导致了双方错失了许多机会，研究人员在拓展他们的视野和舒适区方面有所欠缺。And the application developers in not having a usable,

1225
01:32:24,500 --> 01:32:29,970
导致应用程序开发者没有一个可用的，

1226
01:32:29,970 --> 01:32:33,510
导致应用程序开发者没有一个可用的工具，他们可以将其视为一个有用的想法，但是在10年的发展中，可用性并没有达到我的预期。

1227
01:32:33,510 --> 01:32:39,090
导致应用程序开发者没有一个可用的工具，他们可以将其视为一个有用的想法，但是在10年的发展中，可用性并没有达到我的预期。Stop there.

1228
01:32:40,240 --> 01:32:40,840
停在那里。

1229
01:32:47,091 --> 01:32:51,920
>> 好的，抱歉我好像失去了连接。

1230
01:32:51,920 --> 01:32:57,410
谢谢，我明白了NFD的主题。

1231
01:32:57,410 --> 01:33:02,680
也许我们可以共同承担这个任务。

1232
01:33:02,680 --> 01:33:07,741
我可能会接手，但是，

1233
01:33:13,729 --> 01:33:16,420
我猜，克里斯汀，我应该继续吗？

1234
01:33:17,840 --> 01:33:19,550
>> 我认为你应该继续。

1235
01:33:19,550 --> 01:33:22,160
>> 继续吧。 >> 所以和之前一样的要点，所以

1236
01:33:22,160 --> 01:33:26,770
也许我可以就在哪些方面可以改进做一些讨论，

1237
01:33:26,770 --> 01:33:29,230
我同意Van所说的话。

1238
01:33:29,230 --> 01:33:32,385
也许在这里，先生。

1239
01:33:32,385 --> 01:33:37,059
豆子，>> 是的。

1240
01:33:37,059 --> 01:33:40,320
>> 好的，还有

1241
01:33:40,320 --> 01:33:45,590
当然，易用性在两个不同方面会大有裨益。

1242
01:33:45,590 --> 01:33:49,200
一方面，当然是在应用层进行实验的行为。

1243
01:33:49,200 --> 01:33:53,620
但这也是我们最近从ICR学到的东西。

1244
01:33:53,620 --> 01:33:58,780
能够将简单的应用程序投入使用

1245
01:33:58,780 --> 01:34:04,010
在具有挑战性的网络环境中，IP部署可能会遇到困难。

1246
01:34:04,010 --> 01:34:09,300
在这样一个困难的事情上，它需要相当的努力来维持。

1247
01:34:09,300 --> 01:34:15,260
一个合理的NDN网络基础设施用于测试应用程序。

1248
01:34:15,260 --> 01:34:18,450
因此，这意味着部分的健壮性和 robustness and ~!@#$%^&*()

1249
01:34:18,450 --> 01:34:22,570
尤其是使用多个，即便是像这样简单的事物。

1250
01:34:22,570 --> 01:34:26,850
使用多个接口在生产者中实施冗余。

1251
01:34:26,850 --> 01:34:31,410
以及那些事情很难做到，因此既要考虑到应用程序的使用便捷性，也要考虑到在使用方面的简便性。

1252
01:34:31,410 --> 01:34:34,450
操作方面的使用便利。

1253
01:34:34,450 --> 01:34:37,775
在充满挑战的情况下部署，NDN应该表现良好。

1254
01:34:37,775 --> 01:34:43,090
即使是我们已经拥有的非常简单的应用程序，

1255
01:34:43,090 --> 01:34:45,940
所以那是我认为的两个需要改进的领域。

1256
01:34:45,940 --> 01:34:51,120
我认为在对话的某些部分，感觉我们还在围绕着某个话题打转。

1257
01:34:51,120 --> 01:34:57,030
网络转发作为对话中的关键部分之一。

1258
01:34:57,030 --> 01:34:57,992
而且我也认为，

1259
01:34:57,992 --> 01:35:02,954
Missha我认为之前在其他场合的对话中提到过这个。

1260
01:35:02,954 --> 01:35:08,810
我们可能忽略了集成存储工作的一些关键性。

1261
01:35:08,810 --> 01:35:12,640
我们试图理解至少从应用程序的角度交叉应用之间的联系。

1262
01:35:12,640 --> 01:35:14,020
开发者的视角。

1263
01:35:14,020 --> 01:35:18,490
网络问题与数据库问题之间的交叉点。

1264
01:35:18,490 --> 01:35:22,820
解决存储问题的一种方法，就是尝试弄清楚如何

1265
01:35:22,820 --> 01:35:30,210
设计应用程序以充分利用底层的数据中心架构。

1266
01:35:30,210 --> 01:35:33,700
所以我希望至少在加州大学洛杉矶分校，

1267
01:35:33,700 --> 01:35:36,410
所以我希望我们的一些研究能够最终回到这一点。

1268
01:35:36,410 --> 01:35:39,570
所以那些只是我认为可以改进的几个方面。

1269
01:35:42,970 --> 01:35:43,600
>> 谢谢你，杰夫。

1270
01:35:43,600 --> 01:35:48,460
抱歉把你的幻灯片搞错了。

1271
01:35:48,460 --> 01:35:50,530
下一个轮到的将是Dave和……

1272
01:35:50,530 --> 01:35:54,540
这里我提取了一行，并不是真正需要改进之处。

1273
01:35:54,540 --> 01:35:59,333
但我认为你已经想要开始自己选一个话题来深入研究了。

1274
01:35:59,333 --> 01:36:03,885
在讨论哪些方面可以改进时，请说说你的看法，戴夫。

1275
01:36:06,636 --> 01:36:10,950
嗯，我想回应一下这里的一些人所说的话，因为，

1276
01:36:12,370 --> 01:36:19,020
大约在1995年，我突然冷静地意识到

1277
01:36:19,020 --> 01:36:23,976
关于互联网的未来，那并不是技术在塑造未来。

1278
01:36:23,976 --> 01:36:29,420
是经济学，是投资决策。

1279
01:36:29,420 --> 01:36:33,430
这是生态系统中不同参与者的角色。

1280
01:36:33,430 --> 01:36:35,220
这是在塑造互联网的未来。

1281
01:36:36,530 --> 01:36:42,210
我想再次发挥出Spanng和Jeff还有其他人所说的内容。

1282
01:36:43,420 --> 01:36:48,540
您在尝试建立时面临的挑战之一是

1283
01:36:48,540 --> 01:36:52,940
您在家中建立网络时面临的问题是多大程度上您依赖于不受您控制的资源。

1284
01:36:52,940 --> 01:36:55,730
您依赖于不受您控制的资源的程度有多大。

1285
01:36:57,180 --> 01:37:02,500
我们确实在那里面临一个问题，大多数消费者并不具备将Linux系统导入他们家中或者在服务器上的资格。

1286
01:37:02,500 --> 01:37:06,720
并不具备将Linux系统导入他们家中或者在服务器上的资格。

1287
01:37:06,720 --> 01:37:07,280
实际上，

1288
01:37:07,280 --> 01:37:12,510
实际上，拥有在云端运行服务的能力非常吸引人，直到当然，

1289
01:37:12,510 --> 01:37:15,990
你被从云端切断，然后你发现你的猫锁上了你的前门。

1290
01:37:17,200 --> 01:37:22,100
我认为我们在全球互联网中所面临的紧张局势

1291
01:37:22,100 --> 01:37:25,450
是意识到你身处一个生态系统中，你必须接受

1292
01:37:25,450 --> 01:37:28,590
事实上，那里有些参与者的动机与你的不一致。

1293
01:37:29,750 --> 01:37:30,720
因此

1294
01:37:30,720 --> 01:37:35,145
因此，委派角色时你需要非常谨慎地考虑一个问题：这个角色扮演什么作用。

1295
01:37:35,145 --> 01:37:40,730
杰夫刚刚谈论了存储，而你不能在网络中谈论存储，

1296
01:37:40,730 --> 01:37:45,000
那句话不在上面，我想弄清楚那句话的意思。

1297
01:37:46,800 --> 01:37:50,610
因为我不同程度地信任网络中的所有元素。

1298
01:37:50,610 --> 01:37:55,110
我不准备只讨论统一架构的存储。

1299
01:37:57,270 --> 01:38:01,020
我认为Vance关于信任的评论非常准确。

1300
01:38:01,020 --> 01:38:04,560
在网络中事情发生的地方必须与它们被信任的地方以及谁持有信任有关。

1301
01:38:04,560 --> 01:38:09,700
在网络中事情发生的地方必须与它们被信任的地方以及谁持有信任有关。

1302
01:38:09,700 --> 01:38:12,940
我在这里持有一种非常边缘中心的观点。

1303
01:38:12,940 --> 01:38:16,600
让我这样说，信任应该来源于用户，

1304
01:38:16,600 --> 01:38:20,580
那就是说，如果我愿意信任谷歌的话，嗯，

1305
01:38:20,580 --> 01:38:23,780
这是我的决定，并不意味着你必须信任谷歌。

1306
01:38:23,780 --> 01:38:27,330
我不想要某个高高在上的人告诉我去信任谷歌，或者是

1307
01:38:27,330 --> 01:38:30,580
信任康卡斯特，因为康卡斯特是我的服务提供商。

1308
01:38:30,580 --> 01:38:32,380
现在，这就是这里的紧张关系，

1309
01:38:32,380 --> 01:38:36,520
我别无选择，只能用康卡斯特作为我的服务提供商。

1310
01:38:36,520 --> 01:38:40,140
因为我别无选择，我想尽量减少信任。

1311
01:38:40,140 --> 01:38:41,120
这实际上是说，

1312
01:38:41,120 --> 01:38:46,820
也许我不希望康卡斯特在我想要的架构中做某些事情。

1313
01:38:46,820 --> 01:38:51,410
为了尽量减少他们的作用，正是因为我不得不使用他们，而我又不信任他们。

1314
01:38:51,410 --> 01:38:55,180
我不需要信任他们，我想尽量减少我的信任。

1315
01:38:55,180 --> 01:39:01,430
一旦你开始考虑基于信任的功能定位，

1316
01:39:01,430 --> 01:39:07,510
我认为你可能会发现你想要重新组织一些你的想法。

1317
01:39:07,510 --> 01:39:10,966
我本来还想说其他几件事，但我只是简单提一下因为我

1318
01:39:10,966 --> 01:39:13,340
我不想在这里耗尽时间。

1319
01:39:13,340 --> 01:39:16,270
所有的想法一旦变为现实，就会变得复杂。

1320
01:39:16,270 --> 01:39:20,710
我们必须面对这样一个事实，即其中一个考验是

1321
01:39:20,710 --> 01:39:25,130
我们必须面对这样一个事实，即其中一个考验是一个架构能够如何有效地应对成功的复杂性。显然我会说互联网已经发展出高度的复杂性。

1322
01:39:25,130 --> 01:39:29,840
显然我会说互联网已经发展出高度的复杂性。

1323
01:39:29,840 --> 01:39:32,300
在某些情况下，它是强大的。

1324
01:39:32,300 --> 01:39:35,210
在某些情况下，它是无比烦人的。

1325
01:39:35,210 --> 01:39:38,690
我想回到这个关于路由器中的状态力量的观点，

1326
01:39:38,690 --> 01:39:42,950
我认为这是一个尚未被完全利用的想法。

1327
01:39:44,790 --> 01:39:48,500
当然，我们知道信息中心网络困难之处在于什么，

1328
01:39:48,500 --> 01:39:50,880
信息中心路由。

1329
01:39:50,880 --> 01:39:55,700
我认为这里存在一个根本的挑战，这也同样关联到

1330
01:39:55,700 --> 01:40:00,780
我有多么想告诉网络的不同部分我正在做什么。

1331
01:40:00,780 --> 01:40:04,630
我一直有这个潜在的担忧。

1332
01:40:04,630 --> 01:40:06,500
而且，我和Vance又一次意见不合。

1333
01:40:06,500 --> 01:40:13,130
我一直有这样一个隐约的担忧，也许我会这样，我不想要所有

1334
01:40:13,130 --> 01:40:17,490
我一直有这样一个隐约的担忧，也许我会这样，我不想要所有的网络我正在使用都知道我检索的所有信息的名字。And that's not a technical comment about trust and balance of power.

1335
01:40:18,740 --> 01:40:24,020
这并不是关于信任和权力平衡的技术性评论。

1336
01:40:24,020 --> 01:40:27,780
这实际上是一个维度，

1337
01:40:27,780 --> 01:40:32,160
很多计算机科学家没有受过良好的训练去深入思考。

1338
01:40:32,160 --> 01:40:36,110
所以这是另一个强制功能，我认为它变得越来越……

1339
01:40:37,220 --> 01:40:42,630
对我们来说至关重要，因为网络变得越来越成为社会的中心部分。

1340
01:40:42,630 --> 01:40:46,219
这些就是我对我们应该做什么的想法。

1341
01:40:46,219 --> 01:40:49,065
这也可能是我给出的“棕色三号”答案。

1342
01:40:50,937 --> 01:40:55,350
>> 所以，我当然是来自国家科学基金会（NSF），因此我有国家科学基金会的视角。

1343
01:40:55,350 --> 01:41:02,785
我一直非常关心神经退行性疾病（NDM）团队的资金问题。

1344
01:41:02,785 --> 01:41:10,280
因此，项目越大，你需要的人手就越多，需要的资金也就越多。

1345
01:41:10,280 --> 01:41:15,810
它还我认为从研究延伸到开发再到部署。

1346
01:41:15,810 --> 01:41:22,130
从美国国家科学基金会的角度来看，研究的起点和终点在哪里？

1347
01:41:22,130 --> 01:41:24,400
如果是研究，它还具有创新性吗？

1348
01:41:25,770 --> 01:41:31,670
研究社区在审查提案时是否能够看到

1349
01:41:33,470 --> 01:41:38,670
挑战并理解NDN所面临的挑战。

1350
01:41:38,670 --> 01:41:41,190
而不仅仅是说，嗯，IP已经解决了这个问题。

1351
01:41:41,190 --> 01:41:42,850
你在做什么？

1352
01:41:42,850 --> 01:41:44,137
因为这个问题已经解决了。

1353
01:41:44,137 --> 01:41:45,792
我认为这里有很多问题。

1354
01:41:45,792 --> 01:41:48,410
其他资金来源将会有不同的顾虑。

1355
01:41:48,410 --> 01:41:53,087
但我认为，这只是一个关于如何筹集资金的问题，其他资金来源将会有不同的顾虑。继续资助像那样的大型项目。

1356
01:41:53,087 --> 01:41:56,773
继续资助像那样的大型项目。

1357
01:41:56,773 --> 01:42:01,848
我认为另一个重大挑战是推广这个最终概念并继续资助像那样的大型项目，使其对广泛的用户群体都有用并且易于使用。

1358
01:42:01,848 --> 01:42:06,840
将其使用推广到广泛的用户群体，并使其易于使用。

1359
01:42:06,840 --> 01:42:08,640
这之前已经被提出过了。

1360
01:42:08,640 --> 01:42:12,980
我认为其他人已经指出了，我想我同意，在边缘或内部使用比试图接管整个互联网更有前途。

1361
01:42:12,980 --> 01:42:17,770
一个企业在边缘或内部使用比试图接管整个互联网更有前途。

1362
01:42:17,770 --> 01:42:20,330
但即便如此，即使这些都具有挑战性。

1363
01:42:20,330 --> 01:42:24,390
我认为第三个挑战是管理过渡期，因为情境已经改变，

1364
01:42:24,390 --> 01:42:28,390
管理过渡期是因为情境已经改变，

1365
01:42:28,390 --> 01:42:33,770
专业知识可能会变化，资金可能会变化，资源来源等等。

1366
01:42:33,770 --> 01:42:39,260
随着NDN从……转变过程中，我有一个问题是

1367
01:42:39,260 --> 01:42:45,100
在NDN开发和研究项目投入使用和社区过程中，如何

1368
01:42:46,510 --> 01:42:52,280
在NDN开发和研究项目投入使用和社区过程中，如何创建一个共有的NDN基础呢？或者你只是让百花齐放，独立成长，这样可以吗？

1369
01:42:52,280 --> 01:42:56,410
还是你只是让百花齐放，独立成长，这样可以吗？

1370
01:42:56,410 --> 01:42:58,450
这将是一个未来的挑战吗？

1371
01:42:58,450 --> 01:42:59,710
然后最后，

1372
01:42:59,710 --> 01:43:05,860
因为我最初对FIA的兴趣在于支持一个安全的互联网。

1373
01:43:05,860 --> 01:43:10,470
除了设计之外还有什么问题吗？

1374
01:43:10,470 --> 01:43:14,098
除了设计上的安全保障，实现上也有安全保障吗？

1375
01:43:14,098 --> 01:43:20,370
NDN团队是否使用形式化验证方法？

1376
01:43:20,370 --> 01:43:24,720
其他方法有助于创建更可靠和安全的产品基础设施代码集等。

1377
01:43:24,720 --> 01:43:29,930
安全的产品基础设施代码集等。

1378
01:43:29,930 --> 01:43:35,470
我们是否需要对新的NDN安全风险进行更多的研究？

1379
01:43:35,470 --> 01:43:37,830
所以我不知道这些问题的答案，但是

1380
01:43:37,830 --> 01:43:41,520
这些是我对未来提出的一些问题。

1381
01:43:41,520 --> 01:43:46,950
>> 那么，如果我要总结我对我们认为在哪里可以改进的立场，那就是简单地说我们需要一个成功的案例。

1382
01:43:46,950 --> 01:43:52,630
要说我们在哪里可以改进，那就是简单地说我们需要一个成功的案例。

1383
01:43:52,630 --> 01:43:58,116
我们需要NDN从头到尾解决一个问题，

1384
01:43:58,116 --> 01:44:04,120
被采纳，拥有我们圈子之外的用户。

1385
01:44:04,120 --> 01:44:09,450
并做一些被普遍认为有用的事情。

1386
01:44:11,160 --> 01:44:17,182
我认为这将大有助于帮助其他人理解。

1387
01:44:17,182 --> 01:44:22,922
NDN实际上可以发挥作用，可以用于生产等方面。

1388
01:44:22,922 --> 01:44:25,740
我认为那是可能发生的。

1389
01:44:26,940 --> 01:44:32,410
我们开始与研究气候和环境问题的用户合作，

1390
01:44:32,410 --> 01:44:34,780
物理学和基因组学，我认为这很棒。

1391
01:44:34,780 --> 01:44:37,250
我认为这应该继续下去。

1392
01:44:38,280 --> 01:44:43,680
我真的很想看到它们能产出一些有用的东西。

1393
01:44:43,680 --> 01:44:47,702
而我所说的有用，是指科学家们会使用的东西。

1394
01:44:47,702 --> 01:44:52,890
然后实际上转过身来说，是的，这帮助我改进了我的研究。

1395
01:44:54,450 --> 01:45:00,480
我最近在关注的另一个领域，绝对没有任何保证我们会成功，是汽车部分。

1396
01:45:00,480 --> 01:45:05,940
我们会成功没有任何保证的另一个领域是汽车部分。

1397
01:45:05,940 --> 01:45:10,913
然后我看到的是一个迅速发展变化的行业。

1398
01:45:10,913 --> 01:45:15,497
根据我们的标准将是网络连接

1399
01:45:15,497 --> 01:45:19,706
According to our standards, it will be a network connection, the Dark Ages the limbus, the canvas and so forth. Through automotive Ethernet into a world where...

1400
01:45:19,706 --> 01:45:22,979
通过汽车以太网进入一个世界，在那里……

1401
01:45:22,979 --> 01:45:27,654
所有的互联网技术现在对他们来说都变得可访问了。

1402
01:45:27,654 --> 01:45:29,051
我的意思是，他们在讨论安全问题。

1403
01:45:29,051 --> 01:45:34,872
他们在讨论使用VLAN来保护他们的设备。

1404
01:45:34,872 --> 01:45:40,254
他们已经从汽车内部相互连接的小世界迈进，

1405
01:45:40,254 --> 01:45:44,828
向车内数十个电子控制单元(ECU)以及通过连接的车辆

1406
01:45:44,828 --> 01:45:49,872
通过基础设施，实际上是连接了世界的其他部分。

1407
01:45:49,872 --> 01:45:53,200
这是一个巨大的飞跃。

1408
01:45:53,200 --> 01:45:59,040
我的印象是他们希望互联网技术能够到位，并且准备好帮助他们解决他们所面临的一些大问题。

1409
01:45:59,040 --> 01:46:06,980
他们准备好帮助他们解决他们所面临的一些大问题。

1410
01:46:06,980 --> 01:46:12,460
但我怀疑，正如我们所发现的那样，问题

1411
01:46:12,460 --> 01:46:17,110
在互联网上，他们很快就会发现互联网技术，

1412
01:46:17,110 --> 01:46:22,690
他们所看重的可能并不像他们最初认为的那么美好。

1413
01:46:22,690 --> 01:46:29,122
我希望能和NDN一起在他们意识到这一点时给予他们支持。

1414
01:46:29,122 --> 01:46:31,140
再说一次，这可能会彻底失败。

1415
01:46:31,140 --> 01:46:34,530
我不知道这是否会成功，

1416
01:46:34,530 --> 01:46:37,050
汽车行业非常保守。

1417
01:46:37,050 --> 01:46:39,610
它非常注重标准。

1418
01:46:39,610 --> 01:46:45,371
他们不会做没有经过非常好的审核的事情。

1419
01:46:45,371 --> 01:46:48,280
但另一方面，他们是一个竞争非常激烈的行业。

1420
01:46:48,280 --> 01:46:54,910
他们正在寻找方法以保持在竞争的前列。

1421
01:46:54,910 --> 01:46:59,783
我希望我们能从他们那里得到的反应是某种

1422
01:46:59,783 --> 01:47:04,568
的反应是类似于当科学家们看到NDN时我们从他们那里得到的反应。

1423
01:47:04,568 --> 01:47:07,866
他们说，我想要这个，我必须得到这个。

1424
01:47:07,866 --> 01:47:10,654
这将会帮助我。

1425
01:47:10,654 --> 01:47:14,870
所以结果还没有出来，我们拭目以待。

1426
01:47:14,870 --> 01:47:19,533
但总结来说，我认为我们需要的是成功案例。

1427
01:47:19,533 --> 01:47:22,079
我认为我们应该尝试多个地方。

1428
01:47:24,080 --> 01:47:26,070
我们正在尝试健康领域，我们正在尝试气候领域，

1429
01:47:26,070 --> 01:47:28,670
我们正在尝试汽车领域，我们还在尝试其他事物。

1430
01:47:29,800 --> 01:47:34,700
但我们需要继续尝试，并且希望能让自己达到一个境界，

1431
01:47:34,700 --> 01:47:38,560
我们确实有一个成功的案例可以指出来，感谢。

1432
01:47:39,970 --> 01:47:46,942
所以我认为我写了三点可以改进的地方。

1433
01:47:46,942 --> 01:47:54,764
一个是更加实用的应用程序和工具。

1434
01:47:54,764 --> 01:48:00,239
我认为这与之前的专家小组成员所讨论的内容是一致的。

1435
01:48:02,268 --> 01:48:08,250
所以我认为其中一个问题是我们

1436
01:48:08,250 --> 01:48:12,150
放弃了一些应用程序或

1437
01:48:12,150 --> 01:48:17,470
我们自己开发的工具却没有维护它们。

1438
01:48:17,470 --> 01:48:22,990
这是我们今后需要解决的一个问题。

1439
01:48:22,990 --> 01:48:27,897
所以，每当我们更新库的时候，我们需要更新

1440
01:48:27,897 --> 01:48:33,030
应用程序，确保它们仍能正常工作。

1441
01:48:33,030 --> 01:48:38,509
并且倾听用户的意见，并根据他们的要求进行修改。

1442
01:48:38,509 --> 01:48:44,610
根据他们的要求进行修改。

1443
01:48:44,610 --> 01:48:49,910
所以我认为，对于一个研究团队来说，这是一项繁重的工作。

1444
01:48:49,910 --> 01:48:54,144
我们至少在资金方面并不是这样的，

1445
01:48:54,144 --> 01:49:00,424
大部分情况下，它并不是用来支持维护或

1446
01:49:00,424 --> 01:49:05,401
功能在工具或应用程序中。

1447
01:49:05,401 --> 01:49:10,696
但我认为为了可用性，为了维护一个社区，

1448
01:49:10,696 --> 01:49:15,244
我们必须这样做，那是我们的责任。

1449
01:49:15,244 --> 01:49:20,353
这是我们今后必须坚持的事情。

1450
01:49:20,353 --> 01:49:28,669
第二个是，让我实际上看看，

1451
01:49:31,623 --> 01:49:35,960
更多的无线和移动支持。

1452
01:49:35,960 --> 01:49:44,624
而这方面已经缺乏了一段时间，我认为。

1453
01:49:44,624 --> 01:49:48,935
我认为我们大多数人本来不是

1454
01:49:48,935 --> 01:49:54,404
研究者在无线移动领域。

1455
01:49:54,404 --> 01:50:02,070
所以我们更习惯于在有线环境中进行研究。

1456
01:50:02,070 --> 01:50:04,950
但我认为很多应用程序

1457
01:50:04,950 --> 01:50:12,990
是更倾向于边缘计算的。

1458
01:50:12,990 --> 01:50:15,730
他们需要无线和移动支持。

1459
01:50:15,730 --> 01:50:21,140
所以那是我们真的必须专注于下一个阶段如果我们真的想要

1460
01:50:21,140 --> 01:50:26,230
进入下一个阶段如果我们真的想要

1461
01:50:26,230 --> 01:50:33,260
拥有一个成功的应用程序，许多终端用户将会采用。

1462
01:50:34,550 --> 01:50:36,970
所以那是第二点。

1463
01:50:36,970 --> 01:50:44,100
第三点是更多地运行代码，而不仅仅是论文或模拟中的设计。

1464
01:50:44,100 --> 01:50:49,920
但这是我认为PI（主要研究员）和指导教师需要注意的事情。

1465
01:50:53,100 --> 01:51:01,260
学生们肯定需要发表文章以便毕业和找工作。

1466
01:51:01,260 --> 01:51:03,921
我们还需要发表论文来获取资金。

1467
01:51:03,921 --> 01:51:09,554
但为了拥有这样的架构

1468
01:51:09,554 --> 01:51:16,953
被社区采纳，我们需要运行的代码。

1469
01:51:16,953 --> 01:51:24,290
就像IETF一样，我们有RFC加上运行的代码，我们也需要这些。

1470
01:51:24,290 --> 01:51:30,375
所以我认为在早期的一个NDN会议中，

1471
01:51:30,375 --> 01:51:35,404
我之前说过，研究生毕业之前，

1472
01:51:35,404 --> 01:51:42,833
他们需要完成在NFT或库中的实现。

1473
01:51:42,833 --> 01:51:45,520
所以我猜这更多是针对顾问的。

1474
01:51:45,520 --> 01:51:52,420
他们需要牢记，运行中的代码和发表出来的成果同样重要。

1475
01:51:54,730 --> 01:51:59,460
这是我希望能够改进的三个愿望。

1476
01:51:59,460 --> 01:52:04,230
很多人已经提到了很多观点。

1477
01:52:04,230 --> 01:52:06,140
我将只关注其中一个。

1478
01:52:07,160 --> 01:52:12,576
回到克里斯蒂安给我们的房子比喻，我认为我们可以

1479
01:52:12,576 --> 01:52:18,820
改善的是房子的运作情况和

1480
01:52:18,820 --> 01:52:22,470
提高了这些建筑政策，特别是这些原因之间的接口。

1481
01:52:22,470 --> 01:52:25,377
这样的场合和网络，

1482
01:52:25,377 --> 01:52:31,099
当我们开始这个印度项目时，它是新的互联网架构。

1483
01:52:31,099 --> 01:52:37,540
所以至少包括我在内的很多人都在思考第三层的问题。

1484
01:52:37,540 --> 01:52:42,780
这就像你有了一种新的架构，但是

1485
01:52:42,780 --> 01:52:48,319
实际上，这是一个非常轻描淡写的说法。

1486
01:52:48,319 --> 01:52:55,842
影响或要求包括上层，

1487
01:52:55,842 --> 01:53:01,510
应用程序以及下层的二层和网络媒体。

1488
01:53:01,510 --> 01:53:07,050
否则你就无法完全享受到架构的全部优势，对吧。

1489
01:53:07,050 --> 01:53:07,850
例如，

1490
01:53:07,850 --> 01:53:13,730
你可以在印度网络上进行一些非常简单的翻译操作。

1491
01:53:13,730 --> 01:53:17,680
那么你可能就能够自己运行它，能够获得所有的全部好处，

1492
01:53:18,890 --> 01:53:19,580
那么你可能就能够自己运行它，能够获得所有的全部好处，尽管如此。But when you design network, we're constantly struggle between ~!@#$%^&*()

1493
01:53:19,580 --> 01:53:26,320
但是当你设计网络时，我们不断地在两者之间挣扎，

1494
01:53:26,320 --> 01:53:31,390
在现有的基础设施下，拥有能够相对良好地运作的系统

1495
01:53:33,790 --> 01:53:38,140
现有的互联网基础设施。

1496
01:53:38,140 --> 01:53:42,630
您需要在那些合理的时候努力工作，这样您才能竞争或者

1497
01:53:42,630 --> 01:53:48,446
提供所需的功能的同时也要展示出来。

1498
01:53:48,446 --> 01:53:50,764
Wish applique ~!@#$%^&*() So,

1499
01:53:50,764 --> 01:53:55,220
我认为这些年来经历了很多艰难困苦。

1500
01:53:58,780 --> 01:54:05,660
敢于去做一些真实的或者大胆的事情，并且展望未来，

1501
01:54:05,660 --> 01:54:12,460
我认为我完全同意水晶和其他人所说的，我们需要成功的故事，

1502
01:54:12,460 --> 01:54:17,340
我们需要能够支持任何情况的应用程序。

1503
01:54:17,340 --> 01:54:22,590
我认为我们需要在应用程序设计和网络设计之间进行更多的迭代，

1504
01:54:22,590 --> 01:54:27,600
为了使这种迭代更加有效和频繁。

1505
01:54:27,600 --> 01:54:32,130
我认为那个API作为应用程序和

1506
01:54:32,130 --> 01:54:35,629
我认为那是一个关键部分。

1507
01:54:37,140 --> 01:54:39,860
杰夫·伯克开发的通用名称库，

1508
01:54:39,860 --> 01:54:45,770
我认为这对于这类API来说是一个非常好的基础。

1509
01:54:45,770 --> 01:54:51,570
一旦我们能够详尽地阐述这个API的大部分细节，这将有助于

1510
01:54:51,570 --> 01:54:57,420
用户编写应用程序而无需理解，

1511
01:54:57,420 --> 01:55:02,840
用户只需关注如何操作数据，而无需理解印度的底层细节。

1512
01:55:02,840 --> 01:55:06,280
用户无需担心网络如何支持该操作。

1513
01:55:06,280 --> 01:55:09,540
用户无需担心网络如何支持该操作。

1514
01:55:09,540 --> 01:55:13,480
嘿，我怎样才能更高效地支持这个API呢？

1515
01:55:13,480 --> 01:55:17,350
当然，无论如何，这个API可能需要一些时间。

1516
01:55:17,350 --> 01:55:21,330
但我认为，对我来说，向前看。

1517
01:55:21,330 --> 01:55:23,220
这就是问题所在。

1518
01:55:23,220 --> 01:55:26,090
嗯，在过去，我们本不应该这么早就这么做的。

1519
01:55:26,090 --> 01:55:32,150
但是从现在开始，作为一个团队，我们应该集中精力并彻底解决这个问题，

1520
01:55:32,150 --> 01:55:38,570
以便我们能够允许更多的应用程序被不同的

1521
01:55:38,570 --> 01:55:43,590
用户使用，同时也允许它们随时间发展。

1522
01:55:45,030 --> 01:55:52,899
那么，如果我选择一个具体的立场。

1523
01:55:52,899 --> 01:55:54,316
~!@#$%^&*()

1524
01:55:54,316 --> 01:55:58,139
在房屋的运作和房屋的工程之间。

1525
01:56:02,228 --> 01:56:03,939
~!@#$%^&*()

1526
01:56:03,939 --> 01:56:05,214
好的，请继续。

1527
01:56:08,184 --> 01:56:12,199
>> 我认为接下来的内容是关于休闲的，下一张幻灯片。

1528
01:56:17,800 --> 01:56:21,550
嗯，他把两件事情放在一起了，不过

1529
01:56:21,550 --> 01:56:24,510
让我来说一下我对第二个问题的回答吧，关于

1530
01:56:24,510 --> 01:56:27,610
可以做得更好的真的是第一点。

1531
01:56:27,610 --> 01:56:32,550
这就是我希望我们当初真的是以应用为驱动的架构。

1532
01:56:32,550 --> 01:56:41,100
这就是我们在项目初期所宣称的开发方式。

1533
01:56:41,100 --> 01:56:45,039
然后，这将驱使我们构建更加易用的应用程序。

1534
01:56:46,420 --> 01:56:49,858
为此有一些轻描淡写的话。

1535
01:56:49,858 --> 01:56:54,920
我一直感到高兴，因为我的姓氏是以Z开头的，所以

1536
01:56:54,920 --> 01:56:57,180
并最终成为最后一个。

1537
01:56:57,180 --> 01:56:59,930
如果事情存在，就按字母顺序划分。

1538
01:56:59,930 --> 01:57:04,080
但是今天在最后一次谈话之后，我真的希望我的姓氏是以A开头的，

1539
01:57:04,080 --> 01:57:08,510
我之后可以去读读，我认为两者都不应该有

1540
01:57:08,510 --> 01:57:12,410
将情况放入正确的时间视角中。

1541
01:57:13,770 --> 01:57:19,560
那时在2010年，我们在未来互联网架构计划下。

1542
01:57:19,560 --> 01:57:24,260
那时候，虽然我们没有说我们做应用程序-driven architecture developments, whether we're under the pressure~!@#$%^&*()

1543
01:57:24,260 --> 01:57:27,600
发展驱动型架构，无论我们是否面临压力

1544
01:57:28,760 --> 01:57:34,380
关于让印度规模化地接入全球互联网。

1545
01:57:34,380 --> 01:57:41,230
我记得我们被所有这些问题轰炸，这怎么可能扩展规模。

1546
01:57:41,230 --> 01:57:46,150
当你每天按克保持状态，

1547
01:57:46,150 --> 01:57:49,950
我认为那是早期努力投入的地方，

1548
01:57:49,950 --> 01:57:55,720
这是对社区关于那些具有挑战性问题的两种回应。

1549
01:57:56,820 --> 01:58:00,810
但是对于铰链网站来说，当然，

1550
01:58:00,810 --> 01:58:05,780
我们本应该完全专注于应用程序开发。

1551
01:58:05,780 --> 01:58:11,260
这实际上会把所有棘手的问题摆到桌面上来。

1552
01:58:11,260 --> 01:58:13,730
例如，安全性，

1553
01:58:13,730 --> 01:58:18,670
当你将可用的应用程序与印第安人的观念结合起来，即安全性必须内建于架构的每一个单独部分的基因中。

1554
01:58:18,670 --> 01:58:23,070
必须内建于架构的每一个单独部分的基因中。

1555
01:58:24,450 --> 01:58:28,960
可用性和安全性，除此之外，我们还得把基础构建块做对，但是

1556
01:58:28,960 --> 01:58:33,970
可用性和安全性，除此之外，我们还得把基础构建块做对，安全的可用性将直接呈现，这是我们必须要解决的问题。

1557
01:58:35,510 --> 01:58:40,350
在可用性和安全性方面，印度人可以轻松提供支持，但是...

1558
01:58:40,350 --> 01:58:43,760
在可用性方面，代码并不到位。

1559
01:58:45,110 --> 01:58:49,350
他们提到了复杂性的情况。

1560
01:58:49,350 --> 01:58:54,430
但是一旦你真正体会到实际应用，我认为杰夫提到了这个很多次实际上会突出显示你如何正确构建架构。

1561
01:58:54,430 --> 01:58:59,640
实际上会突出显示你如何正确构建架构。

1562
01:58:59,640 --> 01:59:05,710
这实际上可以将系统设计简化数个数量级。

1563
01:59:05,710 --> 01:59:06,785
看看今天的互联网。

1564
01:59:06,785 --> 01:59:10,540
广泛的应用从不关心地址。

1565
01:59:10,540 --> 01:59:16,410
这就是为什么人们使用URL或URI而不是直接使用HTTP的原因。

1566
01:59:16,410 --> 01:59:22,030
因为它们寻找的是那个HTTP对象的一部分，而不是注释。

1567
01:59:22,030 --> 01:59:26,000
它与之相连，因为今天的互联网是基于地址来运作的。

1568
01:59:26,000 --> 01:59:32,210
这就产生了所有关于我们如何可能在这种脱节之间的复杂性，

1569
01:59:32,210 --> 01:59:36,250
这就造成了网络实际操作与应用程序需求之间的差异。

1570
01:59:36,250 --> 01:59:40,940
我认为我们应该如何专注于正在构建使用的应用程序。

1571
01:59:40,940 --> 01:59:42,090
应用程序。

1572
01:59:42,090 --> 01:59:45,600
我认为印第安纳的所有这些优势将会再次体现，对吧。

1573
01:59:46,750 --> 01:59:52,310
你可以在桌子上看到关于命名问题的内容，以及……

1574
01:59:52,310 --> 01:59:56,760
再次强调，如果我们专注于应用程序，那么那个问题也可以得到解决。

1575
01:59:57,910 --> 02:00:04,470
如果我们担心隐私问题或者不担心隐私问题，应用程序会告诉我们。

1576
02:00:04,470 --> 02:00:09,430
如果隐私真的成为了根本性的事情，我的意思是，

1577
02:00:09,430 --> 02:00:11,960
如果计算机科学中每个人都知道有这样一句话

1578
02:00:11,960 --> 02:00:15,490
那么一层间接性就能解决所有问题。

1579
02:00:15,490 --> 02:00:17,930
这与语义名称关系不大。

1580
02:00:17,930 --> 02:00:23,690
这是一个错误的选择，因为这样你可能会模珊那个名称。

1581
02:00:23,690 --> 02:00:28,805
你所需要的只是在任何名称之间确保一致的对应关系，

1582
02:00:28,805 --> 02:00:35,830
你希望使用什么名字以及哪些名字会暴露给外人。

1583
02:00:35,830 --> 02:00:39,850
所以，现在我们回来做印度灯饰设计。

1584
02:00:39,850 --> 02:00:41,830
我们实际上已经弄清楚我们该如何做了，对吗？

1585
02:00:42,850 --> 02:00:47,660
使用语义化的名称，但并不以纯文本形式暴露你所讨论的内容。

1586
02:00:49,450 --> 02:00:54,510
~!@#$%^&*()

1587
02:00:54,510 --> 02:00:59,890
想要做架构驱动，我的意思是，应用程序。

1588
02:00:59,890 --> 02:01:04,660
我们必须使应用程序变得简单，以便进行架构驱动的开发。

1589
02:01:04,660 --> 02:01:08,910
我这样做是为了告诉周围的人，我认为杰夫已经听到这个很多次了，即

1590
02:01:08,910 --> 02:01:14,260
我认为杰夫真的是边缘团队的老大，因为他

1591
02:01:14,260 --> 02:01:18,650
一直在告诉我们现在你需要做什么，

1592
02:01:18,650 --> 02:01:22,380
我们只是没有好好听从那些建议。

1593
02:01:22,380 --> 02:01:25,199
我认为在过去的一年左右的时间里

1594
02:01:25,199 --> 02:01:30,039
将会肯定地改变解决问题的方向。

1595
02:01:30,039 --> 02:01:35,299
支持NDN应用开发所面临的挑战。

1596
02:01:37,671 --> 02:01:41,250
Tellagami在那里加上了最后一句话。

1597
02:01:41,250 --> 02:01:47,360
历史实际上充满了许多你可能认为的随机因素。

1598
02:01:47,360 --> 02:01:51,770
是的，实际上可以说那支印度队很幸运，我们只需

1599
02:01:51,770 --> 02:01:58,100
他确实推动了架构设计的进步。

1600
02:01:58,100 --> 02:02:05,070
通过展示应用程序实际关心的真正问题。

1601
02:02:05,070 --> 02:02:06,880
我自己跟杰夫提到了这件事。

1602
02:02:06,880 --> 02:02:10,370
我认为我不知道印度在未来十年里将如何提供帮助，

1603
02:02:10,370 --> 02:02:14,060
我认为我们最终会做正确的事，但可能需要70年。

1604
02:02:14,060 --> 02:02:19,060
可能会因为没有杰夫对团结的看法而花更长的时间。

1605
02:02:19,060 --> 02:02:19,820
这就是我目前要说的全部内容。

1606
02:02:22,720 --> 02:02:24,170
>> 好的，谢谢你，丽莎。

1607
02:02:24,170 --> 02:02:28,830
下一页，请翻到Christian关于第三轮的幻灯片。

1608
02:02:28,830 --> 02:02:34,130
问题是，我们现在在哪里以及结束语？

1609
02:02:34,130 --> 02:02:36,210
开始讲述Van Jacobson。

1610
02:02:42,844 --> 02:02:47,560
我不知道如何回答这个问题，因为它没有唯一的答案。

1611
02:02:53,748 --> 02:02:58,653
不同的人对世界有不同的看法，

1612
02:02:58,653 --> 02:03:03,670
他们根据自己的看法和目标来进行工作。

1613
02:03:08,866 --> 02:03:15,133
越来越多的人对NDN这一理念产生了兴趣，

1614
02:03:15,133 --> 02:03:19,832
它是一个工具包，很多人这么说过。

1615
02:03:19,832 --> 02:03:24,218
需要努力充实这个想法，

1616
02:03:24,218 --> 02:03:30,016
需要努力充实这个想法，使其更加具体、更易于理解，并且

1617
02:03:30,016 --> 02:03:35,027
我认为这个工具包需要相当多的~!@#$%^&*()

1618
02:03:35,027 --> 02:03:40,982
因为它一直是研究用的车辆，所以需要很多工作。

1619
02:03:40,982 --> 02:03:46,020
它包含了许多不同的议程。

1620
02:03:46,020 --> 02:03:52,108
它太过模糊不清，正如莱莎所指出的，

1621
02:03:52,108 --> 02:03:57,884
它最初起源于FIA项目，

1622
02:03:57,884 --> 02:04:04,460
它非常专注于下一代互联网。

1623
02:04:04,460 --> 02:04:08,468
所以它专注于全球规模，

1624
02:04:08,468 --> 02:04:13,307
所以它并不真正是印度的目标，

1625
02:04:13,307 --> 02:04:20,221
互联网在本地规模上做得非常非常好，但是

1626
02:04:20,221 --> 02:04:25,010
它在本地规模上并不是那么好。

1627
02:04:25,010 --> 02:04:30,380
It's not that easy to solve local problems locally on the internet.

1628
02:04:31,610 --> 02:04:36,860
在互联网上，解决本地问题并不容易。

1629
02:04:36,860 --> 02:04:39,772
使用NDN应该很容易。

1630
02:04:39,772 --> 02:04:45,200
但是我们拥有的工具包并不支持它。

1631
02:04:45,200 --> 02:04:46,870
正如Land所指出的。

1632
02:04:46,870 --> 02:04:52,600
无线通信在NFV中已经存在问题好几年了，正如我所发现的。

1633
02:04:52,600 --> 02:05:00,590
在尝试本地使用时，这让我非常懊恼，这种情况有些无法原谅。

1634
02:05:00,590 --> 02:05:05,130
它仍然支持广播模式，但复制单播也是可以的。

1635
02:05:05,130 --> 02:05:06,950
还没有说话。

1636
02:05:06,950 --> 02:05:07,550
对不起。

1637
02:05:08,750 --> 02:05:09,610
你们有收音机。

1638
02:05:09,610 --> 02:05:10,730
它们应该是收音机。

1639
02:05:15,530 --> 02:05:22,670
嘿，我认为他们遇到的一些问题可能是

1640
02:05:22,670 --> 02:05:27,860
他们提出的两个问题都给我留下了深刻印象，因为它们是相关的。

1641
02:05:33,991 --> 02:05:38,269
在你变得庞大时，你会遇到复杂性，因为你拥有许多不同的

1642
02:05:38,269 --> 02:05:41,530
利益，你必须平衡和控制。

1643
02:05:42,880 --> 02:05:46,810
如果你想要功能性高的东西，但是

1644
02:05:46,810 --> 02:05:52,010
它是在全球范围内的你

1645
02:05:52,010 --> 02:05:55,980
不想最终变得只追求高效能意味着你不想成为最低公约数。

1646
02:05:55,980 --> 02:06:00,050
但全球规模意味着你将面临数不清的限制。

1647
02:06:00,050 --> 02:06:07,070
因此，你最终得到的东西并没有达到它本可以实现的那种精细调整的程度。

1648
02:06:08,810 --> 02:06:13,230
所以，最终让你能够在本地规模上做事情。

1649
02:06:13,230 --> 02:06:17,800
并且我们再次尝试在我的房子里进行，也就是我现在所坐的地方，

1650
02:06:17,800 --> 02:06:23,210
我们正在尝试基于一个非常简单的发布/订阅模型来建立物联网系统。

1651
02:06:23,210 --> 02:06:29,690
我们正在通过使用本地信任模式来覆盖印度，这些模式或多或少是自动建立的。

1652
02:06:31,490 --> 02:06:33,650
我认为

1653
02:06:36,950 --> 02:06:40,720
我们在避免陷阱，比如说必须有一个共同的命名空间，

1654
02:06:40,720 --> 02:06:44,780
因为没有，那个命名空间是直接绑定的。

1655
02:06:44,780 --> 02:06:49,350
我生成了搜索来锚定那个命名空间。

1656
02:06:49,350 --> 02:06:53,410
他们从不离开这所房子，我甚至无法取得的签名密钥被深埋在里面。

1657
02:06:53,410 --> 02:06:58,480
一个我无法取出的硬件模块，一个TPM。

1658
02:06:58,480 --> 02:07:04,117
所以只有家里的东西，你才能使用那个命名空间。

1659
02:07:04,117 --> 02:07:08,540
这真的限制了

1660
02:07:08,540 --> 02:07:12,950
你可能会遇到的路由问题，我永远不需要担心这些。

1661
02:07:12,950 --> 02:07:16,470
设备通过互联网路由，因为它们无法连接到互联网。

1662
02:07:16,470 --> 02:07:18,750
他们出不了门。

1663
02:07:18,750 --> 02:07:23,340
在那个命名空间中，能够起作用的事物数量非常有限。

1664
02:07:23,340 --> 02:07:27,120
他们都是通过广播进行交流的，所以他们从不需要路由。

1665
02:07:27,120 --> 02:07:32,000
信息想要上网的唯一途径是通过一个重新发布它的代理。

1666
02:07:32,000 --> 02:07:37,520
信息想要上网的唯一途径是通过一个重新发布它的代理。

1667
02:07:38,660 --> 02:07:41,640
而那个代理是我所拥有的。

1668
02:07:41,640 --> 02:07:46,510
它可以按照我希望的方式过滤信息。

1669
02:07:47,668 --> 02:07:53,900
我会告诉我们的太阳能公司有关我们面板生产的事情，因为他们需要这些信息来……

1670
02:07:53,900 --> 02:07:58,050
我会告诉我们的太阳能公司有关我们面板生产的事情，因为他们需要这些信息来……

1671
02:07:58,050 --> 02:08:03,100
我是负责向他们提供那些信息的人，以便进行维护，但是……

1672
02:08:03,100 --> 02:08:06,920
我的代理人在边境上完成了这项工作，他们无法与我的面板沟通。

1673
02:08:09,870 --> 02:08:11,530
所以，我认为你可以。

1674
02:08:14,059 --> 02:08:18,419
制作可以共同演化的部件，如果你从本地开始，

1675
02:08:18,419 --> 02:08:24,228
解决当地问题，那种解决方案本质上包含了一个边界。

1676
02:08:24,228 --> 02:08:30,410
你有一组名字，你确切地知道谁是社区的成员，

1677
02:08:30,410 --> 02:08:34,710
这样就形成了一个边界，你可以在上面放置代理，它们会说，

1678
02:08:34,710 --> 02:08:38,890
好的，这就是这个社区将如何与外界互动。

1679
02:08:38,890 --> 02:08:45,550
与其他社区或我认为能让你成长的服务提供商互动。

1680
02:08:45,550 --> 02:08:51,870
有序地保护经济利益，但不影响隐私。

1681
02:08:51,870 --> 02:08:54,530
我认为我们在那方面的工作还不够充分，但是

1682
02:08:54,530 --> 02:08:56,010
我认为那里有巨大的潜力。

1683
02:08:57,070 --> 02:08:57,570
停止。

1684
02:08:58,920 --> 02:09:04,090
>> 当然，我认为我们已经谈过了，

1685
02:09:04,090 --> 02:09:09,780
在这个小组讨论中我思考了，还有昨天在社区会议上，关于

1686
02:09:09,780 --> 02:09:14,546
很多不同的应用领域对NDN感兴趣并且看到了其潜力。

1687
02:09:14,546 --> 02:09:18,470
但我认为仅仅是为了增加一个不同的视角或

1688
02:09:18,470 --> 02:09:23,820
不同用户群体的一个好处是我们进行了一些讨论，正如韦恩所暗示的，

1689
02:09:23,820 --> 02:09:28,890
它确实似乎提供了一个很好的机会去改善现有的

1690
02:09:28,890 --> 02:09:34,910
它确实似乎提供了一个很好的机会去改善现有的，对于那些不是工业界人士的人们可用的一系列想法和工具。Who are making smaller interesting experimental projects in the hacker and

1691
02:09:34,910 --> 02:09:39,340
在黑客界和制造者空间中进行小型有趣实验项目的人是……

1692
02:09:39,340 --> 02:09:42,830
教育中的创客空间是……

1693
02:09:42,830 --> 02:09:48,050
基本上是在现有的去中心化工具上进行构建。

1694
02:09:48,050 --> 02:09:53,390
在IPFS领域或DAT中，其他可能的解决方案可能会不兼容NDN的思维方式，但是当你说的时候，它们是兼容的。

1695
02:09:53,390 --> 02:09:57,240
可能与NDN的思维方式不兼容，但是当你说的时候，它们是兼容的。

1696
02:09:57,240 --> 02:10:00,180
我打算开发一个去中心化的应用程序，供人们使用。

1697
02:10:00,180 --> 02:10:04,750
仍然让我感到有些迷惑的是，我们至今还没有

1698
02:10:04,750 --> 02:10:10,630
我们至今还没有能够将NDN定位为那个社区的一个实验工具集。

1699
02:10:10,630 --> 02:10:15,980
我认为最近的另一个例子是，由于远离

1700
02:10:15,980 --> 02:10:20,980
我们的加州大学洛杉矶分校设施由于远离，已经导致它考虑使用ZeroTier和其他解决方案来创建某种虚拟化以太网网络。

1701
02:10:20,980 --> 02:10:24,320
其他解决方案来创建某种虚拟化以太网网络。

1702
02:10:27,820 --> 02:10:29,960
在我们想要使用的系统和设备之间。

1703
02:10:29,960 --> 02:10:33,240
以便于我这一半需要部署事物的自己

1704
02:10:33,240 --> 02:10:37,140
为那些存在的解决方案感到兴奋

1705
02:10:37,140 --> 02:10:43,250
合理部署一些远程和准去中心化应用程序。

1706
02:10:43,250 --> 02:10:49,110
然后我看着NDN的那部分就在想，为什么我们不能传递当前的

1707
02:10:49,110 --> 02:10:54,980
理念，这些可能尚未实施，可能还不适用于某些应用程序。

1708
02:10:54,980 --> 02:10:59,919
希望尝试去中心化应用程序的社区。

1709
02:11:01,030 --> 02:11:03,520
而这确实是一个令人沮丧的境地。

1710
02:11:03,520 --> 02:11:07,770
但它似乎在某种程度上反映了我们现在所处的这个时点，

1711
02:11:07,770 --> 02:11:12,768
它确实有两面性，也许用NDN这个术语来形容并不恰当。

1712
02:11:12,768 --> 02:11:16,500
对于NDN社区和NDN架构来说，它们是面向寻求解决方案的用户的一面，

1713
02:11:16,500 --> 02:11:21,520
对于寻找解决方案的用户而言，它们是一张面孔，

1714
02:11:21,520 --> 02:11:26,350
那么，需要继续推动个体前进的面孔就是~!@#$%^&*()

1715
02:11:26,350 --> 02:11:30,110
这些研究课题的类型是为了使得架构可行且安全。

1716
02:11:30,110 --> 02:11:34,970
我认为那是一个令人兴奋的领域，但我认为两者都有这种类型

1717
02:11:34,970 --> 02:11:39,150
的资金和结构性挑战，这是Darlene早些时候提到的。

1718
02:11:39,150 --> 02:11:43,827
并且投入一些精力去弄清楚如何让这两件事情都动起来。

1719
02:11:43,827 --> 02:11:46,108
既让人望而生畏，又有点令人兴奋。

1720
02:11:49,583 --> 02:11:51,200
>> 谢谢，杰夫。

1721
02:11:51,200 --> 02:11:53,210
戴夫，你对这个问题有什么看法？

1722
02:11:53,210 --> 02:11:53,990
我们现在在哪里？

1723
02:11:55,530 --> 02:11:59,450
>> 我知道我们进度落后了，所以让我尽量快点。

1724
02:11:59,450 --> 02:12:03,280
我完全理解杰夫所说的，他想要去……

1725
02:12:03,280 --> 02:12:06,620
将工具推向黑客制造者社区等等。

1726
02:12:06,620 --> 02:12:11,890
但如果这种架构要成功，

1727
02:12:11,890 --> 02:12:17,740
它必须对那些没有那种技能的人也是可用的。

1728
02:12:17,740 --> 02:12:23,010
他谈到布置他的家时，我在听着，

1729
02:12:23,010 --> 02:12:28,000
我绝对相信范想要拥有的欲望

1730
02:12:28,000 --> 02:12:30,680
边缘中心的解决方案，我一点也不反对。

1731
02:12:30,680 --> 02:12:33,323
但无论他做什么，都必须确保他的母亲也能复制这一做法。

1732
02:12:35,493 --> 02:12:41,006
市场已经了解到，用户乐于使用服务——

1733
02:12:41,006 --> 02:12:46,160
专注于云端，因为这使得它们更易于管理。

1734
02:12:47,330 --> 02:12:51,420
而因此我们失去了很大一部分自主权。

1735
02:12:51,420 --> 02:12:56,540
而实际上，如果你观察用户的行为，他们似乎乐于放弃

1736
02:12:56,540 --> 02:13:01,970
放弃那种自主权，放弃那种控制权，失去对信任结构的控制。

1737
02:13:01,970 --> 02:13:05,060
因为否则他们将面临一个难以管理的情况。

1738
02:13:06,100 --> 02:13:10,990
所以我想说这里有两个主要的挑战。

1739
02:13:10,990 --> 02:13:13,620
其中一个挑战是构建应用程序是一个庞大的任务。

1740
02:13:15,250 --> 02:13:18,720
应用程序的规模比起互联网的复杂性来说，要大得多。

1741
02:13:18,720 --> 02:13:22,660
与大型应用程序的复杂性相比，应用程序的难度要大得多。

1742
02:13:22,660 --> 02:13:26,850
在哪里获取资源，以及承诺去构建应用程序。

1743
02:13:26,850 --> 02:13:30,440
然后第二个就是从一开始就仔细思考。

1744
02:13:30,440 --> 02:13:34,480
系统可用性的问题。

1745
02:13:34,480 --> 02:13:38,440
我认为这几乎是在某种意义上独立存在的一个问题。

1746
02:13:38,440 --> 02:13:39,060
的神经发育网络（NDN）。

1747
02:13:39,060 --> 02:13:41,710
也就是说，我可以问一个完全相同的问题，关于如何连接

1748
02:13:41,710 --> 02:13:44,450
我家与互联网的连接。

1749
02:13:44,450 --> 02:13:47,625
如果NDN让它变得更简单了，那就好了。

1750
02:13:47,625 --> 02:13:50,450
但是证明这一点的是，你可以把这个给一个不知道什么是网络的人，他们可以打开它并使其工作。

1751
02:13:50,450 --> 02:13:52,930
一个网络是什么，他们可以打开它并使其工作。

1752
02:13:52,930 --> 02:13:56,870
我认为这是一个非常重要的未来挑战。

1753
02:13:56,870 --> 02:13:59,109
而且它又大又笨重，

1754
02:13:59,109 --> 02:14:02,775
计算机科学家不喜欢做那种事情。

1755
02:14:06,813 --> 02:14:08,210
>> 达琳，最后有什么想法吗？

1756
02:14:11,454 --> 02:14:16,464
>> 是的，小组讨论中的很多内容都是对我之前听到过的事情的扩展，或者是更多、更清晰的陈述。

1757
02:14:16,464 --> 02:14:22,560
很多内容都是我之前听过的事情的扩展，或者是更多、更清晰的陈述。

1758
02:14:22,560 --> 02:14:26,940
但我之前没有听说过的事情，我很好奇是否……

1759
02:14:26,940 --> 02:14:29,370
你在2010年并不知道这件事。

1760
02:14:29,370 --> 02:14:34,730
这句话的意思是应该专注于应用程序，而不是全局架构，或者专注于更小的细节。

1761
02:14:34,730 --> 02:14:40,127
细节上。

1762
02:14:40,127 --> 02:14:46,600
企业和地点。

1763
02:14:46,600 --> 02:14:50,220
这是你在2010年就知道的事情，还是后来你才意识到的？

1764
02:14:51,230 --> 02:14:52,710
这是我对社区的问题。

1765
02:14:54,090 --> 02:14:56,878
>> 那是我们在2010年就知道的，

1766
02:15:01,435 --> 02:15:05,488
当本在1977年的ICCC上描述互联网时，

1767
02:15:05,488 --> 02:15:10,100
安迪·弗雷泽问道，你是在尝试重新发明电话系统吗？

1768
02:15:10,100 --> 02:15:10,770
Ben 说，不是的，

1769
02:15:10,770 --> 02:15:15,070
那会很愚蠢，我们正试图做电话系统做不到的事情。

1770
02:15:16,090 --> 02:15:21,520
那在我看来是一个极为成功的方法。

1771
02:15:21,520 --> 02:15:26,440
那正是我们在NDN中尝试遵循的原则，通过引入

1772
02:15:26,440 --> 02:15:31,070
在应用中成为了痛点

1773
02:15:31,070 --> 02:15:34,490
的互联网协议应用程序，这些程序并没有被互联网很好地服务。

1774
02:15:34,490 --> 02:15:40,738
因此，这并不是重新发明互联网，而是尝试为那些并没有被互联网很好地服务的互联网协议应用程序发明通信方式。

1775
02:15:40,738 --> 02:15:45,230
因此，这并不是重新发明互联网，而是尝试为那些并没有被互联网很好地服务的事物发明通信方式。

1776
02:15:46,880 --> 02:15:51,806
>> 我不认为那就是我听到你说做应用程序时的意思。

1777
02:15:51,806 --> 02:15:53,970
不做就算了，反正也没关系。

1778
02:15:53,970 --> 02:16:00,029
但我发现这真是一组有趣的评论。

1779
02:16:05,285 --> 02:16:07,910
>> 最后的想法？

1780
02:16:07,910 --> 02:16:09,680
>> 嗯，我会尽量简短。

1781
02:16:09,680 --> 02:16:14,220
所以我认为我们仍然是一个研究项目，并且

1782
02:16:15,990 --> 02:16:19,500
我们需要从一个研究项目转变成

1783
02:16:21,660 --> 02:16:24,150
转变成一些真正能够帮助用户的东西。

1784
02:16:24,150 --> 02:16:28,875
我们正在进行很棒的对话，讨论着

1785
02:16:28,875 --> 02:16:33,749
NDN及其本质和它应有的样子。

1786
02:16:36,280 --> 02:16:41,160
我也希望同时看到，与那些对话并行的是

1787
02:16:41,160 --> 02:16:45,530
正在接触那些真正有问题的人们，

1788
02:16:45,530 --> 02:16:48,810
试图理解他们的问题所在，他们的痛点在哪里。

1789
02:16:48,810 --> 02:16:54,740
然后开始采用NDN的方法来解决这些问题，

1790
02:16:54,740 --> 02:16:58,350
并尝试理解NDN如何解决这些问题。

1791
02:16:58,350 --> 02:17:04,743
我认为这些方法不仅能帮助用户理解NDN，

1792
02:17:04,743 --> 02:17:09,430
但也有助于我们深化对NDN的思考。

1793
02:17:09,430 --> 02:17:14,221
所以我想看到更多这样的内容，谢谢。

1794
02:17:16,361 --> 02:17:17,165
>> 谢谢克里斯托斯。

1795
02:17:17,165 --> 02:17:19,170
Lan，最后一张幻灯片？

1796
02:17:22,770 --> 02:17:27,353
>> 好的，所以我只是借用了这个数据图表来自

1797
02:17:27,353 --> 02:17:32,188
好的，所以我只是借用了这个数据图表来自高德纳去年的研究报告。他们将NDN列为其中一项技术。

1798
02:17:32,188 --> 02:17:37,210
他们将NDN列为其中一项技术，

1799
02:17:37,210 --> 02:17:41,950
他们将NDN列为其中一项技术，所以这意味着它仍然有很好的发展前景。

1800
02:17:44,030 --> 02:17:50,131
这也就意味着它仍然有很好的发展前景。

1801
02:17:50,131 --> 02:17:56,242
这项技术受到了人们的关注。

1802
02:17:56,242 --> 02:18:01,447
我认为那是件好事。

1803
02:18:01,447 --> 02:18:05,430
I think that is a good thing for NDN.

1804
02:18:05,430 --> 02:18:10,894
我认为我们需要，现在是关键阶段，

1805
02:18:10,894 --> 02:18:14,970
我们不想从这个曲线上掉下来。

1806
02:18:16,630 --> 02:18:23,554
我们想要扩大社区并且

1807
02:18:23,554 --> 02:18:27,613
我们想要扩大社区并且让代码易于被其他人使用，所以

1808
02:18:27,613 --> 02:18:33,104
我们想要扩大社区并且让代码易于被其他人使用，所以

1809
02:18:33,104 --> 02:18:39,803
我们要迅速沿着这个曲线向上发展。

1810
02:18:43,565 --> 02:18:48,530
但我认为人们对这项技术仍然有相当大的兴趣。

1811
02:18:48,530 --> 02:18:51,190
我也相信这个方向，并且

1812
02:18:51,190 --> 02:18:55,110
我认为我们所有人都相信这个研究方向。

1813
02:18:55,110 --> 02:19:01,205
我们只是需要确实地定位我们自己

1814
02:19:01,205 --> 02:19:06,430
向应用程序开发者和用户，

1815
02:19:06,430 --> 02:19:12,234
以便我们能够迅速扩大社区并且

1816
02:19:12,234 --> 02:19:17,330
开发一些成功的应用程序。

1817
02:19:18,690 --> 02:19:25,214
希望明年我们能在曲线上更高一些。

1818
02:19:25,214 --> 02:19:27,750
>> 谢谢兰。

1819
02:19:27,750 --> 02:19:29,784
Beichuang, are you the first?

1820
02:19:32,951 --> 02:19:36,371
>> 所以，我认为我们已经有了基本的基础设施。

1821
02:19:36,371 --> 02:19:39,580
未来NDN的发展模式。

1822
02:19:39,580 --> 02:19:46,210
未来的重点，我认为真正与应用程序息息相关，将会

1823
02:19:47,340 --> 02:19:52,493
在探索建筑优势方面要更加大胆。

1824
02:19:54,540 --> 02:19:58,460
所以，我认为这涵盖了相似的要点。

1825
02:19:58,460 --> 02:20:04,054
我们需要一个易于使用且用户友好的API，以便不同的用户能够，

1826
02:20:04,054 --> 02:20:10,054
我们不知道如何使用NDN代码来创建自己的应用程序。

1827
02:20:10,054 --> 02:20:16,950
实际上可以展示或从底层架构中获益。

1828
02:20:16,950 --> 02:20:22,794
我认为那就是需要做的事情，以将NDN推向下一个阶段。

1829
02:20:26,668 --> 02:20:27,290
嗯，就是这样。

1830
02:20:27,290 --> 02:20:29,250
>> 谢谢北川。

1831
02:20:30,390 --> 02:20:35,180
最后但同样重要的是，Lixia，你的最终想法，你将结束这个小组讨论。

1832
02:20:36,480 --> 02:20:38,267
>> 我知道我们的时间不多了，但我确实希望-

1833
02:20:38,267 --> 02:20:39,339
是的。

1834
02:20:39,339 --> 02:20:41,980
>> 在我之后还有一些更多的讨论。

1835
02:20:41,980 --> 02:20:45,859
我也同意北窗的观点，十年之后，

1836
02:20:45,859 --> 02:20:52,130
我认为我们已经建立了基础框架，让更广泛的社区进行探索。

1837
02:20:52,130 --> 02:20:55,810
就像我在这里提到的，我们实际上了解了什么是困难。

1838
02:20:55,810 --> 02:20:59,220
在推进的过程中以及我们应该在哪里施力，那就是所谓的内侧边缘。

1839
02:20:59,220 --> 02:21:04,634
在提到边缘的时候，我真正指的是两种不同的边缘讨论方式。

1840
02:21:04,634 --> 02:21:09,599
您不需要咨询您的ISP即可使用的本地应用程序

1841
02:21:09,599 --> 02:21:12,780
云计算资源丰富的今天，您完全可以自己构建。

1842
02:21:12,780 --> 02:21:18,280
在如今资源丰富的环境中，计算资源，

1843
02:21:18,280 --> 02:21:22,540
带宽和内存都很便宜，而且随处可见。

1844
02:21:22,540 --> 02:21:25,585
问题真的在于我们如何能够最好地利用这一点，

1845
02:21:25,585 --> 02:21:29,920
构建一个非常强大的应用程序，就在你的家里。

1846
02:21:29,920 --> 02:21:33,010
我同意戴夫的观点。

1847
02:21:33,010 --> 02:21:38,600
这个应用程序必须易于使用，比如说我的妈妈就能使用，她今年88岁了，

1848
02:21:38,600 --> 02:21:44,660
这是一个巨大的挑战，但这是一个标准。

1849
02:21:44,660 --> 02:21:51,520
所以，另一个优势是应用程序，这些应用程序可以在任何平台上运行。

1850
02:21:51,520 --> 02:21:54,460
就像IP早期的日子。

1851
02:21:54,460 --> 02:21:59,680
你负责DevOps，你做任何可以传输数据报的事情，

1852
02:21:59,680 --> 02:22:02,440
那么NDN就可以进行通信了。

1853
02:22:02,440 --> 02:22:06,340
那么，我们应该在那里发力。

1854
02:22:06,340 --> 02:22:08,419
我也会给他们最后一个。

1855
02:22:08,419 --> 02:22:13,020
我听到别人的问题，我想澄清几件事情。

1856
02:22:13,020 --> 02:22:18,273
那就像是，现在构建应用程序的基础是任何这些

1857
02:22:18,273 --> 02:22:24,460
它们中的一些可能会自身变成一个巨大的成功。

1858
02:22:24,460 --> 02:22:30,850
但对我们来说，根本的事情是作为架构师，

1859
02:22:30,850 --> 02:22:35,198
是要真正理解什么是有效的，什么是缺失的。

1860
02:22:35,198 --> 02:22:40,460
所以，使用应用程序来推动架构的发展。

1861
02:22:40,460 --> 02:22:46,630
这至少是，我认为团队有兴趣了解的事情有多好

1862
02:22:46,630 --> 02:22:51,620
这基本上是设计实际上支持应用程序并使事情变得更简单。

1863
02:22:53,250 --> 02:22:57,750
但我也同意实用性确实有两个部分，是可以分开的部分。

1864
02:22:57,750 --> 02:22:59,086
设计是其中的一个方面。

1865
02:22:59,086 --> 02:23:04,180
NDN设计应该如何最好地支持应用程序。

1866
02:23:04,180 --> 02:23:08,458
然后另一个挑战是兰提到的，

1867
02:23:08,458 --> 02:23:13,690
代码的可用性、维护和支持。

1868
02:23:13,690 --> 02:23:19,780
这是一个挑战，我认为尽管研究生很聪明，但他们

1869
02:23:19,780 --> 02:23:24,810
并不是提供那个的合适劳动力。

1870
02:23:24,810 --> 02:23:27,708
我认为那仍然是一个挑战。

1871
02:23:32,250 --> 02:23:32,858
>> 谢谢，丽霞。

1872
02:23:32,858 --> 02:23:34,630
我们进度落后了。

1873
02:23:34,630 --> 02:23:38,320
正在聊天中进行着一场有趣的讨论。

1874
02:23:38,320 --> 02:23:42,662
但不幸的是，我认为我们不能回答问题。

1875
02:23:42,662 --> 02:23:47,862
所以如果小组成员有任何最后的想法，或者还有一两分钟的时间。

1876
02:23:51,662 --> 02:23:55,460
那么我们就结束这个小组讨论。

1877
02:23:55,460 --> 02:23:59,170
我们非常感谢所有的小组成员。

1878
02:23:59,170 --> 02:24:02,550
我们应该在1点15分回来。

1879
02:24:02,550 --> 02:24:06,110
我认为我们可以坚持那个时间表，并缩短休息时间。

1880
02:24:06,110 --> 02:24:08,419
那么我们1点15分再见。

1881
02:24:08,419 --> 02:24:09,820
非常感谢。

