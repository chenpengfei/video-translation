1
00:00:00,821 --> 00:00:03,682
好的，欢迎大家回来。

2
00:00:03,682 --> 00:00:07,528
我们下一场讨论的主题是安全性和Mac电脑。

3
00:00:07,528 --> 00:00:11,671
格雷格·帕特里奇是科罗拉多州立大学计算机科学系的教授兼系主任，他将主持这次会议。

4
00:00:11,671 --> 00:00:15,180
科罗拉多州立大学将主持这次会议。

5
00:00:15,180 --> 00:00:18,252
那么我就交给你了，克雷格，请开始吧。

6
00:00:18,252 --> 00:00:19,827
好的，谢谢。

7
00:00:19,827 --> 00:00:25,191
我将立即把它交给下一个人，所以

8
00:00:25,191 --> 00:00:30,030
我们将直接进入本环节的第一个报告。

9
00:00:30,030 --> 00:00:36,303
>> 致毅张是加州大学洛杉矶分校互联网研究实验室的一名五年级博士研究生。

10
00:00:36,303 --> 00:00:41,457
他的主要研究兴趣在于网络技术以及网络安全。

11
00:00:41,457 --> 00:00:47,276
他将会讨论部署NDN来缓解DDoS攻击。

12
00:00:47,276 --> 00:00:48,339
>> 好的，完美。

13
00:00:48,339 --> 00:00:51,911
我们将开始。

14
00:00:51,911 --> 00:00:54,490
是的，所以我很高兴能来到这里。

15
00:00:54,490 --> 00:00:56,121
我是来自加州大学洛杉矶分校的智毅。

16
00:00:56,121 --> 00:01:01,657
这项工作被称为部署NDN以缓解DDoS攻击，

17
00:01:01,657 --> 00:01:08,030
这项工作也是由来自加州大学洛杉矶分校的Sichen和来自弗吉尼亚理工学院的Angelos完成的，

18
00:01:08,030 --> 00:01:12,224
埃里克来自乔治梅森大学，而艾丽西亚来自加州大学洛杉矶分校。

19
00:01:12,224 --> 00:01:14,955
所以，好的。

20
00:01:14,955 --> 00:01:19,810
所以，DDoS，我在这里提到它，它可以成为一款杀手级应用程序。

21
00:01:19,810 --> 00:01:23,761
所以，我们都知道DDoS已经困扰互联网几十年了。

22
00:01:23,761 --> 00:01:28,509
所以，我们都知道DDoS已经在很大程度上

23
00:01:28,509 --> 00:01:33,415
影响了一些基于TCP/IP的网络属性。

24
00:01:33,415 --> 00:01:35,620
因此，分布式拒绝服务攻击可以成为一种致命应用程序，

25
00:01:35,620 --> 00:01:38,777
推动当今互联网架构的一些变革。

26
00:01:38,777 --> 00:01:40,746
~!@#$%^&*()

27
00:01:40,746 --> 00:01:45,976
我们的候选者NDN具有内在的DDoS缓解特性。

28
00:01:45,976 --> 00:01:51,060
这包括了例如从设计上就排除了某些功能，我们拥有承受的状态，

29
00:01:51,060 --> 00:01:54,545
我们已命名以提供更好的流量洞察。

30
00:01:54,545 --> 00:01:59,449
我们可以消除反射攻击，因为数据

31
00:01:59,449 --> 00:02:02,695
必须沿着兴趣的相同路径。

32
00:02:02,695 --> 00:02:08,985
在讨论如何将NDN变为现实以缓解DDoS攻击之前，

33
00:02:08,985 --> 00:02:14,046
让我们首先看看当今行业如何实践以缓解DDoS攻击。

34
00:02:14,046 --> 00:02:18,767
首先，我展示了这张CDN网络的图片。

35
00:02:18,767 --> 00:02:22,758
所以我们有的线路是在它们自己的网络中。

36
00:02:22,758 --> 00:02:27,437
它们连接到CDN节点，这些节点还增加了边缘计算功能，

37
00:02:27,437 --> 00:02:34,093
这些CDN节点连接到服务器，如同Roger所想的，最终到达了服务器。

38
00:02:34,093 --> 00:02:37,591
这就是CDN平时的样子，但是

39
00:02:37,591 --> 00:02:41,833
这就是CDN平时的样子，但是当发生DDoS攻击时，情况就会有所不同。

40
00:02:41,833 --> 00:02:46,092
所以CDN提供商们已经开始提供DDoS缓解服务，利用他们现有的CDN基础设施。

42
00:02:49,383 --> 00:02:51,824
当DDoS攻击发生时，正如你在这里看到的。

43
00:02:51,824 --> 00:02:57,333
而不是直接将流量引导到服务器的Azure祭坛上，

44
00:02:57,333 --> 00:03:00,131
而将流量引导至MaaS（Mitigation as a Service），

45
00:03:00,131 --> 00:03:05,394
该服务是用于DDoS缓解的缓解即服务（Mitigation as a Service）基础设施。

46
00:03:05,394 --> 00:03:09,577
所以在这个缓解即服务（MaaS）中，他们会进行例如TLS解密，

47
00:03:09,577 --> 00:03:14,473
所以在这个缓解即服务（MaaS）中，他们会进行例如TLS解密，他们进行深度包检查，处理那些可疑的数据包。And then after this so-called traffic scrambling,

48
00:03:14,473 --> 00:03:18,739
然后在所谓的流量混淆之后，

49
00:03:18,739 --> 00:03:23,994
他们将飞机的流量引导到服务器的边缘路由器，然后在所谓的流量混淆之后，最终到达服务器。

50
00:03:23,994 --> 00:03:26,489
最终到达服务器。

51
00:03:26,489 --> 00:03:30,575
但问题是，今天的DDoS缓解措施有多有效。

52
00:03:30,575 --> 00:03:33,678
首先一个作品，绝对有效，而且

53
00:03:33,678 --> 00:03:38,670
已成功缓解了多起DDoS事件。

54
00:03:38,670 --> 00:03:44,170
然而，首先存在几个问题，深度包检查DPI

55
00:03:44,170 --> 00:03:49,305
由于我们都知道，今天的TLS流量很难处理，因为

56
00:03:49,305 --> 00:03:53,540
HTTPS已经成为互联网Web应用的主宰。

57
00:03:53,540 --> 00:04:00,723
为了进行深度包检测(DPI)，这通常需要额外的基础设施，比如像MaaS（金属即服务）这样的系统。

58
00:04:00,723 --> 00:04:06,186
而且，当今实践中使用的缓解方法

59
00:04:06,186 --> 00:04:11,068
是为了将攻击流量进行黑洞处理或回传。

60
00:04:11,068 --> 00:04:15,622
但这肯定会对那些

61
00:04:15,622 --> 00:04:19,694
这无疑会拒绝优质客户的服务。

62
00:04:19,694 --> 00:04:26,064
同时，问题还在于反应迟缓。

63
00:04:26,064 --> 00:04:31,469
在这项工作中，我们想提出将我们的FITT应用于NDM之上，以缓解DDoS攻击。

64
00:04:31,469 --> 00:04:37,334
因此，FITT被设定为10G大规模互联网流量限制，简称FITT。

65
00:04:37,334 --> 00:04:43,542
这是一个基于DDoS的DDoS缓解系统，利用ADN有状态转发。

66
00:04:43,542 --> 00:04:49,814
为了节省时间，我不会详细介绍FITT的工作原理。

67
00:04:49,814 --> 00:04:53,602
我在这里放了我们技术报告的链接，所以

68
00:04:53,602 --> 00:04:57,012
I have placed the link to our technical report here, so people who are interested can check this translation. And in this talk I want to focus on the incremental deployment of NDN and...

69
00:04:57,012 --> 00:05:02,292
在这次演讲中，我想重点讨论NDN的渐进式部署以及...

70
00:05:02,292 --> 00:05:04,897
FITT, 利用当今的CDN盒子。

71
00:05:04,897 --> 00:05:10,570
而且重要的是，我们想要分析这里的激励因素。

72
00:05:10,570 --> 00:05:14,901
这种增量部署方法也适用于其他NDS。

73
00:05:14,901 --> 00:05:17,390
ICN分布式拒绝服务攻击缓解机制同样适用。

74
00:05:17,390 --> 00:05:22,355
通过这次讲话，我想展示首先NDN和FITT，

75
00:05:22,355 --> 00:05:24,656
它们帮助CDN更好地发挥作用。

76
00:05:24,656 --> 00:05:26,358
为了更具体说明，

77
00:05:26,358 --> 00:05:32,227
它提供了即便预算更小的CDN DDoS缓解服务。

78
00:05:32,227 --> 00:05:35,837
那么让我们来看看它是如何工作的。

79
00:05:35,837 --> 00:05:40,110
首先，我们想要在边缘部署我们的NDN和FITT。

80
00:05:40,110 --> 00:05:44,362
在边缘部署指的是我们部署

81
00:05:44,362 --> 00:05:48,936
NDN加上FITT在所有的CDN设备上。

82
00:05:48,936 --> 00:05:55,359
在这里所示，我们还在服务器的边缘路由器上部署了NDN。

83
00:05:55,359 --> 00:05:59,653
我们还希望服务器具有NDN和FITT的感知能力。

84
00:05:59,653 --> 00:06:03,397
并且在CDN与那些边缘服务器之间，还有

85
00:06:03,397 --> 00:06:06,544
服务器作为中介，我们构建了NDN隧道。

86
00:06:06,544 --> 00:06:11,793
当DDoS攻击发生时，首先是服务器首当其冲地做出反应。

87
00:06:11,793 --> 00:06:16,386
因为服务器是遭受DDoS攻击的对象。

88
00:06:16,386 --> 00:06:21,944
所以这表明，这是对系统的即时反馈，即我遭受了DDoS攻击。

89
00:06:21,944 --> 00:06:27,014
攻击的目标是斜杠a斜杠me斜杠C前缀。

90
00:06:27,014 --> 00:06:32,177
如果服务器知道哪些兴趣包是恶意的，

91
00:06:32,177 --> 00:06:37,253
它们还可以将这些恶意的兴趣名称显式地放入我们的事实中，或者至少放入一个布隆过滤器中。

92
00:06:37,253 --> 00:06:39,725
至少放入一个布隆过滤器中。

93
00:06:39,725 --> 00:06:44,519
在消息中，服务器还指定了请求的内容。

94
00:06:44,519 --> 00:06:48,410
服务器在该前缀下的每秒处理能力。

95
00:06:48,410 --> 00:06:53,452
之后，反馈将会到达服务器Azure路由器，

96
00:06:53,452 --> 00:06:56,271
服务器Azure路由器首先将会检查

97
00:06:56,271 --> 00:07:00,905
查看那些匹配的流量或数据包的兴趣表。

98
00:07:00,905 --> 00:07:06,324
然后向下游创建一个新的反馈。

99
00:07:06,324 --> 00:07:11,840
来自哪里的可疑流量，然后通过NDN隧道

100
00:07:11,840 --> 00:07:16,697
这些反馈将逐跳最终到达CDN设备。

101
00:07:16,697 --> 00:07:21,920
当CDN设备知道已经获得了反馈后，它可以开始进行流量限制。

102
00:07:21,920 --> 00:07:27,396
来自怀疑检查的流量，仅在前缀/a/b/c/下。

103
00:07:27,396 --> 00:07:33,688
以及我们的NDA FITT的进一步部署，甚至更多。

104
00:07:33,688 --> 00:07:40,343
我们还可以让客户的夜间工作充当NDN的路由器。

105
00:07:40,343 --> 00:07:45,541
例如，我们可以拥有一个带有NDN azure路由器的智能家居。

106
00:07:45,541 --> 00:07:51,245
在这种情况下，我们可以进一步将流量限制推至网络边缘。

107
00:07:51,245 --> 00:07:55,376
在这种情况下，你甚至可以进行一些加强的流量限制，

108
00:07:55,376 --> 00:07:58,475
这意味着，我们可以对那些恶意客户端进行加强的流量限制，并为那些温顺的客户端解除限制。

109
00:07:58,475 --> 00:08:03,000
对那些恶意客户端加强流量限制，并为那些温顺的客户端解除限制。

110
00:08:06,380 --> 00:08:11,317
并且正如我提到的，我想分析这个NDN的激励机制。

111
00:08:11,317 --> 00:08:12,738
FITT部署。

112
00:08:12,738 --> 00:08:17,345
FITT和NDN首次共同对CDN进行DDoS攻击缓解，因为NDN

113
00:08:17,345 --> 00:08:21,140
提供良好的缓存和网络存储，以及

114
00:08:21,140 --> 00:08:26,221
FITT提供DDoS缓解属性和功能。

115
00:08:26,221 --> 00:08:31,004
然后就像我之前展示的，没有必要

116
00:08:31,004 --> 00:08:36,586
进行去中心化数据包的额外硬件或MaaS基础设施，

117
00:08:36,586 --> 00:08:39,522
深度数据包检查或清洗。

118
00:08:39,522 --> 00:08:43,734
我们可以清楚地看到，FITT和NDN使用了更小的

119
00:08:43,734 --> 00:08:48,446
我们可以清楚地看到，FITT和NDN使用了更小的资源占用与现今的做法相比，这是TLS终止加上DPI加上流量混淆。

120
00:08:48,446 --> 00:08:53,573
它是TLS终止加上DPI加上流量混淆。

121
00:08:53,573 --> 00:08:59,724
我通过这个真实世界部署评估来证明我的观点，

122
00:08:59,724 --> 00:09:05,472
在一方面，我们当然是在NDN（命名数据网络）上部署FITT，同时也在IP上部署。

123
00:09:05,472 --> 00:09:10,546
在另一方面，我们使用Squid，这是一个流行的CDN（内容分发网络）软件栈。

124
00:09:10,546 --> 00:09:13,280
我们使用Squid进行CDN和TLS终止。

125
00:09:13,280 --> 00:09:18,738
我们甚至没有在Squid端添加清洗和TLS转发逻辑。

126
00:09:18,738 --> 00:09:23,446
然后我们比较了这两者的开销。

127
00:09:23,446 --> 00:09:30,510
我们发现，FITT 加上 NDN 只需要大约五分之一的 CPU 内存和

128
00:09:30,510 --> 00:09:35,584
相同负载下，仅需三分之一的带宽。

129
00:09:35,584 --> 00:09:41,340
然后我想谈谈FITT在DDoS缓解中的优势。

130
00:09:41,340 --> 00:09:45,905
所以与当今的集中式缓解相比，或者

131
00:09:45,905 --> 00:09:51,926
使用黑洞或回程，FITT实现了分布式限流，

132
00:09:51,926 --> 00:09:58,260
然后我们拥有了细粒度控制，因为我们在真实攻击源处按前缀进行操作。

133
00:09:59,640 --> 00:10:04,430
因此，这将最大程度地减少对良性流量的附带损害。

134
00:10:04,430 --> 00:10:07,470
因此，我们可以做出快速反应，因为我们仅需

135
00:10:07,470 --> 00:10:11,740
因此，我们可以做出快速反应，因为我们仅需从服务器到边缘的单向延迟来开始节流。And we see that FITT is enabled by NDN's architectural properties.

136
00:10:11,740 --> 00:10:16,242
我们看到，FITT得以实现是由于NDN的架构特性。

137
00:10:16,242 --> 00:10:21,560
该名字为我们提供了对流量的良好洞察，

138
00:10:21,560 --> 00:10:24,100
基于IP加端口进行比较。

139
00:10:24,100 --> 00:10:27,690
因此，我们可以进行细粒度的流量分类和限速。

140
00:10:27,690 --> 00:10:30,649
第二是要有状态的转发。

141
00:10:30,649 --> 00:10:36,347
这使得FITT能够追踪那些真实的攻击或范围。

142
00:10:36,347 --> 00:10:42,214
然后，这次演讲的要点，我们想说的是，首先，架构

143
00:10:42,214 --> 00:10:47,245
实际上在DDoS的韧性和缓解方面扮演了重要的角色。

144
00:10:47,245 --> 00:10:53,673
这出现在NDN与当今的TCP/IP之间的比较中。

145
00:10:53,673 --> 00:10:59,335
显然，分布式拒绝服务攻击可能成为一种推动部署的杀手级应用程序。

146
00:10:59,335 --> 00:11:04,547
通过我们的工作，我们展示了FITT和NDN可以逐步

147
00:11:04,547 --> 00:11:09,665
通过我们的工作，我们展示了FITT和NDN可以逐步部署到这个城市的箱子中，而无需任何额外的负担或overhead, without any further hardware and MEMS infrastructure.

148
00:11:09,665 --> 00:11:15,710
额外的开销，无需任何进一步的硬件和MEMS基础设施。

149
00:11:15,710 --> 00:11:20,608
因此，有动机在当今的CDN盒子中部署FITT和NDN。

150
00:11:20,608 --> 00:11:27,124
这就是我演讲的全部内容，谢谢，感谢。

151
00:11:27,124 --> 00:11:29,970
谢谢，所以我们有一个问题。

152
00:11:29,970 --> 00:11:34,353
FITT 如何检测攻击者使用有效的名称前缀和

153
00:11:34,353 --> 00:11:36,129
FITT 如何检测攻击者使用有效的名称前缀和无效的名称后缀？

154
00:11:37,500 --> 00:11:41,280
>> 是的，例如，

155
00:11:41,280 --> 00:11:47,000
这些有效的前缀加上无效的后缀以到达服务器。

156
00:11:48,070 --> 00:11:53,020
服务器会知道没有对应的数据或

157
00:11:53,020 --> 00:11:57,622
服务器可以回应不存在的服务，

158
00:11:57,622 --> 00:12:02,050
实际上是为了回应这种攻击流量。

159
00:12:02,050 --> 00:12:08,590
因此，服务器可以知道回传的兴趣是它们的电子邮件ID。

160
00:12:08,590 --> 00:12:13,568
因此，当他们发送回FITT，即对网络的反馈时，

161
00:12:13,568 --> 00:12:18,373
他们可以将这些名称明确地放入布隆过滤器中。

162
00:12:18,373 --> 00:12:23,130
因此，之后边缘节点和CDN设备就可以检查它们的待处理内容。

163
00:12:23,130 --> 00:12:27,800
因此，可以追溯到真正的攻击者，并找到这些数据包的发送来源。

164
00:12:27,800 --> 00:12:32,559
find the source from which these packets were sent. And then, 对该接口的该前缀执行流量限制。

165
00:12:32,559 --> 00:12:37,240
对该接口的该前缀执行流量限制。

166
00:12:37,240 --> 00:12:41,700
为了缓解DDoS攻击。

167
00:12:41,700 --> 00:12:44,234
>> 酷，谢谢你。

168
00:12:44,234 --> 00:12:47,405
我认为我们刚刚听到的是Dave Moran的一句嘲讽的话。

169
00:12:47,405 --> 00:12:49,237
这是他的典型特征。

170
00:12:49,237 --> 00:12:50,640
他喜欢说话并且……

171
00:12:50,640 --> 00:12:56,538
然后他评论说，如果它工作得太好，也许人们就不会部署NDN了。

172
00:12:56,538 --> 00:12:59,815
~!@#$%^&*()

173
00:12:59,815 --> 00:13:06,167
所以这是一种特定类型的DDoS攻击，即你正在发起攻击

174
00:13:06,167 --> 00:13:12,150
兴趣洪水攻击，以产生压倒性的兴趣请求量或流量。

175
00:13:13,360 --> 00:13:18,342
但NDN容易受到的另一种DDoS攻击形式是那些造成

176
00:13:18,342 --> 00:13:21,350
缓存抖动问题，这主要发生在中间节点上，

177
00:13:21,350 --> 00:13:26,831
你请求大量你实际上并不关心的有效数据。

178
00:13:26,831 --> 00:13:31,951
但你这么做是为了将真正有价值的内容从缓存中驱逐出去，

179
00:13:31,951 --> 00:13:36,993
而你最终导致热门内容被正确地一次又一次地从源头请求。

180
00:13:36,993 --> 00:13:39,380
从源头传送过来。

181
00:13:39,380 --> 00:13:43,120
FITT有助于这方面吗？

182
00:13:43,120 --> 00:13:43,950
>> 目前来说？

183
00:13:43,950 --> 00:13:51,310
不，因为目前的FITT实现只保护了应用程序。

184
00:13:51,310 --> 00:13:55,548
但我认为你提到的那种DDoS攻击场景，

185
00:13:55,548 --> 00:13:59,122
实际上它并不会真的使服务器过载。

186
00:13:59,122 --> 00:14:04,356
如果攻击者足够聪明，找到足够多的内容来

187
00:14:04,356 --> 00:14:09,499
持续替换内容存储，这意味着将会有大量

188
00:14:09,499 --> 00:14:15,022
大量有效的请求达到服务器，以至于服务器不堪重负。

189
00:14:15,022 --> 00:14:18,141
在这种情况下，FITT可以提供帮助，因为，

190
00:14:18,141 --> 00:14:23,404
在这种情况下，服务器可以告诉FITT网络看到了，好的，

191
00:14:23,404 --> 00:14:29,062
这个完美的斜线A、斜线B或者其他前缀正在遭受攻击。

192
00:14:29,062 --> 00:14:33,475
我预计即使是每秒请求量（RPS），也会有

193
00:14:33,475 --> 00:14:37,093
例子，内容分发服务。

194
00:14:37,093 --> 00:14:40,498
即便有这些RPS，

195
00:14:40,498 --> 00:14:44,704
这些边缘服务器就像CDN设备一样充当路由器，

196
00:14:44,704 --> 00:14:51,532
它们都记录了流量以满足服务器指定的每秒请求量(RPS)要求。

197
00:14:51,532 --> 00:14:54,519
所以是的，在这里它说，是的，

198
00:14:54,519 --> 00:14:59,500
它可以阻止那些有效数据包的过载。

199
00:15:00,500 --> 00:15:03,690
好的，我们现在已经到了时间限制。

200
00:15:03,690 --> 00:15:06,630
非常感谢您精彩的演讲。

201
00:15:06,630 --> 00:15:10,154
显然，我看到聊天群里正在进行一些讨论，

202
00:15:10,154 --> 00:15:13,173
你可能会想加入他们，并且更多地和他们讨论你的工作。

203
00:15:13,173 --> 00:15:13,989
好的，当然可以。

204
00:15:13,989 --> 00:15:15,289
>> 我们非常感谢你。

205
00:15:15,289 --> 00:15:18,828
>> 我们非常感谢你。>> 你需要释放屏幕给

206
00:15:18,828 --> 00:15:20,960
你需要把屏幕让给下一个发言人。

207
00:15:20,960 --> 00:15:22,780
在这个过渡期间发生的是，

208
00:15:22,780 --> 00:15:26,590
我要迅速抓住机会说，这还不是正式的，

209
00:15:26,590 --> 00:15:32,430
但我们预计很快就会宣布科罗拉多州立大学正在寻找

210
00:15:32,430 --> 00:15:37,050
科罗拉多州立大学正在寻找一位网络领域的新晋助理教授。

211
00:15:37,050 --> 00:15:38,720
所以我们今年将会进行一次搜索。

212
00:15:38,720 --> 00:15:42,689
所以如果你正在寻找一个教职位，

213
00:15:42,689 --> 00:15:47,591
所以如果你正在寻找一个教职位，我们鼓励你申请来到美丽的四柱城。

214
00:15:47,591 --> 00:15:51,207
所以我们的下一位演讲者是Laqin Fan，

215
00:15:51,207 --> 00:15:55,325
所以我们的下一位演讲者是Laqin Fan，他将会讲述关于通过基于名称的访问控制来安全分享时空数据。

216
00:15:55,325 --> 00:16:01,585
通过基于名称的访问控制来安全分享时空数据。

217
00:16:01,585 --> 00:16:03,870
我会把它交给Laqin。

218
00:16:03,870 --> 00:16:08,650
大家好，我是来自孟菲斯大学的范拉钦。

219
00:16:08,650 --> 00:16:13,542
我将要展示的主题是关于我们如何共享时空数据。

220
00:16:13,542 --> 00:16:16,729
通过基于名称的访问控制来提供安全性。

221
00:16:19,467 --> 00:16:24,108
如今，移动设备和传感器无处不在，并且提供

222
00:16:24,108 --> 00:16:29,348
这些数据量是随时间和空间动态且连续的。

223
00:16:30,550 --> 00:16:36,430
例如，移动设备会在不同的时间和地点产生数据。

224
00:16:36,430 --> 00:16:40,710
这些数据可能包含用户的隐私敏感信息。

225
00:16:40,710 --> 00:16:45,770
我们需要确保只有授权的用户才能访问数据，

226
00:16:49,580 --> 00:16:54,780
我们面临的挑战是，我们需要一种精细的访问控制来表达

227
00:16:54,780 --> 00:17:00,330
我们需要与时间和数据位置信息相关的精细访问策略。

228
00:17:02,520 --> 00:17:06,670
我们需要实时数据共享以便我们能够

229
00:17:06,670 --> 00:17:10,970
许多干预措施都是基于收集到的数据。

230
00:17:10,970 --> 00:17:18,460
这里有一个用户框数据共享的演示或示例。

231
00:17:18,460 --> 00:17:23,880
鲍勃正在使用他的智能手表收集个人数据，并且

232
00:17:23,880 --> 00:17:29,730
分享数据给他的教练、医生和数据科学研究员，

233
00:17:31,670 --> 00:17:37,020
他的教练只能访问Bob在健身房产生的活动数据，以及

234
00:17:37,020 --> 00:17:43,610
他的医生可以访问上午8点到晚上8点之间的心率数据。

235
00:17:43,610 --> 00:17:47,760
数据科学研究员可以访问他的活动数据。

236
00:17:48,770 --> 00:17:54,110
在白天生成，而不是在Bob的家里。

237
00:17:54,110 --> 00:17:58,660
这三个消费者有不同的访问策略。

238
00:18:01,220 --> 00:18:02,210
在你的工作中，

239
00:18:02,210 --> 00:18:07,780
我们使用的是Nimbus访问控制，这是印度的访问控制模型。

240
00:18:09,820 --> 00:18:16,010
NAC通过在数据生成时对其进行加密来保证数据的机密性。

241
00:18:17,630 --> 00:18:23,720
它还能够在不依赖第三方服务的情况下实现端到端的安全性。

242
00:18:23,720 --> 00:18:28,350
正如我们所知，印度拥有很多好处。

243
00:18:29,500 --> 00:18:33,720
像数据中心安全中的分层命名结构，

244
00:18:35,130 --> 00:18:40,500
这是由生产者签名的加密CLI，

245
00:18:40,500 --> 00:18:42,300
Nimbus，数据分发。

246
00:18:44,580 --> 00:18:49,239
好的，让我简要介绍一下NAC是如何工作的。

247
00:18:52,270 --> 00:18:58,120
NAC模型中有三个实体：访问管理器、生产者和消费者。

248
00:18:58,120 --> 00:19:05,930
访问管理器以命名的公私钥对的形式发布访问策略。

249
00:19:05,930 --> 00:19:12,037
而公钥被用作密钥加密密钥，在这里我们称之为KEK。

250
00:19:12,037 --> 00:19:16,549
而私钥被用作密钥解密密钥，

251
00:19:16,549 --> 00:19:21,814
我们将其命名为KDK，数据生产者生成数据时，

252
00:19:21,814 --> 00:19:29,070
与之对应的是一个内容密钥，它是一个对称密钥。

253
00:19:29,070 --> 00:19:31,560
为了加密数据并且

254
00:19:31,560 --> 00:19:37,200
检索相应的KEK来加密内容密钥

255
00:19:39,480 --> 00:19:45,200
数据消费者，例如数据消费者获取加密的

256
00:19:45,200 --> 00:19:48,740
内容和加密内容是关键。

257
00:19:48,740 --> 00:19:55,090
从内容密钥名称中提取KDK名称，并检索KDK

258
00:19:55,090 --> 00:20:00,610
解密内容密钥，然后使用内容密钥来解密数据。

259
00:20:00,610 --> 00:20:04,439
这基本上是基于名称的访问控制的工作流程。

260
00:20:06,899 --> 00:20:10,877
在您的工作中，我们提出了时空访问控制，

261
00:20:10,877 --> 00:20:16,710
它提供了一个与时间和地点相关的分层命名约定。

262
00:20:16,710 --> 00:20:21,139
例如，Bob的活动数据可以命名为

263
00:20:21,139 --> 00:20:25,679
例如，Bob的活动数据可以命名为地理位置/时间戳。

264
00:20:26,930 --> 00:20:30,710
我们的访问控制可以支持细粒度的权限控制，

265
00:20:30,710 --> 00:20:36,150
它还支持长时间的实时数据共享，以便所有者能够共享存储中的历史数据。

266
00:20:37,500 --> 00:20:41,510
它还支持粒度化的实时数据共享。

267
00:20:42,710 --> 00:20:48,270
例如，医生可以检索病人的心率数据以便及时干预。

268
00:20:48,270 --> 00:20:50,480
及时干预。

269
00:20:50,480 --> 00:20:57,290
与此同时，我们可以指定内容关键字的不同粒度。

270
00:20:57,290 --> 00:21:02,160
而这种粒度可以根据时间和地点进行调整。

271
00:21:02,160 --> 00:21:07,879
例如，用户可以配置内容

272
00:21:07,879 --> 00:21:13,051
每秒、每分钟生成的密钥，或者

273
00:21:13,051 --> 00:21:17,560
根据他们的需求在每个位置上。

274
00:21:17,560 --> 00:21:22,202
根据他们的需求在每个位置上定义细粒度访问策略，以便业主决定谁可以在哪个粒度访问什么数据。

275
00:21:22,202 --> 00:21:29,180
业主决定谁可以在哪个粒度访问什么数据。

276
00:21:29,180 --> 00:21:34,018
您关于粒度访问策略的设计

277
00:21:34,018 --> 00:21:38,555
包含了一系列的限制条件，比如

278
00:21:38,555 --> 00:21:43,250
时间间隔为上午8点至下午5点。

279
00:21:43,250 --> 00:21:47,064
例如和空间区域，

280
00:21:47,064 --> 00:21:52,785
它可能处于建筑级别、社区级别或者

281
00:21:52,785 --> 00:21:58,744
城市级别，例如，用户的房子和城市孟菲斯。

282
00:21:58,744 --> 00:22:06,532
这个可视区域由一个中心点和一个半径来表示。

283
00:22:06,532 --> 00:22:12,103
这是一个示例，用一个圆来定位建筑物。

284
00:22:12,103 --> 00:22:17,689
这是孟菲斯大学的健身中心。

285
00:22:17,689 --> 00:22:22,951
我们为时空数据设计了分层命名方案，并且

286
00:22:22,951 --> 00:22:28,764
我们为时空数据设计了分层命名方案，并且，如右侧所示的手指指出的，你的树状结构，代表了数据所有者的一个可路由的名字前缀。

287
00:22:28,764 --> 00:22:33,490
数据所有者代表了数据的一个可路由的名字前缀。

288
00:22:33,490 --> 00:22:37,697
例如，孟菲斯大学和

289
00:22:37,697 --> 00:22:42,585
用户Bob在数据流上指的是数据类型，

290
00:22:42,585 --> 00:22:45,439
像活动和高速率。

291
00:22:45,439 --> 00:22:53,142
在数据流下面，有两个以单词"data"和"what rate"开头的子树。

292
00:22:53,142 --> 00:22:57,477
该子树用于表示命名空间

293
00:22:57,477 --> 00:23:01,460
数据、PSync以及内容密钥。

294
00:23:01,460 --> 00:23:05,380
读取子树用于访问控制的命名空间。

295
00:23:07,510 --> 00:23:11,690
嗯，让我们来看一个例子如何

296
00:23:12,810 --> 00:23:16,720
脓肿政策在这里被指定。

297
00:23:16,720 --> 00:23:21,830
访问管理器帮助所有者设置访问策略。

298
00:23:21,830 --> 00:23:27,180
例如，鲍勃的教练可以访问鲍勃的活动数据。

299
00:23:30,150 --> 00:23:35,330
仅在上午8点至中午12点间在合身健身中心生成。

300
00:23:35,330 --> 00:23:40,438
从9月1日到9月5日，每天，

301
00:23:40,438 --> 00:23:45,745
左侧的表格显示了访问的详细信息。

302
00:23:45,745 --> 00:23:50,970
策略包括数据前缀和时间间隔。

303
00:23:50,970 --> 00:23:57,194
指示的时间单位的开始和结束时间，

304
00:23:57,194 --> 00:24:01,863
指定的是这里的哪一天和由空间区域指定的，

305
00:24:01,863 --> 00:24:07,220
它还包括中心点和半径。

306
00:24:07,220 --> 00:24:10,768
它包括消费者前缀，即Bob的教练。

307
00:24:14,774 --> 00:24:17,946
好吧，那我们来说说我们是如何遵循的。

308
00:24:17,946 --> 00:24:22,510
我们使用命名结构来表达访问策略。

309
00:24:24,320 --> 00:24:26,250
在提供访问策略之后，

310
00:24:26,250 --> 00:24:32,190
访问管理器生成一对KEK和KDK。

311
00:24:32,190 --> 00:24:40,211
她们的名字有相同的前缀，这与她们保护的数据活动相关。

312
00:24:40,211 --> 00:24:46,121
此外，这些密钥包含时间和~!@#$%^&*()

313
00:24:46,121 --> 00:24:51,048
遵循位置约束

314
00:24:51,048 --> 00:24:57,296
之前在那张表中的访问策略。

315
00:24:57,296 --> 00:25:02,896
鲍勃在9月8日早上8:30产生活动数据时，

316
00:25:02,896 --> 00:25:08,063
鲍勃在9月8日早上8:30产生活动数据时，第一次在健身中心，这些数据可以被命名为，包括前缀地理位置和时间戳。

317
00:25:08,063 --> 00:25:13,030
包括前缀地理位置和时间戳。

318
00:25:15,010 --> 00:25:23,036
我们还允许Bob指定内容的关键粒度，

319
00:25:23,036 --> 00:25:27,059
在这种情况下，是一分钟。

320
00:25:27,059 --> 00:25:31,038
关键名的内容也有相同的前缀

321
00:25:31,038 --> 00:25:34,400
数据追加时间间隔。

322
00:25:34,400 --> 00:25:39,666
这里的范围是一分钟，还有一个特殊区域。

323
00:25:39,666 --> 00:25:44,802
在这种情况下，内容使用KEK进行了加密。

324
00:25:44,802 --> 00:25:48,634
它还包含了KEK名称前缀。

325
00:25:48,634 --> 00:25:51,460
在某些情况下，数据访问将会失败。

326
00:25:52,500 --> 00:25:57,622
如果消费者没有被授予访问权限

327
00:25:57,622 --> 00:26:03,030
如果消费者没有被授予访问权限，他的代码只能访问他在健身房生成的活动数据。

328
00:26:03,030 --> 00:26:10,301
他的代码只能访问他在健身房生成的活动数据。

329
00:26:10,301 --> 00:26:18,037
即使他的袋子想在他家中检索鲍勃的活动数据，

330
00:26:18,037 --> 00:26:23,202
他将没有解密数据的钥匙。

331
00:26:23,202 --> 00:26:28,020
我们对这种访问控制的数据检索时间进行了实验。

332
00:26:28,020 --> 00:26:32,751
我们在MiniNDN仿真环境中运行了实验。

333
00:26:32,751 --> 00:26:36,751
我们使用了一个包含100多个节点的星型拓扑。

334
00:26:36,751 --> 00:26:41,488
我们的数据集包含了具有连续时间的活动数据以及

335
00:26:41,488 --> 00:26:43,511
不同的位置。

336
00:26:43,511 --> 00:26:48,594
所有消费者都有相同的访问策略。

337
00:26:48,594 --> 00:26:49,410
>> 很酷。>> 好的。

338
00:26:49,410 --> 00:26:53,638
>> 我们已经到了最后，你的时间用完了。

339
00:26:53,638 --> 00:26:59,504
>> 好的，那么，我想结束这张幻灯片，请允许。

340
00:26:59,504 --> 00:27:00,831
>> 五秒钟。

341
00:27:00,831 --> 00:27:04,728
>> 好的 [笑声] >> 我给你们最后两分钟的警告，

342
00:27:04,728 --> 00:27:07,578
好的，所以在我们的实验中，

343
00:27:07,578 --> 00:27:11,811
我们可以伪造内容关键字的不同粒度。

344
00:27:11,811 --> 00:27:17,102
我们可以根据数据生成的间隔来指定粒度。

345
00:27:17,102 --> 00:27:22,760
如果数据是每秒生成的，那么粒度可以是每秒或者更精细。

346
00:27:22,760 --> 00:27:27,635
根据结果，存在着在更精细的粒度和生成的竞争者关键字数量之间的权衡。

347
00:27:27,635 --> 00:27:32,138
粒度以及生成的竞争者关键字的数量，

348
00:27:32,138 --> 00:27:37,138
粒度的成本使得一个内容密钥覆盖更多数据。

349
00:27:37,138 --> 00:27:42,732
但如果内容密钥被破解，那么那些数据就会暴露出来。

350
00:27:42,732 --> 00:27:46,373
好的，结果如下。

351
00:27:46,373 --> 00:27:50,184
>> 如果你让我们保留那些，我们就从问题开始。

352
00:27:50,184 --> 00:27:52,600
>> 好的，这样更好。

353
00:27:52,600 --> 00:27:56,521
好的，我想说一下未来的工作。

354
00:27:56,521 --> 00:28:00,230
未来的工作是我们将直接指定空间区域。

355
00:28:00,230 --> 00:28:04,431
所以有一张地图，目前是手动配置的。

356
00:28:04,431 --> 00:28:09,320
我们将通过改变空间区域的粒度来进行实验。

357
00:28:09,320 --> 00:28:12,030
像是在社区层面和城市层面。

358
00:28:12,030 --> 00:28:14,783
显然，它是固定在豆荚网络上的。

359
00:28:14,783 --> 00:28:17,480
>> 好的。 >> 好的，就这些了，谢谢。

360
00:28:17,480 --> 00:28:19,980
>> 好的，所以我们有多个问题。

361
00:28:19,980 --> 00:28:28,573
那么我们如何加密将要被多个不同访问单元使用的数据呢？

362
00:28:28,573 --> 00:28:33,878
那么如果一条数据要同时被例如一个培训师和

363
00:28:33,878 --> 00:28:38,670
So if a piece of data needs to be accessed by, for example, a trainer and a physician at the same time, how is that data encrypted?

364
00:28:43,050 --> 00:28:46,991
如何对数据进行加密，一个数据同时被使用时，如何进行加密？

365
00:28:46,991 --> 00:28:51,313
两个不同的消费者，你是想将他们分开吗？

366
00:28:51,313 --> 00:28:56,472
>> 数据仅由内容密钥加密。

367
00:28:56,472 --> 00:29:00,250
>> 好吧，问题是你得到了两个数据流。

368
00:29:00,250 --> 00:29:03,645
这只是恰巧在一段时间内共享了一些数据。

369
00:29:03,645 --> 00:29:06,132
>> 这意味着相同的数据，对吗？

370
00:29:06,132 --> 00:29:07,800
>> 两个数据流共享相同的数据，然后分开。

371
00:29:09,430 --> 00:29:12,012
是的，如果它有效，就没有问题。

372
00:29:12,012 --> 00:29:14,807
不，让我快速澄清我的问题。

373
00:29:14,807 --> 00:29:17,667
那么，同一份数据被两组人使用，如果这样的话，那么这两组人就有了他们不同的特权。

374
00:29:17,667 --> 00:29:21,720
那么这两组人就有了他们不同的特权。

375
00:29:21,720 --> 00:29:25,890
那么如果你只加密一次数据，然后一组人得到了C密钥和

376
00:29:25,890 --> 00:29:26,880
解密数据。

377
00:29:26,880 --> 00:29:30,730
这意味着他们也可以解密数据。

378
00:29:30,730 --> 00:29:33,060
这意味着他们也可以看到为对方加密的数据。

379
00:29:34,060 --> 00:29:36,912
你明白我的意思了吗？

380
00:29:36,912 --> 00:29:42,084
Bob活动之家TPM既被Bob活动之家使用，也被

381
00:29:42,084 --> 00:29:44,973
Bob活动之家，这两个团体。

382
00:29:44,973 --> 00:29:52,230
如果只有一个C键，那意味着这两个团体使用的是同一个C键。

383
00:29:52,230 --> 00:29:56,345
我是说，我的问题是，你需要对数据加密两次吗还是

384
00:29:56,345 --> 00:29:59,591
两个组因为他们有不同的权限。

385
00:29:59,591 --> 00:30:04,545
不，即使是那两个组，他们已经发放了访问权限。

386
00:30:04,545 --> 00:30:09,282
他们一旦能够访问数据，就有了权限。

387
00:30:09,282 --> 00:30:13,822
这意味着两个团队，他们想要相互分享关键内容。

388
00:30:13,822 --> 00:30:17,032
然后我们不会，>> 他们不会，他们是不同的。

389
00:30:17,032 --> 00:30:21,425
即使他们不共享内容密钥，如果他们被发放为

390
00:30:21,425 --> 00:30:26,090
即使他们不共享内容密钥，如果他们被发放为一个茎干访问策略，我认为他们可以以任何方式访问数据。

391
00:30:27,370 --> 00:30:32,410
>> 好的，听起来我们应该在聊天群里更多地讨论这个问题。

392
00:30:32,410 --> 00:30:36,030
那么，另一个问题是，在这个命名政策下，

393
00:30:36,030 --> 00:30:39,790
它听起来像是消费者可以了解何时以及在这个命名政策下，where data was generated even if they can't decrypt it.

394
00:30:39,790 --> 00:30:43,490
即使他们无法解密数据，也能了解数据是在何处产生的。

395
00:30:43,490 --> 00:30:47,974
而这实际上不就揭示了某人所在的位置和

396
00:30:47,974 --> 00:30:49,404
他们正在做的事情。

397
00:30:49,404 --> 00:30:51,437
但你可以本地化，对吗？

398
00:30:55,444 --> 00:30:57,202
即使这是一个重复的问题？

399
00:30:57,202 --> 00:31:02,021
>> 好的，如果你需要，这也在聊天群里，来自Dave Moran。

400
00:31:02,021 --> 00:31:04,228
根据我所理解的你的命名方案以及

401
00:31:04,228 --> 00:31:06,920
戴夫，我稍微调整了一下你的问题。

402
00:31:06,920 --> 00:31:11,660
数据的消费者即使无法解密，仍然可以看到名称

403
00:31:11,660 --> 00:31:12,601
内容。

404
00:31:12,601 --> 00:31:13,959
这个问题是，

405
00:31:13,959 --> 00:31:18,717
这个名字本身就足以确定一个人在时间和空间中的位置吗？

406
00:31:18,717 --> 00:31:23,202
所以即使你不知道确切的读数，我也会知道你在哪里。

407
00:31:23,202 --> 00:31:28,207
>> 好的，这次我站着，我认为这意味着数据名称，

408
00:31:28,207 --> 00:31:34,890
数据消费者，并不知道用来检索数据的数据名称。

409
00:31:34,890 --> 00:31:37,265
不，他们告诉他们能够发现这些名称。

410
00:31:37,265 --> 00:31:40,423
抱歉，Dave，你想试试吗？

411
00:31:40,423 --> 00:31:41,360
>> 或者我可以加入进来。

412
00:31:41,360 --> 00:31:48,882
>> 抱歉，如果实际名称中包含了地点和时间。

413
00:31:48,882 --> 00:31:54,700
我假设消费者可以使用一个不错的猜测策略来尝试并且

414
00:31:54,700 --> 00:31:59,430
找出哪些名字是存在的，哪些名字是不存在的。

415
00:31:59,430 --> 00:32:02,100
他们最终会通过选择一个名字而找到线索，

416
00:32:03,190 --> 00:32:07,860
他们从中知道了名字本身告诉他们的任何事情。

417
00:32:07,860 --> 00:32:10,372
即使他们无法解密数据，

418
00:32:10,372 --> 00:32:15,172
即使他们无法获取密钥来解密存储在那个名称下的数据。

419
00:32:15,172 --> 00:32:20,996
所以问题是，这些带有地理位置信息的名称是否

420
00:32:20,996 --> 00:32:25,164
容易被猜到的，换一种方式提问这个问题。

421
00:32:28,589 --> 00:32:30,843
>> 为了节省时间，如果我可以插一句，

422
00:32:30,843 --> 00:32:35,460
我认为这是我们今天早些时候在小组讨论中提到的一个问题。

423
00:32:35,460 --> 00:32:39,931
基本原则是通过命名暴露了多少信息。

424
00:32:39,931 --> 00:32:44,880
我认为我当时的回答是充分的，就是这一切都取决于怎样

425
00:32:44,880 --> 00:32:47,640
可以隐藏这些名字，对吗？

426
00:32:47,640 --> 00:32:51,533
只有生产者和消费者需要知道这些名字。

427
00:32:51,533 --> 00:32:56,086
如果他们有了解方法的方法

428
00:32:56,086 --> 00:33:00,230
模糊名称，这就是你所需要的。

429
00:33:00,230 --> 00:33:03,734
>> 但你无法在他们尝试之前分辨出一个好消费者和坏消费者。

430
00:33:03,734 --> 00:33:04,684
访问某物。

431
00:33:08,732 --> 00:33:11,601
>> 我以为消费者权利是预先定义好的。

432
00:33:14,203 --> 00:33:19,450
>> 好的，再次提醒，我认为这是聊天中另一个话题，因为我们需要继续进行。

433
00:33:19,450 --> 00:33:24,379
谢谢丽霞的发言，如果你能把屏幕让给穆罕默德，

434
00:33:24,379 --> 00:33:25,985
那会很棒。

435
00:33:27,576 --> 00:33:33,892
所以我们这个环节的最后一个报告是由Mohammed Elbadri进行的。

436
00:33:33,892 --> 00:33:39,276
穆罕默德是纽约州立大学石溪分校的一名三年级博士研究生。

437
00:33:39,276 --> 00:33:43,040
穆罕默德的研究兴趣是无线网络，所以他在这方面更加专注。

438
00:33:43,040 --> 00:33:46,883
因此，我预计在他的演讲中，我们将听到他在这些研究兴趣方面的一些内容，特别是关于边缘通信的部分。

439
00:33:46,883 --> 00:33:52,933
因此，我预计在他的演讲中，我们将听到他在这些研究兴趣方面的一些内容，

440
00:33:52,933 --> 00:33:59,790
题为“整合V-MAC和NFD的全数据中心网络栈”。

441
00:33:59,790 --> 00:34:01,450
所以穆罕默德，轮到你了。

442
00:34:03,270 --> 00:34:05,960
>> 谢谢，你们能看到我的屏幕吗？

443
00:34:05,960 --> 00:34:09,120
>> 是的，我们能很清楚地看到你的屏幕，谢谢。

444
00:34:09,120 --> 00:34:10,600
>> 好的，谢谢。

445
00:34:10,600 --> 00:34:16,152
所以我将负责V-MAC和NFD之间的全数据中心堆栈集成。

446
00:34:16,152 --> 00:34:19,298
V-MAC是我们正在与NFD集成的新阶段。

447
00:34:19,298 --> 00:34:22,794
V-MAC是一个无线介质访问控制层，

448
00:34:22,794 --> 00:34:27,290
设计得完全从零开始，完全以数据为中心。

449
00:34:28,540 --> 00:34:31,880
我们最终设计了一个以数据为中心的MAC的原因是因为现有的MAC层有多个方面的不足。

450
00:34:31,880 --> 00:34:35,560
是因为现有的MAC层在多个方面存在不足。

451
00:34:35,560 --> 00:34:36,871
之一是网络和

452
00:34:36,871 --> 00:34:40,704
在任何以数据为中心的通信之前，必须建立发现程序。

453
00:34:40,704 --> 00:34:42,690
在信标通信中，

454
00:34:42,690 --> 00:34:45,241
必须发生的是地址空间的共享。

455
00:34:45,241 --> 00:34:49,222
在一个临时网络中，你必须在任何通信发生之前加入网络。

456
00:34:49,222 --> 00:34:53,462
这会导致持续的开销、媒体中和以及延迟，

457
00:34:53,462 --> 00:34:55,833
特别是在移动环境中。

458
00:34:55,833 --> 00:34:58,204
在传输之前必须确定目的地。

459
00:34:58,204 --> 00:35:01,480
这是基于地址的标准通信目的地和

460
00:35:01,480 --> 00:35:02,750
这是基于地址的标准通信目的地和网络组。

461
00:35:02,750 --> 00:35:05,860
传统的MAC多播支持并不存在。

462
00:35:05,860 --> 00:35:09,260
通常情况下，如果我们使用的是自组织通信，那么它就是广播形式。

463
00:35:09,260 --> 00:35:12,480
是在低基础速率下，即低数据速率，1或6 Mbps。

464
00:35:12,480 --> 00:35:16,130
如果我们提高数据速率，最终会导致很高的丢包率。

465
00:35:18,160 --> 00:35:21,705
因此，我们在设计新的无线MAC层时面临的挑战是存在着

466
00:35:21,705 --> 00:35:24,783
不同邻近接收器的接收质量各异。

467
00:35:24,783 --> 00:35:26,245
一般来说，它的损耗很大，

468
00:35:26,245 --> 00:35:30,380
我相信之前的一些报告者已经提到过这个问题了。

469
00:35:30,380 --> 00:35:33,750
在一般情况下，来自高度移动的环境，比如车载网络，

470
00:35:33,750 --> 00:35:38,100
我们有非常短暂的接触时间，我们希望在这期间共享数据。

471
00:35:38,100 --> 00:35:42,770
然而，在无线通信中，我们有广播仪表。

472
00:35:42,770 --> 00:35:47,860
因此我们可以非常容易地进行多播，这与NFDM MDM非常匹配。

473
00:35:47,860 --> 00:35:50,780
我们还有可能消除网络发现，

474
00:35:50,780 --> 00:35:54,170
它能够加入一个网络，并依靠属性数据过滤。

475
00:35:56,310 --> 00:35:58,050
这就是我们设计V-MAC的原因，

476
00:35:58,050 --> 00:36:02,110
这是一种从零开始设计的新型无线MAC层，它是以数据为中心的。

477
00:36:02,110 --> 00:36:05,270
该系统无需信标，它不需要任何发现或加入网络的过程，因此消除了巨大的开销。

478
00:36:05,270 --> 00:36:09,120
加入网络，因此消除了巨大的开销。

479
00:36:09,120 --> 00:36:12,630
打开无线电，你就可以立即进行通信和数据共享。

480
00:36:12,630 --> 00:36:17,186
它使用一个待处理的编码表来进行MAC中的数据名称过滤。

481
00:36:17,186 --> 00:36:17,692
层。

482
00:36:17,692 --> 00:36:22,764
我们进行一次匹配，这不是待处理的兴趣表，而是编码。

483
00:36:22,764 --> 00:36:28,210
在ICM层中，原因是因为一次兴趣对应一份数据包。

484
00:36:28,210 --> 00:36:29,712
但是，在MAC层中，

485
00:36:29,712 --> 00:36:33,939
它是将一个数据包对应到多个帧中的一种兴趣。

486
00:36:33,939 --> 00:36:36,246
一个数据包被分段后

487
00:36:36,246 --> 00:36:40,673
然后我们根据数据名称过滤多个片段。

488
00:36:40,673 --> 00:36:45,712
我们还构建了最佳尽力控制的最后鲁棒多播系统。

489
00:36:45,712 --> 00:36:48,240
该协议不需要任何设置，

490
00:36:48,240 --> 00:36:52,538
不需要在通信过程中或创建多播组名称时进行任何设置，

491
00:36:52,538 --> 00:36:55,142
传统MAC中存在的类似系统。

492
00:36:55,142 --> 00:36:58,540
并且在所有接收器中提供了较低的控制损耗，

493
00:36:58,540 --> 00:37:01,010
我们测试了多达15个接收器。

494
00:37:01,010 --> 00:37:05,130
我们有一篇论文，详细讨论了确切的实现方式以及

495
00:37:05,130 --> 00:37:08,742
协议设计将出现在SEC 20中，以及

496
00:37:08,742 --> 00:37:11,285
名字在脚注的最底部。

497
00:37:11,285 --> 00:37:14,702
为了展示V-MAC作为NFD面部使用的性能，

498
00:37:14,702 --> 00:37:18,513
我们有一个测试平台，它使用树莓派并且使用V alpha无线电调制解调器，

499
00:37:18,513 --> 00:37:23,480
它们是市面上常见的、价格便宜的无线电调制解调器，任何人都可以轻易购得。

500
00:37:23,480 --> 00:37:26,882
我们正在进行内核模块的第三次迭代，

501
00:37:26,882 --> 00:37:29,989
它是为NFD集成配置的。

502
00:37:29,989 --> 00:37:33,321
我一会儿就让凯文播放一个视频。

503
00:37:33,321 --> 00:37:35,920
这个视频基本上是一个制作人和……

504
00:37:35,920 --> 00:37:39,672
十个消费者同时请求同一个视频。

505
00:37:39,672 --> 00:37:45,160
我们的传输速率是54 Mbps，视频大约2 MB大小。

506
00:37:45,160 --> 00:37:47,923
凯文，如果可以的话，请播放视频。

507
00:38:10,448 --> 00:38:14,984
谢谢，正如你之前看到的，临时的十个接收器中，

508
00:38:14,984 --> 00:38:20,692
在十个接收器中，只有两个能够播放该文件。

509
00:38:20,692 --> 00:38:25,620
在这两个接收器中，一个损失非常高，达到了68%，而另一个的损失更是高得多。

510
00:38:25,620 --> 00:38:29,684
与此同时，在V-MAC中，损失非常低，得到了很好的控制。

511
00:38:29,684 --> 00:38:33,192
所有十个接收器，0.5%及以下降至0.2%。

512
00:38:33,192 --> 00:38:36,393
我们还进行了进一步的实验，我们进行了静态实验。

513
00:38:36,393 --> 00:38:40,083
我们尝试了从3个消费者到15个消费者的临时广播和多点传送。

514
00:38:40,083 --> 00:38:44,917
在左图的左侧可以看到，对于临时广播，

515
00:38:44,917 --> 00:38:50,480
您将拥有b3，即三个消费者一个生产者，5、7、10、15。

516
00:38:50,480 --> 00:38:55,512
然后在采用V-MAC鲁棒性协议的多播结果之后。

517
00:38:55,512 --> 00:38:58,012
在所有接收器中进行临时广播，

518
00:38:58,012 --> 00:39:00,200
在所有接收器中进行临时广播，百分之四十到六十的比例始终存在，同时，当我们切换到V-MAC时，我们始终能保持低于5%的一致性。

519
00:39:00,200 --> 00:39:05,423
同时，当我们切换到V-MAC时，我们始终能保持低于5%的一致性。

520
00:39:05,423 --> 00:39:10,512
我们还进行了真实车辆实验，在实验中我们有四个消费者。

521
00:39:10,512 --> 00:39:14,854
在车队中，还有一名生产者使用54 Mbps的数据传输速率。

522
00:39:14,854 --> 00:39:20,630
速度是中等速度，大约25到35 Mbps，距离大约四英里。

523
00:39:21,750 --> 00:39:24,344
我们尝试了多种兴趣点，

524
00:39:24,344 --> 00:39:30,072
数据可以传输包括500个数据帧的数据包，这些是返回的兴趣点。

525
00:39:30,072 --> 00:39:34,591
如您在右图中看到的，丢包率得到控制，低于15%。

526
00:39:34,591 --> 00:39:39,085
即使是多次超出范围的接收器4，

527
00:39:39,085 --> 00:39:42,315
它仍然能够保持受控的丢失率。

528
00:39:42,315 --> 00:39:45,387
当我们尝试用同样的实验来做临时的安排时，效果并不好。

529
00:39:45,387 --> 00:39:47,298
由于接收器4和~!@#$%^&*()

530
00:39:47,298 --> 00:39:52,455
接收器3不断脱离网络，因为信标不断超时。

531
00:39:52,455 --> 00:39:55,292
它不断地加入和脱离网络，但这并没有奏效。

532
00:39:55,292 --> 00:39:56,197
未能接收到任何数据。

533
00:39:58,078 --> 00:40:01,706
因此将V与V-MAC集成，并使用V-MAC作为NFD的界面，

534
00:40:01,706 --> 00:40:04,611
我们获得了一个完整的数据中心化技术栈。

535
00:40:04,611 --> 00:40:09,979
我们获得了一个可控的丢包率，而不是在广播中变化的10到90%的丢包率。

536
00:40:09,979 --> 00:40:14,970
我们将获得1到5%的多播丢包率，对于静止的情况下少于15%的

537
00:40:14,970 --> 00:40:16,690
移动环境。

538
00:40:16,690 --> 00:40:18,430
我们的延迟并不高。

539
00:40:18,430 --> 00:40:21,480
它不到广播传输的2.5倍。

540
00:40:21,480 --> 00:40:26,695
大约25秒，风险最大，说V-MAC是15个接收器的多播控制损失。

541
00:40:26,695 --> 00:40:32,413
大约25秒，风险最大，说V-MAC是15个接收器的多播控制损失。

542
00:40:32,413 --> 00:40:39,155
我们实现了跨栈延迟的改善，这来自于软件

543
00:40:39,155 --> 00:40:43,355
我们将系统集成了，从固件一直到用户空间。

544
00:40:43,355 --> 00:40:48,000
我们将跨栈传输的延迟提高了60倍，并且

545
00:40:48,000 --> 00:40:52,495
我们将接收能力提高了100倍，同时也使系统具备了即席网络的互操作性，并且

546
00:40:52,495 --> 00:40:57,000
可以与任何常规WiFi共存，以适应不同环境。

547
00:40:57,000 --> 00:40:58,390
我们支持高数据传输速率。

548
00:40:59,690 --> 00:41:03,890
为了节省时间，不要急于为NFD面部处理这个问题。

549
00:41:03,890 --> 00:41:06,040
我们提供三种不同的媒体类型，

550
00:41:06,040 --> 00:41:10,400
我们提供的兴趣数据和公告正在被用于NACK。

551
00:41:10,400 --> 00:41:13,410
我们还提供了一个称为隐性兴趣的系统。

552
00:41:13,410 --> 00:41:17,040
隐性兴趣是一种内部订阅。

553
00:41:17,040 --> 00:41:21,220
因为V-MAC目前根据数据名称或属性进行过滤。

554
00:41:21,220 --> 00:41:24,420
如果你不订阅数据，它不会将数据转发给NFT。

555
00:41:24,420 --> 00:41:27,450
所以如果有人想订阅数据而不发送兴趣，

556
00:41:27,450 --> 00:41:29,460
您可以使用隐式回答。

557
00:41:29,460 --> 00:41:35,190
我们还有可配置的数据速率，适用于8至11岁的儿童，从1到65 MPs。

558
00:41:35,190 --> 00:41:40,190
该平台已经适用于Raspberry Pi，并且支持8至11ac的高达900 MPs的数据速率。

559
00:41:40,190 --> 00:41:46,232
该设备在Jetson上运行，使用mini PCIE适配器，那是他们的Wi-Fi芯片。

560
00:41:47,540 --> 00:41:51,200
我们未来的工作之一是完成集成准备，为代码审查做好准备，

561
00:41:51,200 --> 00:41:52,230
和测试。

562
00:41:52,230 --> 00:41:54,890
代码将于10月份提供给社区。

563
00:41:54,890 --> 00:41:58,390
我们需要社区的帮助来完成集成，以及

564
00:41:58,390 --> 00:42:01,830
验证我们的集成是否完整且成功。

565
00:42:01,830 --> 00:42:04,050
我们还可以提供V-MAC的源代码。

566
00:42:04,050 --> 00:42:07,630
如果有人感兴趣，请立即联系我，我们可以提供。

567
00:42:07,630 --> 00:42:10,540
我们还在研究多播帧率自适应技术，

568
00:42:10,540 --> 00:42:15,300
以适应数据速率而不是固定速率，这将改善延迟，

569
00:42:15,300 --> 00:42:17,650
以提高鲁棒性，并且还能减少一些丢包率。

570
00:42:18,660 --> 00:42:21,380
此外，我们还在努力支持更多的硬件设备。

571
00:42:21,380 --> 00:42:26,080
芯片支持更多不同的Wi-Fi适配器，这些适配器也可以在Android上使用。

572
00:42:26,080 --> 00:42:30,420
我们还面临着一些新的、有趣的以数据为中心的研究问题，比如生产者选择。

573
00:42:30,420 --> 00:42:33,980
可以用另一种方式来做，不是由生产者来决定

574
00:42:33,980 --> 00:42:38,970
我们可以让所有的生产者发送数据，以及

575
00:42:38,970 --> 00:42:41,710
然后通过媒介在传输过程中，

576
00:42:41,710 --> 00:42:46,240
消费者选择最适合他们的生产者，这样做非常有效。

577
00:42:46,240 --> 00:42:50,768
它在移动环境中可能显示出有希望的结果，其中动态特性需要

578
00:42:50,768 --> 00:42:55,550
链路持续变化，需要进行动态适配。

579
00:42:55,550 --> 00:42:57,620
他们也可以使用以数据为中心的方法。

580
00:42:58,740 --> 00:43:01,649
非常感谢张丽霞和Asavari Limaye的支持，以及

581
00:43:01,649 --> 00:43:04,356
开始努力将NFD和V-MAC进行整合，以及

582
00:43:04,356 --> 00:43:06,980
我很乐意回答你们的任何问题。

583
00:43:06,980 --> 00:43:11,010
>> 所以我注意到你基本上是在鼓励我们都去阅读一篇将会在11月出现的关于V-MAC的论文。

584
00:43:11,010 --> 00:43:14,370
将会在11月出现的关于V-MAC的。

585
00:43:14,370 --> 00:43:17,750
另一方面，你说这是一个软件实现。

586
00:43:17,750 --> 00:43:20,270
所以它只能在现有的Wi-Fi接口上工作。

587
00:43:20,270 --> 00:43:21,278
这是正确的吗？

588
00:43:21,278 --> 00:43:22,147
或者你有？

589
00:43:22,147 --> 00:43:25,560
对，我们确保了系统是关闭的 >> 是的

590
00:43:25,560 --> 00:43:28,570
我们确保了系统是关闭的。

591
00:43:28,570 --> 00:43:32,380
货架上的商品Wi-Fi适配器，因此研究社区中的任何人都可以

592
00:43:32,380 --> 00:43:35,500
立即使用它，而无需购买昂贵的硬件定制硬件。

593
00:43:35,500 --> 00:43:39,210
我们基本上是更改了芯片上的固件和SOC，以及

594
00:43:39,210 --> 00:43:40,920
我们彻底更改了内核栈。

595
00:43:40,920 --> 00:43:45,113
我们彻底消除了整个外层空间的MAC层。

596
00:43:45,113 --> 00:43:48,414
好的，所以那一年你们正在传输Wi-Fi频段，但是

597
00:43:48,414 --> 00:43:50,288
你们在做一些非常不同的事情。

598
00:43:50,288 --> 00:43:52,014
对，好的。

599
00:43:52,014 --> 00:43:55,820
对，好的，以及

600
00:43:55,820 --> 00:44:00,680
你所做的是你已经映射了一些频道或者

601
00:44:00,680 --> 00:44:06,940
你所做的是你已经映射了一些频道或者特定的频率到名称上，你是在变化上做的简单吗？还是在...上有所变化？

602
00:44:06,940 --> 00:44:10,690
我是说，你所做的很多事情的明显方法是去做一些...

603
00:44:10,690 --> 00:44:16,570
这些已经进行过的共享随机共享时钟方法，

604
00:44:16,570 --> 00:44:21,320
军事临时网络，那么何时唤醒以与不同的人交谈，以及

605
00:44:21,320 --> 00:44:24,240
没有发生过访问、加入或离开的情况。

606
00:44:24,240 --> 00:44:26,980
它完全是基于时钟的，你的是基于时钟的还是？

607
00:44:26,980 --> 00:44:30,180
它是基于NDN名称的还是基于其他的？

608
00:44:30,180 --> 00:44:35,740
它是使用其他什么方法来决定谁何时与谁通话吗？

609
00:44:35,740 --> 00:44:37,990
我们实际上依赖CSMA，好像，

610
00:44:37,990 --> 00:44:41,945
我们保持了CSMA，好像它是非常随机的访问方式。

611
00:44:41,945 --> 00:44:44,245
>> 好的，很酷。

612
00:44:44,245 --> 00:44:46,600
>> 谢谢。

613
00:44:46,600 --> 00:44:47,100
>> 谢谢。

614
00:44:48,570 --> 00:44:53,150
>> 看，我认为如果有人想提出问题的话，我们还有时间再回答一个问题。

615
00:44:53,150 --> 00:44:57,450
在聊天室里，否则，我就在这里结束会话。

616
00:44:57,450 --> 00:44:58,730
穆罕默德，那是一次愉快的交谈。

617
00:44:58,730 --> 00:45:00,928
谢谢。 >> 非常感谢。

618
00:45:00,928 --> 00:45:02,060
>> 好的。

619
00:45:02,060 --> 00:45:03,590
非常感谢。

620
00:45:03,590 --> 00:45:05,720
我想就是这样。

621
00:45:05,720 --> 00:45:07,120
>> 好的，非常感谢你，Craig。

622
00:45:08,390 --> 00:45:12,946
我们下一环节是关于发现和配置。

623
00:45:12,946 --> 00:45:15,400
是康卡迪亚大学的兼职教授，并将主持这一环节。

624
00:45:15,400 --> 00:45:20,490
是康卡迪亚大学的兼职教授，并将主持这一环节。

625
00:45:20,490 --> 00:45:23,100
他将负责管理这一环节。

626
00:45:23,100 --> 00:45:24,260
>> 好的，太好了。

627
00:45:24,260 --> 00:45:25,200
嘿。

628
00:45:25,200 --> 00:45:30,360
所以，是的，我们将进入这最后一个但同样重要的环节，

629
00:45:30,360 --> 00:45:35,630
所以，是的，我们将进入这最后一个但同样重要的环节，在这里我们将探讨发现，我认为这是极其重要的。

630
00:45:35,630 --> 00:45:39,750
实际上，这对我来说很重要，我希望它对人们也同样重要，

631
00:45:39,750 --> 00:45:44,910
我们所做的一切都是围绕数据为中心的系统。

632
00:45:44,910 --> 00:45:48,330
第一场演讲是由John Della Version进行的。

633
00:45:48,330 --> 00:45:53,320
一位在加州大学洛杉矶分校与Lixia合作的二年级博士研究生。

634
00:45:53,320 --> 00:46:00,300
他是一个地道的洛杉矶人，在洛杉矶出生并长大。

635
00:46:00,300 --> 00:46:04,250
他在物理学专业获得了本科学位，

636
00:46:04,250 --> 00:46:07,870
他在阿默斯特获得了计算机科学专业的学位，这个学校离我现在的位置很近。

637
00:46:07,870 --> 00:46:12,330
与此同时，加利福尼亚州和马萨诸塞州在一起......

638
00:46:12,330 --> 00:46:15,190
在MDN上发现了一些东西。

639
00:46:15,190 --> 00:46:16,443
那就开始吧，约翰。

640
00:46:16,443 --> 00:46:20,540
>> [同时讲话] >> 我会给每个人计时10分钟。

641
00:46:20,540 --> 00:46:23,520
所以请尽量留出时间来回答问题。

642
00:46:23,520 --> 00:46:25,450
所以再次感谢你，约翰。

643
00:46:25,450 --> 00:46:25,950
请继续。

644
00:46:26,980 --> 00:46:27,480
>> 大家好。

645
00:46:27,480 --> 00:46:30,880
非常感谢大家来参加MDN即插即用的讲座。

646
00:46:30,880 --> 00:46:35,022
作品本身是由Eric Newbery完成的，请给我发消息。

647
00:46:35,022 --> 00:46:38,360
The work itself was completed by Eric Newbery, please message me. So with that in mind, a natural question you might have is why the presenter is attracted to Lamberson.

648
00:46:38,360 --> 00:46:41,740
所以考虑到这一点，你可能会自然而然地产生一个问题。

649
00:46:41,740 --> 00:46:44,040
考虑到这个演讲的名称是什么是即插即用。

650
00:46:44,040 --> 00:46:46,040
那我们就继续进行吧。

651
00:46:46,040 --> 00:46:50,050
为了这次演讲的目的，我把它分成了两部分。

652
00:46:50,050 --> 00:46:54,160
所以首先是配置，这是所谓的插头概念。

653
00:46:54,160 --> 00:46:57,610
这是必需的设置，以便实际与其他节点通信。

654
00:46:57,610 --> 00:46:58,700
在网络上。

655
00:46:58,700 --> 00:47:01,530
其次，我们有平面海洋，即可达性。

656
00:47:01,530 --> 00:47:04,070
您如何在网络上找到其他节点？

657
00:47:04,070 --> 00:47:06,160
您如何找到您想要交谈的人？

658
00:47:06,160 --> 00:47:09,220
在这次讨论中，我们希望比较这些目标，或者

659
00:47:09,220 --> 00:47:12,090
比较这两个步骤在IP和NDN之间的差异。

660
00:47:12,090 --> 00:47:16,340
理想情况下，在NDN中定义一些步骤来说明我们如何做这件事，并且

661
00:47:16,340 --> 00:47:17,320
从中学到一些东西。

662
00:47:18,590 --> 00:47:22,010
所以抱着这样的想法，是的，很好。

663
00:47:22,010 --> 00:47:26,580
所以我们首先从IP配置开始，IP配置的目标是

664
00:47:26,580 --> 00:47:30,560
配置的目的非常简单，就是要实现与全球互联网的连接。

665
00:47:30,560 --> 00:47:33,060
在这种插入的概念中，

666
00:47:33,060 --> 00:47:36,570
您将一个节点插入到现有的连接IP基础设施中，或者

667
00:47:36,570 --> 00:47:42,360
一些半固定的拓扑结构，其目的是能够与其他节点进行通信，这些节点

668
00:47:42,360 --> 00:47:45,980
是接入并连接到该基础设施或仅仅是拓扑结构的。

669
00:47:45,980 --> 00:47:50,520
如果我们想要将其形象化，我们可以想象在更大的互联网之中，

670
00:47:50,520 --> 00:47:51,720
一些狭窄的切片。

671
00:47:51,720 --> 00:47:52,650
我们有一些节点，

672
00:47:52,650 --> 00:47:57,360
它们具有任意的IP地址，并连接到一些路由器集。

673
00:47:57,360 --> 00:47:59,500
为了实际加入网络，

674
00:47:59,500 --> 00:48:03,300
为了实际加入网络，一个新节点必须连接到某个DHCP服务器，检索一个IP地址，

675
00:48:03,300 --> 00:48:06,270
你的子网掩码、默认网关，可能还有一个DNS服务器。

676
00:48:06,270 --> 00:48:10,730
那么一旦连接上了，一旦你得到了这四样东西，

677
00:48:10,730 --> 00:48:13,510
配置完成后，你就连接上了。

678
00:48:13,510 --> 00:48:15,680
配置完成后，你就连接上了。

679
00:48:15,680 --> 00:48:18,130
你就可以和网络内的其他节点进行通信。

680
00:48:19,380 --> 00:48:22,460
然后因为IP只是关于连接性，

681
00:48:22,460 --> 00:48:27,530
一切涉及信任的事务都必然会发生在更高的层次上。

682
00:48:27,530 --> 00:48:31,520
这可能会引入一些漏洞并错失一些机会，

683
00:48:31,520 --> 00:48:35,850
因为仅凭IP地址，你无法确定自己是否在和正确的对方通话。

684
00:48:35,850 --> 00:48:41,130
我想要说明的一种漏洞类型是DDoS攻击。

685
00:48:42,230 --> 00:48:45,090
你可以伪造源地址，你可以做到

686
00:48:45,090 --> 00:48:49,780
重定向攻击假装你是别人，等等。

687
00:48:49,780 --> 00:48:54,360
因为在这个层面上，你无法验证真实性，而且

688
00:48:54,360 --> 00:48:57,610
这可能会导致很多损害，正如我们都见证过的那样。

689
00:48:57,610 --> 00:49:01,430
而第二，我们在这里见证了错失良机的例子，那种你本可以……

690
00:49:01,430 --> 00:49:05,740
真的很喜欢围绕交谈设计的基础设施。

691
00:49:05,740 --> 00:49:10,040
位于两个相对本地节点或主机的边缘，但你不能，

692
00:49:10,040 --> 00:49:12,990
因为你没有办法去验证真实性。

693
00:49:12,990 --> 00:49:15,830
因此，这种情况往往导致了很多错失的机会，或者

694
00:49:15,830 --> 00:49:19,970
因此，这种情况往往导致了很多错失的机会，或者对于所有事情都上云等等。So with that in mind, we can sort of briefly talk about the play of notion,

695
00:49:19,970 --> 00:49:24,076
因此，考虑到这一点，我们可以简要地谈谈概念的运用。

696
00:49:24,076 --> 00:49:27,210
IP可达性，归根结底这是相当简单的。

697
00:49:27,210 --> 00:49:29,208
配置完成后，

698
00:49:29,208 --> 00:49:32,058
一旦你能和每个人通信，你要么将其发送到本地网络，要么

699
00:49:32,058 --> 00:49:33,545
你将其发送到默认网关。

700
00:49:33,545 --> 00:49:37,080
网络会负责将其送达正确的地点或正确的主机。

701
00:49:38,480 --> 00:49:42,902
所以最终，我们可以继续探讨或许更有趣的概念，

702
00:49:42,902 --> 00:49:45,040
NDN配置。

703
00:49:45,040 --> 00:49:50,874
那么，如果IP配置是将主机接入固定基础设施，或者

704
00:49:50,874 --> 00:49:53,236
半固定基础设施。

705
00:49:53,236 --> 00:49:57,810
NDN配置是将新实体插入应用程序命名空间中。

706
00:49:57,810 --> 00:50:01,274
由于应用程序命名空间内存在信任关系，因此

707
00:50:01,274 --> 00:50:06,460
我们也在该命名空间内继承了与其他名称相关的信任关系。

708
00:50:06,460 --> 00:50:11,010
需要特别指出的是，因为我们在这里建立信任，

709
00:50:11,010 --> 00:50:16,650
因为我们在这里同时启动名称和安全性，真实性至关重要。

710
00:50:16,650 --> 00:50:22,419
如果你稍微搞砸了，那你就得在接下来的过程中暂停。

711
00:50:23,530 --> 00:50:28,870
但正如我所说，这个配置过程全都关乎命名和安全性。

712
00:50:28,870 --> 00:50:31,240
实际上，整个配置过程，

713
00:50:31,240 --> 00:50:35,900
可以被封装在首先，从某个相关应用程序获取一个名称中。其次，从信任锚点获取证书。

714
00:50:35,900 --> 00:50:39,360
其次，从信任锚点获取证书。

715
00:50:39,360 --> 00:50:41,700
其他一切都是可以自动化的，

716
00:50:41,700 --> 00:50:44,590
您可以从信任模式中检索一个信任锚点。

717
00:50:44,590 --> 00:50:47,860
You can retrieve a trust anchor from the trust model.

718
00:50:47,860 --> 00:50:50,400
你可以自动发现命名空间。

719
00:50:50,400 --> 00:50:55,066
值得注意的是，NDN配置，

720
00:50:55,066 --> 00:50:59,557
有别于IP配置，这不是一次性的事情。

721
00:50:59,557 --> 00:51:06,983
一个在网络上的NDN实体，实际上可以获得一个新的证书或者

722
00:51:06,983 --> 00:51:11,023
甚至还可以获得一个新的名称等等。

723
00:51:11,023 --> 00:51:15,581
我们还没有在你开发的代码中探索过的是，但是

724
00:51:15,581 --> 00:51:18,057
使用某种NDN配置的一部分。

725
00:51:18,057 --> 00:51:22,567
当然，你参与的是应用命名空间，

726
00:51:22,567 --> 00:51:25,250
相比之下，在基础设施或拓扑结构方面。

727
00:51:25,250 --> 00:51:26,350
也是使得NDN如此

728
00:51:26,350 --> 00:51:29,101
擅长使用这种配置适应移动性。

729
00:51:30,142 --> 00:51:34,722
因为你每次搬地方时都不需要重新获得证书，或者

730
00:51:34,722 --> 00:51:38,702
更换你所连接的路由器或其他相关设备。

731
00:51:38,702 --> 00:51:42,885
因此，如果我们想要直观地了解NDN配置，

732
00:51:42,885 --> 00:51:47,784
我们可能会再次选取一些小样本或一些小型网络。

733
00:51:47,784 --> 00:51:52,731
在这里，我们有一些主机，它们有一些类似示例的信任模式。

734
00:51:52,731 --> 00:51:57,756
然后有两个信任锚点，在这种情况下我们有两个不同的命名空间/ndn/home。

735
00:51:57,756 --> 00:52:02,444
因此，如果一个新实体想要加入网络，它所需要做的，或者它必须做的，就是首先从它运行的那种应用程序中获取一个名称。

736
00:52:02,444 --> 00:52:07,229
所需要做的，或者它必须做的，就是首先从它运行的那种应用程序中获取一个名称。

737
00:52:07,229 --> 00:52:10,021
然后从锚点获取一个证书，

738
00:52:10,021 --> 00:52:15,013
如果它想要在命名空间/home/p下或前缀/home/p下发布。

739
00:52:15,013 --> 00:52:18,030
他们必须从信任锚2处获得一个证书，

740
00:52:18,030 --> 00:52:20,130
它在某种程度上运行管理家庭。

741
00:52:22,620 --> 00:52:24,430
如果你想让我在幻灯片上停留一会儿，

742
00:52:24,430 --> 00:52:26,270
如果你想要我回到那个话题，请告诉我。

743
00:52:26,270 --> 00:52:31,228
但是，从这里开始，我们就要处理好插头方面的问题了。

744
00:52:31,228 --> 00:52:36,650
但是，从这里开始，我们就要处理好插头方面的问题了。接下来就是 NDN 配置的好处之一，我们可以开始进行实际操作了。

745
00:52:36,650 --> 00:52:39,150
而NDN的好处之一，

746
00:52:39,150 --> 00:52:42,110
这里有很多方法可以实现可达性。

747
00:52:42,110 --> 00:52:46,560
一旦你完成了配置的基本组件，你就可以

748
00:52:46,560 --> 00:52:50,920
或者使用NDN广播自学习来确定其他命名空间的位置。

749
00:52:50,920 --> 00:52:54,164
您可以使用NDND，也可以使用Ndn-autoconfig，

750
00:52:54,164 --> 00:52:58,680
与名称相反，它实际上并不是一个自动配置系统。[笑]

751
00:52:58,680 --> 00:53:00,577
它是一个很好的最近集线器系统，所以

752
00:53:00,577 --> 00:53:04,003
这显然属于可达性范畴。

753
00:53:04,003 --> 00:53:09,493
或者你可以使用NLSR进行路由选择。

754
00:53:09,493 --> 00:53:14,362
那么，我们开始吧。

755
00:53:14,362 --> 00:53:18,237
那么，从那里我们可以提出这个问题，如何实现即插即用，或者说，有哪些方法可以做到这一点？

756
00:53:18,237 --> 00:53:20,610
有哪些方法可以做到这一点？有哪些方式可以实现呢？

757
00:53:20,610 --> 00:53:24,316
而在我们看来，实现这一点的最佳方式可能是

758
00:53:24,316 --> 00:53:28,968
提供简单安全的方式，这里指的是真实可靠的方式。

759
00:53:28,968 --> 00:53:32,794
输入一个信任锚点、证书、乐队名称，以及

760
00:53:32,794 --> 00:53:36,863
然后尽我们所能自动化所有超出此范围的可达性。

761
00:53:36,863 --> 00:53:43,710
这在某种程度上是我们想象中的如何在IP领域复制该系统。

762
00:53:43,710 --> 00:53:45,930
连接到互联网，进行动态主机配置协议（DHCP）操作，然后就准备好随时插上即可使用。

763
00:53:45,930 --> 00:53:49,590
然后只需随时准备好即插即用。

764
00:53:49,590 --> 00:53:51,754
这确保了开发者或用户，因此

765
00:53:51,754 --> 00:53:55,395
他不需要担心超出必要部分的任何事情。

766
00:53:55,395 --> 00:53:58,676
以及必要的配置和引导程序部分。

767
00:54:02,134 --> 00:54:05,554
我们还继续开发了一些现有的代码。

768
00:54:05,554 --> 00:54:10,244
它的工作原理相对简单，它可以一跳之達地连接到其他设备，无论是通过 Wi-Fi 还是

769
00:54:10,244 --> 00:54:14,540
它确保你能够得到相关的部件，并覆盖以太网的范围。

770
00:54:15,760 --> 00:54:19,830
所以在这里，我们有一个快速的演示，我就直接去进行了

771
00:54:19,830 --> 00:54:20,750
为大家表演。

772
00:54:22,600 --> 00:54:25,620
我们有两个树莓派和一台Mac电脑。

773
00:54:27,340 --> 00:54:30,940
右边的Mac NFT已经启动，而树莓派没有。

774
00:54:30,940 --> 00:54:32,811
树莓派还没有运行。

775
00:54:33,980 --> 00:54:36,740
这三个设备通过以太网连接起来了，而且

776
00:54:36,740 --> 00:54:39,750
在Mac上，我们已经有一个服务器正在运行。

777
00:54:41,020 --> 00:54:44,270
这将生成一个信任锚证书架构，用于

778
00:54:44,270 --> 00:54:48,208
设备，并监听分发这些请求。

779
00:54:48,208 --> 00:54:53,180
在演示中我们将看到，树莓派将会

780
00:54:54,300 --> 00:54:58,770
从默认身份开始，然后它们将请求相关的数据位。

781
00:54:58,770 --> 00:54:59,480
它会获取它们并且

782
00:54:59,480 --> 00:55:01,850
它们将被安装在一种硬编码的位置。

783
00:55:03,560 --> 00:55:06,992
尽管在这个演示中，服务器是负责分配名称的，

784
00:55:06,992 --> 00:55:09,856
在这个演示中，虽然服务器是负责分配名称的，分配身份并不是必须的。

785
00:55:09,856 --> 00:55:14,730
以及代码本身确实支持树莓派或

786
00:55:14,730 --> 00:55:20,510
请求一个名称和服务器。

787
00:55:20,510 --> 00:55:25,235
然后可以判断是否会颁发该证书。

788
00:55:25,235 --> 00:55:27,599
或者你当然可以使用类似于NDN证书这样的东西，

789
00:55:27,599 --> 00:55:30,406
它会执行带外方法并且已经开发出来了。

790
00:55:33,653 --> 00:55:35,403
>> 约翰，你快没有时间了。

791
00:55:54,998 --> 00:55:58,692
>> 是的，从这里你可以看到我们将要打印出来

792
00:55:58,692 --> 00:56:03,423
相关的证书，相信我，它们都放在了正确的地方。

793
00:56:03,423 --> 00:56:08,340
所以从那里开始，仅仅简要地谈谈未来的方向，我们想要进一步

794
00:56:08,340 --> 00:56:12,460
澄清并明确IP与NDN配置之间的差异。

795
00:56:12,460 --> 00:56:15,676
我们想要开发用于实现可达性的自动化工具。

796
00:56:15,676 --> 00:56:20,320
关于配置的话题，我们还想让它更加灵活。

797
00:56:20,320 --> 00:56:24,380
所以你可以多次进行这个配置过程，以检索不同的内容，比如

798
00:56:24,380 --> 00:56:29,250
因此，可以使用更多的身份标识或不同的证书等等。

799
00:56:29,250 --> 00:56:33,752
所以总的来说，IP配置仅仅关注于连通性，因此

800
00:56:33,752 --> 00:56:36,151
主机可以发送和接收IP数据包。

801
00:56:36,151 --> 00:56:39,227
应用程序本身还必须配置安全性，

802
00:56:39,227 --> 00:56:43,487
它伴随着一些漏洞和缺点。

803
00:56:43,487 --> 00:56:46,596
然而，NDN实体的命名来自于应用程序，并且

804
00:56:46,596 --> 00:56:48,720
然后配置它们的安全性。

805
00:56:48,720 --> 00:56:53,009
这需要对名称和安全措施进行引导设置，

806
00:56:53,009 --> 00:56:55,737
这反过来又需要真实性。

807
00:56:55,737 --> 00:56:59,180
然后一旦你配置好了，你就可以通过多种方式进行可达性测试。

808
00:56:59,180 --> 00:57:01,000
然后，这就是我们看到插件和

809
00:57:01,000 --> 00:57:05,150
在未来的命名数据网络中进行播放。

810
00:57:05,150 --> 00:57:06,890
这就是我所知道的全部内容。

811
00:57:06,890 --> 00:57:11,177
所以如果有人有任何问题，我都欢迎提问。

812
00:57:11,177 --> 00:57:15,594
嗯，聊天里有一些问题，

813
00:57:15,594 --> 00:57:22,347
我建议你这么做，因为我们完全没有时间了。

814
00:57:22,347 --> 00:57:23,720
>> 当然，对此我感到抱歉。

815
00:57:23,720 --> 00:57:25,235
>> 我认为我们应该搬家。

816
00:57:25,235 --> 00:57:29,432
好的，请查看聊天记录，并回答聊天中的问题。

817
00:57:29,432 --> 00:57:32,030
那么现在我们来进行第二个演讲。

818
00:57:33,820 --> 00:57:38,605
那么演讲将由Saurab Dulal来进行。

819
00:57:38,605 --> 00:57:43,390
他目前正在孟菲斯大学攻读计算机科学博士学位。

820
00:57:43,390 --> 00:57:48,320
他目前正在孟菲斯大学攻读计算机科学，并且自2017年起参与NDN研究。

821
00:57:48,320 --> 00:57:53,838
自2017年起参与NDN研究。

822
00:57:53,838 --> 00:57:58,729
在路由、物联网等研究领域，

823
00:57:58,729 --> 00:58:06,154
在NDN中进行数据同步，所以Saurab，请。>> Thank you so much.

824
00:58:06,154 --> 00:58:07,786
>> 非常感谢你。

825
00:58:07,786 --> 00:58:08,870
大家好。

826
00:58:10,270 --> 00:58:15,876
所以今天我将要介绍的研究是NDNSD。

827
00:58:15,876 --> 00:58:18,190
它是NDN中的服务发布和发现。

828
00:58:19,280 --> 00:58:23,427
所以我是Saurab Dulal，我来自孟菲斯大学。

829
00:58:23,427 --> 00:58:27,396
因此，在现代应用程序中，服务发现非常重要，

830
00:58:27,396 --> 00:58:29,911
因此，在现代应用程序中，服务发现非常重要，无论是物联网还是移动应用程序。There are so many use cases of it like discovering printer,

831
00:58:29,911 --> 00:58:33,513
在现代应用程序中，服务发现的用例非常多，比如发现打印机，

832
00:58:33,513 --> 00:58:35,545
服务存储设备等。

833
00:58:35,545 --> 00:58:38,887
所以当我们在进行这个建筑管理系统项目时，我们面临着

834
00:58:38,887 --> 00:58:42,558
多个挑战，因为在NDM中缺乏服务发现机制，

835
00:58:42,558 --> 00:58:44,940
我们不得不进行大量的手动配置。

836
00:58:46,040 --> 00:58:48,715
我们开始研究一些现有的解决方案，

837
00:58:48,715 --> 00:58:51,727
我们发现有些解决方案是集中式的。

838
00:58:51,727 --> 00:58:56,470
因此所有的解决方案都局限于非常特定的环境中。

839
00:58:56,470 --> 00:59:01,026
在大多数解决方案中，我们发现缺少高级别的应用程序编程接口（API）。

840
00:59:01,026 --> 00:59:05,840
因此，应用程序不得不处理较低级别的网络原语。

841
00:59:07,982 --> 00:59:12,639
因此，我们的主要研究目标是设计一个通用的

842
00:59:12,639 --> 00:59:17,309
因此，我们的主要研究目标是设计一个通用的，目的是为NDN设计一个分布式服务发现协议，并且可以支持各种类型的服务和。

843
00:59:17,309 --> 00:59:19,837
应用场景。

844
00:59:19,837 --> 00:59:22,400
覆盖广泛的环境。

845
00:59:22,400 --> 00:59:25,675
我们还希望开发一个可重用的库组件以及

846
00:59:25,675 --> 00:59:27,515
同时提供更高层次的API。

847
00:59:27,515 --> 00:59:31,524
因此，这将便于应用开发人员实现他们自己的逻辑，

848
00:59:31,524 --> 00:59:35,421
因此，这将避免应用开发人员处理那些较低层次的网络原语所带来的麻烦。

849
00:59:35,421 --> 00:59:38,359
但显而易见的可能解决方案是进行洪泛，淹没网络，

850
00:59:38,359 --> 00:59:39,872
消费者将会大量发出请求。

851
00:59:39,872 --> 00:59:43,801
无论是谁提供服务，我们都将响应请求。

852
00:59:43,801 --> 00:59:47,970
但是当这个网络的规模增长时，事情将开始变得复杂。

853
00:59:47,970 --> 00:59:51,596
显然，洪泛式方法是无法扩展的。

854
00:59:51,596 --> 00:59:58,212
另一种解决方案是将发现过程移至一个集合点或云端。

855
00:59:58,212 --> 01:00:00,071
但是这种解决方案存在一些问题。

856
01:00:00,071 --> 01:00:03,088
我们不想要一个中心化的解决方案，因为它可能导致单点

857
01:00:03,088 --> 01:00:04,050
故障的单点。

858
01:00:04,050 --> 01:00:07,012
它甚至可能会有额外的计算时间，即使对于

859
01:00:07,012 --> 01:00:10,895
这种服务彼此非常接近。

860
01:00:10,895 --> 01:00:12,980
他们必须承担这个额外的往返。

861
01:00:12,980 --> 01:00:17,366
在某些情况下，也可能存在一些外部依赖。

862
01:00:17,366 --> 01:00:18,800
所以我们不希望有一个中心化的解决方案。

863
01:00:18,800 --> 01:00:21,384
所以我们想要的是一种去中心化的东西。

864
01:00:21,384 --> 01:00:25,070
所以我们的解决方案是按照服务类型对服务进行分组。

865
01:00:25,070 --> 01:00:29,216
例如，打印机、服务器或者类似的故事，

866
01:00:29,216 --> 01:00:32,237
取决于它们是什么类型的服务。

867
01:00:32,237 --> 01:00:36,125
并使用同步协议来同步服务的元数据。

868
01:00:36,125 --> 01:00:38,150
使用通用名称前缀。

869
01:00:38,150 --> 01:00:41,163
例如，打印机将使用这个名称前缀，而

870
01:00:41,163 --> 01:00:42,710
服务器将位于下方。

871
01:00:42,710 --> 01:00:47,010
先生，很抱歉打扰一下，但您的幻灯片没有切换。

872
01:00:47,010 --> 01:00:49,692
您还停留在标题幻灯片上。

873
01:00:49,692 --> 01:00:53,330
>> 好的，那么- >> 是的，现在它在动了。

874
01:00:54,750 --> 01:00:58,644
>> 好的，那么我们现在是在我们的解决方案幻灯片上吗。

875
01:00:58,644 --> 01:01:00,954
>> 是的。

876
01:01:00,954 --> 01:01:02,809
>> 好的，所以这些是我错过的幻灯片。

877
01:01:02,809 --> 01:01:04,031
我应该走吗？

878
01:01:04,031 --> 01:01:07,576
好的，我会从这里开始。

879
01:01:07,576 --> 01:01:11,333
所以解决方案是根据服务端来对服务进行分组，

880
01:01:11,333 --> 01:01:13,020
这是打印机和服务器。

881
01:01:13,020 --> 01:01:17,079
正如我之前所说，使用同步协议进行同步。

882
01:01:17,079 --> 01:01:22,031
服务将使用公共名称前缀，也就是打印机将使用这个命名空间，

883
01:01:22,031 --> 01:01:24,880
服务器也将使用这个命名空间等等。

884
01:01:26,010 --> 01:01:29,143
我们提供了一个定义明确的高级API。

885
01:01:29,143 --> 01:01:32,326
目前我们提供了服务发布者API和服务定位器API。

886
01:01:32,326 --> 01:01:35,432
服务发布者API用于发布服务，以及

887
01:01:35,432 --> 01:01:37,968
定位器API用于定位服务。

888
01:01:37,968 --> 01:01:41,291
所以如果你看这个流程图，这就是一个发布者。

889
01:01:41,291 --> 01:01:45,544
应用程序接收来自用户的请求以发布服务，并且

890
01:01:45,544 --> 01:01:48,950
它将使用同步来发布服务。

891
01:01:48,950 --> 01:01:51,843
如果服务已经在网络上存在，比如说打印机，

892
01:01:51,843 --> 01:01:55,271
如果服务名称打印机已经存在，那么它将直接以该名称发布。

893
01:01:55,271 --> 01:01:59,095
如果服务不存在，例如，我想创建一个群组用于

894
01:01:59,095 --> 01:02:00,356
一个游戏应用程序。

895
01:02:00,356 --> 01:02:05,335
然后NNEFI会指定一些服务类型，这些服务将会即时创建。

896
01:02:05,335 --> 01:02:08,643
它将会在整个网络中进行广播。

897
01:02:08,643 --> 01:02:11,802
在定位器这一端，如果比如说有一些请求进来，

898
01:02:11,802 --> 01:02:13,670
我想查看所有的打印机。

899
01:02:13,670 --> 01:02:17,083
然后定位器应用程序将获取所有的名称，

900
01:02:17,083 --> 01:02:21,742
对应的名称，这些名称基本上是应用程序的名称。

901
01:02:21,742 --> 01:02:24,310
稍后我会在后面的幻灯片上讨论这些名称。

902
01:02:24,310 --> 01:02:28,226
我将会适配这些名称，然后对应个别的服务信息。

903
01:02:28,226 --> 01:02:30,453
我将会回复用户。

904
01:02:30,453 --> 01:02:33,735
例如，打印机一，这是服务信息，以及打印机二和

905
01:02:33,735 --> 01:02:36,940
这是服务，也是提供的粗略服务。

906
01:02:36,940 --> 01:02:40,908
所以逻辑是什么，我们使用单个水槽的原因是什么？

907
01:02:40,908 --> 01:02:42,255
服务发现。

908
01:02:42,255 --> 01:02:46,020
因此，同步提供者出现了，这简化了发现过程。

909
01:02:46,020 --> 01:02:49,758
因此，如果你看到了发现过程，那么它基本上是某人试图

910
01:02:49,758 --> 01:02:52,958
发布某项服务并且其他人尝试获取该服务。

911
01:02:52,958 --> 01:02:55,880
所以这是一种发布-订阅模型。

912
01:02:55,880 --> 01:03:00,693
所以我们决定使用同步，使用同步来实现非常灵活。

913
01:03:00,693 --> 01:03:06,336
因为几个参与方可以就一个共同的同步组达成一致，所以这对应用语义来说是有益的。

914
01:03:06,336 --> 01:03:08,757
而且不用关心所有那些细节，

915
01:03:08,757 --> 01:03:12,589
他们可以就一个共同的同步组达成一致，这样会非常好用。

916
01:03:12,589 --> 01:03:16,311
还有使用同步的其他好处，但是

917
01:03:16,311 --> 01:03:18,857
这是两个重要的好处。

918
01:03:18,857 --> 01:03:21,305
所以谈到设计特点，

919
01:03:21,305 --> 01:03:26,090
我们提供了一个分层的命名空间设计，它有两种类型的前缀。

920
01:03:26,090 --> 01:03:29,272
一个是发现前缀，另一个是应用前缀。

921
01:03:29,272 --> 01:03:32,111
所以发现前缀非常灵活，这将会

922
01:03:32,111 --> 01:03:36,750
根据服务提供商将要提供的服务类型来决定。

923
01:03:36,750 --> 01:03:41,339
例如，在这里，你可以看到有一条可以组织的路线。

924
01:03:41,339 --> 01:03:45,018
家中或任何地方，新路线下有一个发现。

925
01:03:45,018 --> 01:03:46,450
这些就是服务的类型。

926
01:03:46,450 --> 01:03:48,952
例如，图像处理就是一种服务类型，

927
01:03:48,952 --> 01:03:52,335
现在许多应用程序都关注这类服务。

928
01:03:52,335 --> 01:03:56,842
同样，表面上也可以有服务器打印机或任何其他计算机。

929
01:03:56,842 --> 01:04:00,217
同样，提供服务的这些服务可以

930
01:04:00,217 --> 01:04:04,032
可以归类到这个命名空间以及应用程序前缀或者

931
01:04:04,032 --> 01:04:07,570
可以归类到这个命名空间以及携带服务信息的应用程序前缀。

932
01:04:07,570 --> 01:04:10,730
所以，如果你看这个设计应用程序数据的命名空间设计，那么，

933
01:04:10,730 --> 01:04:14,840
这个组和之前的路线几乎是一样的。

934
01:04:14,840 --> 01:04:16,660
这就是实际的服务提供商。

935
01:04:16,660 --> 01:04:20,450
所以，打印机这个是为了服务提供商和服务信息。

936
01:04:20,450 --> 01:04:23,270
所以，打印机这个是为了服务提供商和服务信息，会有很多服务信息，比如它是什么样的printer it is and what kind of service it provides.

937
01:04:23,270 --> 01:04:25,260
它是什么样的打印机以及它提供哪些服务。

938
01:04:25,260 --> 01:04:29,000
类似地，更详细的信息也可以在这里找到，例如，

939
01:04:29,000 --> 01:04:33,400
打印机的位置，比如图书馆或者其他地方。

940
01:04:33,400 --> 01:04:36,600
所以，在同步级别上，这两个命名空间将会是，

941
01:04:36,600 --> 01:04:38,840
这个前缀将会这样使用。

942
01:04:38,840 --> 01:04:42,060
所以，打印机，这是一个服务组，同时这也是一个同步组。

943
01:04:43,150 --> 01:04:45,750
这是同步组将要处理的内容，基本上，

944
01:04:45,750 --> 01:04:46,526
同步将会执行。

945
01:04:46,526 --> 01:04:52,390
同步中将携带所有名称应用前缀，无论何时，

946
01:04:52,390 --> 01:04:57,335
无论谁获取这些内容，他们都可以检索到各自的服务信息。

947
01:04:58,460 --> 01:05:01,500
在我们的情况下，它是一个服务定位器。

948
01:05:01,500 --> 01:05:03,750
在我们的情况下，它是一个服务定位器，它基本上是一个服务细节。

949
01:05:03,750 --> 01:05:06,210
它基本上是一个服务细节。

950
01:05:06,210 --> 01:05:09,310
所以，这将为……提供一个很好的机会。

951
01:05:09,310 --> 01:05:11,146
因此，这将为推广服务发现协议提供一个很好的机会。

952
01:05:11,146 --> 01:05:15,011
因为在服务详情中，根据你提供的服务类型，

953
01:05:15,011 --> 01:05:17,694
您可以在这里尽可能地添加更多的描述。

954
01:05:17,694 --> 01:05:21,719
所以，例如，对于这里的这种特定类型的服务，图像处理，

955
01:05:21,719 --> 01:05:24,990
所以，描述在这里，发布在这里，还有一个永久期限。

956
01:05:26,110 --> 01:05:28,130
所以，基本上，这是用来……

957
01:05:28,130 --> 01:05:32,430
因此，某些类型的服务对于生命周期非常敏感。

958
01:05:32,430 --> 01:05:35,138
因此，我只提供这项服务50秒钟，

959
01:05:35,138 --> 01:05:36,935
它将在那一秒后过期。

960
01:05:36,935 --> 01:05:40,987
因此，我们结合服务的发布时间戳和这个生命周期来

961
01:05:40,987 --> 01:05:44,332
计算服务是已过期还是仍然有效，并且

962
01:05:44,332 --> 01:05:48,200
这些信息将被提供给服务定位器。

963
01:05:48,200 --> 01:05:50,090
这将有助于推广协议的通用性，以便

964
01:05:50,090 --> 01:05:52,580
这将有助于推广协议的通用性，以便它们可以实施自己的类型的，

965
01:05:52,580 --> 01:05:55,500
他们可以指定自己的服务细节类型。

966
01:05:55,500 --> 01:05:58,120
可以通过API提供这些信息，

967
01:05:58,120 --> 01:06:02,510
这些测量信息的法则也可以通过API提供。

968
01:06:02,510 --> 01:06:04,162
例如，到服务的往返时间。

969
01:06:04,162 --> 01:06:08,570
这包含了您可以提供给服务定位器的网络级别信息，以便

970
01:06:08,570 --> 01:06:12,580
这样它就可以执行QS或其他类型的事务。

971
01:06:12,580 --> 01:06:16,846
但是通过往返时间，人们可以查找最近的网关或中心。

972
01:06:16,846 --> 01:06:21,982
通过服务稳定性，如果服务定位器想要确定服务位置，

973
01:06:21,982 --> 01:06:26,746
稳定性，然后是周期性探测，NDNSD库可以执行周期性探测。

974
01:06:26,746 --> 01:06:31,660
探测然后找出如何同样地稳定服务，以及如何进行重传。

975
01:06:31,660 --> 01:06:36,600
计数到获取服务，这些信息可以通过API提供。

976
01:06:38,230 --> 01:06:40,326
其他重要方面是无障碍性。

977
01:06:40,326 --> 01:06:45,158
所以，获取服务信息的人可能需要被授权访问服务信息。

978
01:06:45,158 --> 01:06:48,810
授权访问服务信息。

979
01:06:48,810 --> 01:06:49,949
那么，你是如何保护的呢？

980
01:06:49,949 --> 01:06:52,494
那么，你是如何保护一些敏感信息不被未经授权的观众看到的呢？

981
01:06:52,494 --> 01:06:53,610
未经授权的观众？

982
01:06:54,830 --> 01:06:57,241
所以，我们计划使用基于名称的访问控制。

983
01:06:57,241 --> 01:06:59,467
拉丁文已经呈现。

984
01:06:59,467 --> 01:07:01,770
有时候，我会去NAC那边。

985
01:07:01,770 --> 01:07:05,090
所以，基本上，服务信息将会，内容即是

986
01:07:05,090 --> 01:07:09,070
所以，基本上，服务信息将会使用一个内容密钥，即是CK来加密。

987
01:07:09,070 --> 01:07:11,990
而这个内容密钥将会被解密、使用一个密钥进行加密，

988
01:07:11,990 --> 01:07:14,750
加密密钥，这个是从访问管理器中获得的。

989
01:07:14,750 --> 01:07:16,920
因此，这两部分内容都将提供给，

990
01:07:16,920 --> 01:07:19,540
将会传递给服务定位器。

991
01:07:19,540 --> 01:07:22,960
在服务定位器获取了这个内容之后，它将面临KDK，

992
01:07:22,960 --> 01:07:24,660
它是关键的解密密钥。

993
01:07:24,660 --> 01:07:27,050
解密这个内容密钥，然后，最终，

994
01:07:27,050 --> 01:07:28,700
解密这个内容并获取内容。

995
01:07:28,700 --> 01:07:31,420
那么，这是基于某种访问策略，

996
01:07:31,420 --> 01:07:35,380
如果用户被授权访问这些内容。

997
01:07:35,380 --> 01:07:39,792
如果他被授权，他就可以访问所有的方式。

998
01:07:39,792 --> 01:07:43,127
所以，这就是用例，也是我们的动机所在，即在这里，

999
01:07:43,127 --> 01:07:44,240
一切都开始了。

1000
01:07:44,240 --> 01:07:46,689
所以，我们正在做这个我已经提过的建筑管理系统项目。

1001
01:07:46,689 --> 01:07:51,112
这是一个简单的建筑管理系统项目，其中涉及的各方包括

1002
01:07:51,112 --> 01:07:53,250
参与方包括传感器、代码仓库和用户。

1003
01:07:53,250 --> 01:07:54,861
所以，基本的流程是，

1004
01:07:54,861 --> 01:08:00,112
传感器想要发现它可以插入数据的相应仓库。

1005
01:08:00,112 --> 01:08:04,420
因此，它将使用NDNSD来发现这些仓库。

1006
01:08:04,420 --> 01:08:06,488
例如，这些仓库将会，

1007
01:08:06,488 --> 01:08:10,720
愿意插入任何传感器将会产生的数据。

1008
01:08:10,720 --> 01:08:12,407
因此，它将会发现可能的仓库。

1009
01:08:12,407 --> 01:08:16,646
例如，这三个仓库就在这里，它通过NDNSD发现了这些仓库。

1010
01:08:16,646 --> 01:08:19,613
它将使用其中一个仓库来进行数据传输。

1011
01:08:19,613 --> 01:08:23,256
一旦仓库接收到数据，这些数据将会在所有这些仓库之间复制。

1012
01:08:23,256 --> 01:08:27,780
使用同步协议的仓库下面，然后数据将会被复制。

1013
01:08:27,780 --> 01:08:32,020
现在，一旦用户想要获取一些数据，它将会

1014
01:08:32,020 --> 01:08:37,580
首先发现那个特定仓库为哪些前缀服务提供数据。

1015
01:08:37,580 --> 01:08:40,390
所以，这是一个有趣的应用程序。

1016
01:08:40,390 --> 01:08:43,558
我给了你多几分钟，但我希望你已经快要完成了。

1017
01:08:43,558 --> 01:08:46,503
是的，我[不可辨识]。

1018
01:08:46,503 --> 01:08:48,412
他将会发现所有的前缀和

1019
01:08:48,412 --> 01:08:51,160
然后它将从仓库中获取相应的数据。

1020
01:08:51,160 --> 01:08:52,630
所以，这是一个完整的用例。

1021
01:08:52,630 --> 01:08:54,920
使用我们这里的发现协议，

1022
01:08:54,920 --> 01:08:57,530
手动进行所有这些配置将会非常痛苦。

1023
01:08:58,630 --> 01:08:59,801
所以，我们进行了一些初步评估。

1024
01:08:59,801 --> 01:09:04,169
我们在孟菲斯大学使用树莓派搭建了测试平台，并且

1025
01:09:04,169 --> 01:09:08,700
我们进行了一些关于距离和条件的实验。

1026
01:09:08,700 --> 01:09:12,649
这些是树莓派在邓恩大厅的分布情况，

1027
01:09:12,649 --> 01:09:14,300
孟菲斯大学。

1028
01:09:14,300 --> 01:09:16,707
我们还进行了有线和无线的模拟测试。

1029
01:09:16,707 --> 01:09:19,580
我们的实现是基于PSync之上的，

1030
01:09:19,580 --> 01:09:24,192
我们目前积极维护的同步协议就是Chronosync，而且

1031
01:09:24,192 --> 01:09:27,229
NDNSDs能够适配这两种协议。

1032
01:09:27,229 --> 01:09:31,180
因此，我想在这里分享的一个评估来自mini-NDN。

1033
01:09:31,180 --> 01:09:33,080
这是一个仿真实验。

1034
01:09:33,080 --> 01:09:38,190
因此，数据中涉及了多跳传输，这是一种多跳传输策略。

1035
01:09:38,190 --> 01:09:42,729
服务信息升级频率为每900毫秒，加上200毫秒的抖动。

1036
01:09:42,729 --> 01:09:45,830
这就是服务信息更新的频率。

1037
01:09:45,830 --> 01:09:47,941
每个生产者的升级总数是300次。

1038
01:09:47,941 --> 01:09:51,330
协议用户，PSync和Link-delay的延迟是10毫秒。

1039
01:09:51,330 --> 01:09:55,120
所以，你看，如果这样，你看这些延迟，那么这些是较低的，

1040
01:09:55,120 --> 01:09:58,120
比实际应有的延迟要少。

1041
01:09:58,120 --> 01:10:00,764
例如，这个的往返时间，

1042
01:10:00,764 --> 01:10:04,054
从发布者发布服务的那一刻起，

1043
01:10:04,054 --> 01:10:08,960
从发布者发布服务的那一刻起，同步将这些信息传播到消费者大约需要10毫秒，

1044
01:10:08,960 --> 01:10:12,769
所以，再获取服务信息又需要大约20毫秒，

1045
01:10:12,769 --> 01:10:17,029
大约是30毫秒，但它降到了25毫秒，以及

1046
01:10:17,029 --> 01:10:18,872
它发生在这里的所有跳数上。

1047
01:10:18,872 --> 01:10:23,135
所以，这很大程度上是由于NDN中的网络内缓存，同时也是由于同步多播。

1048
01:10:23,135 --> 01:10:25,340
也是由于同步多播。

1049
01:10:25,340 --> 01:10:27,020
因此，这减少了整体的延迟。

1050
01:10:27,020 --> 01:10:30,828
因此，这是使用多播的好处之一，多播并且

1051
01:10:30,828 --> 01:10:32,083
多播NDN。

1052
01:10:32,083 --> 01:10:34,274
总的来说，我们正在开发一个通用的，

1053
01:10:34,274 --> 01:10:37,468
我们正在开发一个通用的、分布式的服务发布和发现机制，用于NDN。

1054
01:10:37,468 --> 01:10:39,346
我们为NDN开发了一种发现机制。

1055
01:10:39,346 --> 01:10:43,642
我们为发现机制定义了明确的发布-订阅API和可复用的库组件。

1056
01:10:43,642 --> 01:10:47,910
我们将分享一些初步的评估和用例。

1057
01:10:47,910 --> 01:10:51,950
我们面临的一些现有困难是建立一个真实世界的

1058
01:10:51,950 --> 01:10:53,980
我们面临的一些现有困难是建立一个真实世界的测试床并进行实验。One of the problem that we faced was due to lack of multicast suppression in NFD.

1059
01:10:53,980 --> 01:10:58,010
我们面临的一个问题是由于NFD中缺乏多播抑制功能。

1060
01:10:58,010 --> 01:11:00,840
我们观察到大量的非请求数据和兴趣。

1061
01:11:00,840 --> 01:11:03,090
这导致了网络中的一个巨大问题。

1062
01:11:03,090 --> 01:11:07,853
所以，我们不能，实际上在做实验时我几乎无法进行

1063
01:11:07,853 --> 01:11:11,950
在一个跳的MESS设置中，超出10到12个节点。

1064
01:11:12,970 --> 01:11:17,010
因此，未来的工作是在mini-NDN中进行一些扩展实验。

1065
01:11:17,010 --> 01:11:19,820
还有，进行一些真实世界的多跳无线实验和

1066
01:11:19,820 --> 01:11:23,260
还要实现我之前看到的用例

1067
01:11:23,260 --> 01:11:26,290
还要完全实现我之前看到的用例，并进行更多的评估。

1068
01:11:27,390 --> 01:11:30,420
谢谢。

1069
01:11:30,420 --> 01:11:31,640
>> 非常感谢。

1070
01:11:31,640 --> 01:11:37,080
在我应该能查看的聊天中有很多活动。

1071
01:11:37,080 --> 01:11:41,916
为了掌握时间，因为真的很接近

1072
01:11:41,916 --> 01:11:46,102
为了掌握时间，因为真的很接近，当我们应该停下来而我们还有一个演讲时，I would suggest that we take the questions to the chat.

1073
01:11:46,102 --> 01:11:50,399
我建议我们把问题带到聊天中去。

1074
01:11:50,399 --> 01:11:52,679
>> 好的，当然可以。

1075
01:11:52,679 --> 01:11:54,530
>> 非常感谢您。

1076
01:11:54,530 --> 01:11:58,450
所以，这是最后一个，而且是最最后一个。

1077
01:12:00,170 --> 01:12:05,277
我们有来自Susmit Shannigrahi的演讲。

1078
01:12:05,277 --> 01:12:09,192
他是田纳西科技大学的助理教授。

1079
01:12:09,192 --> 01:12:15,074
我们正在大科学领域的网络方面进行研究，

1080
01:12:15,074 --> 01:12:21,493
我们显然还在研究未来的互联网架构以及5G移动网络。

1081
01:12:21,493 --> 01:12:26,674
他将与孔兆宁一起分享这个演讲，

1082
01:12:26,674 --> 01:12:29,222
他是普渡大学的一名博士研究生。

1083
01:12:29,222 --> 01:12:32,541
他曾在加州大学洛杉矶分校攻读硕士学位，并且显然也对网络系统和分布式系统感兴趣。

1084
01:12:32,541 --> 01:12:38,221
并且显然也对网络系统和分布式系统感兴趣。

1085
01:12:38,221 --> 01:12:42,918
他们还将讨论用于基因组数据集的NDN-Repo，

1086
01:12:42,918 --> 01:12:46,362
它是进展和未来的方向。

1087
01:12:46,362 --> 01:12:51,418
我认为很有趣，我们最后讨论的是

1088
01:12:51,418 --> 01:12:57,620
我们之所以讨论这个，是因为我认为我们最初是从大数据集的NDN演示开始的。

1089
01:12:57,620 --> 01:13:01,914
所以我们现在正在闭环，所以Susmit和

1090
01:13:01,914 --> 01:13:06,323
赵宁，请开始你的演讲。

1091
01:13:06,323 --> 01:13:08,740
>> 好的，太好了，感谢你的介绍。

1092
01:13:08,740 --> 01:13:14,861
正如你所说，我们正在结束我们在基因组学文档中开始的循环，

1093
01:13:14,861 --> 01:13:17,443
现在我们正在结束这个循环。

1094
01:13:17,443 --> 01:13:24,175
这次演讲的动机在于，Repo是一种通用存储，

1095
01:13:24,175 --> 01:13:30,172
它不一定只是为了基因组学社区。

1096
01:13:30,172 --> 01:13:36,271
但我们正在以基因组学为例，推动仓库的发展。

1097
01:13:36,271 --> 01:13:40,306
对于那些长期在NDN社区的人来说，

1098
01:13:40,306 --> 01:13:42,691
你可能还记得NDN-repo。

1099
01:13:42,691 --> 01:13:48,842
它又是同样的东西，它是一个持久性的仓库，用来存储数据包。

1100
01:13:48,842 --> 01:13:53,978
我们研究了基因组学的用例，并发现了一些差异。

1101
01:13:53,978 --> 01:13:58,780
我们需要在代码仓库的设计中加入这些内容。

1102
01:13:58,780 --> 01:14:05,923
我们将会审查这些内容，并提供一些实验结果。

1103
01:14:05,923 --> 01:14:10,443
但更重要的是，它仍然处于设计和实施阶段，所以

1104
01:14:10,443 --> 01:14:13,963
如果您有任何反馈，我们将非常感激。

1105
01:14:13,963 --> 01:14:19,966
[咳嗽] 好的，正如我们在第一场会议中看到的那样，大型科学数据集确实可以从NDN的基于名称的特性中受益。

1106
01:14:19,966 --> 01:14:25,292
数据集确实可以从NDN的基于名称的特性中受益。

1107
01:14:25,292 --> 01:14:29,161
和位置透明的网络。

1108
01:14:29,161 --> 01:14:32,581
这其中一个关键方面是要有存储设备。

1109
01:14:35,773 --> 01:14:41,548
我们需要科学数据集具备哪些属性？

1110
01:14:41,548 --> 01:14:45,760
它们必须支持非常大的数据集，

1111
01:14:45,760 --> 01:14:49,745
它们必须支持从太字节到拍字节不等的非常大的数据集。

1112
01:14:49,745 --> 01:14:55,136
我们已经用超过1太字节的数据测试了新的Python-Repo。

1113
01:14:55,136 --> 01:14:59,476
但在Graham的整体计划中，

1114
01:14:59,476 --> 01:15:05,184
这并不算太大，因此我们还有很长的路要走。

1115
01:15:05,184 --> 01:15:09,956
它应该提供文件级别的持久存储。

1116
01:15:09,956 --> 01:15:15,460
所以，即使NDN将文件分割成数据包，

1117
01:15:15,460 --> 01:15:19,488
我们是这么说的，因为所有这些

1118
01:15:19,488 --> 01:15:24,760
社区的运作单位是文件。

1119
01:15:24,760 --> 01:15:31,118
所以这样做是有道理的，与其把所有数据包放在一个地方，

1120
01:15:31,118 --> 01:15:36,503
我们应该以文件级粒度来存储数据。

1121
01:15:36,503 --> 01:15:40,200
它应该提供透明的数据访问权限给

1122
01:15:40,200 --> 01:15:45,280
请求者应当了解数据所在的位置。

1123
01:15:45,280 --> 01:15:49,192
以及为了可用性而进行了复制

1124
01:15:49,192 --> 01:15:51,922
地理分布的用户。

1125
01:15:51,922 --> 01:15:58,770
所以这些社区中的大多数都是相当国际化的。

1126
01:15:58,770 --> 01:16:06,385
因此，它们甚至是全国性分布的，所以我们不能只在一个地方有一个仓库，

1127
01:16:06,385 --> 01:16:11,549
告诉每个人去那里，那是不可扩展的。

1128
01:16:14,963 --> 01:16:17,199
所以对于基因组学的用例来说，

1129
01:16:17,199 --> 01:16:22,600
我们希望出版商能将数据集发布到仓库中。

1130
01:16:22,600 --> 01:16:28,430
他们可以使用自己社区定义的名称。

1131
01:16:28,430 --> 01:16:32,490
因此，如果同一个仓库存储的是物理学和基因组数据集，它应该同时支持社区定义的命名方案。

1132
01:16:32,490 --> 01:16:38,320
因此，如果同一个仓库存储的是物理学和基因组数据集，它应该同时支持社区定义的命名方案。

1133
01:16:38,320 --> 01:16:42,234
相反，不要说这是我在管理的一个仓库，

1134
01:16:42,234 --> 01:16:46,832
您从这里发布的所有内容都必须有相同的前缀。

1135
01:16:46,832 --> 01:16:52,930
第二点是数据会自动复制。

1136
01:16:52,930 --> 01:16:57,112
因此，复制的程度是由用例来定义的。

1137
01:16:57,112 --> 01:17:00,670
基因组学社区可能有三个复制程度，

1138
01:17:00,670 --> 01:17:02,010
其他人可能会有更多。

1139
01:17:04,620 --> 01:17:07,538
它应该能够自动维持复制的程度当

1140
01:17:07,538 --> 01:17:08,392
发生故障。

1141
01:17:08,392 --> 01:17:13,395
所以如果一个副本发生故障，它需要复制

1142
01:17:13,395 --> 01:17:18,660
所以如果一个副本发生故障，它需要复制那些失败的内容到另一个仓库实例中。

1143
01:17:18,660 --> 01:17:24,030
我们不打算深入了解细节，但理论上应该是这样运作的。

1144
01:17:25,330 --> 01:17:30,550
现在，需要知道的另一件事是，这个仓库是一个持久存储。

1145
01:17:30,550 --> 01:17:35,121
但在其基础之上，还有机会创建另外一层，

1146
01:17:35,121 --> 01:17:37,533
这支持不同的使用场景。

1147
01:17:37,533 --> 01:17:44,880
例如，在基因组学中，我们在仓库中有数据，但我们如何确定这些名字呢？

1148
01:17:44,880 --> 01:17:48,400
因此我们可以有一种独立的名字目录或者

1149
01:17:48,400 --> 01:17:52,410
数据库，科学家们可以去查找信息。

1150
01:17:53,870 --> 01:17:57,922
如果我们有另一个例子，可能是复制。

1151
01:17:57,922 --> 01:18:02,066
如果我们有某种逻辑，那么可能会说，

1152
01:18:02,066 --> 01:18:08,995
这些是科学家们正在使用的数据集中最顶尖的10%。

1153
01:18:08,995 --> 01:18:10,823
所以从亚历克斯的演讲来看，

1154
01:18:10,823 --> 01:18:16,321
你可能还记得有42佩他字节的基因组数据。

1155
01:18:16,321 --> 01:18:20,990
显然，所有这些都不能被多次复制。

1156
01:18:20,990 --> 01:18:25,641
因此，你可能会在仓库上方创建一个轻量级的层，这个层的作用是说，

1157
01:18:25,641 --> 01:18:30,401
这是一个非常受欢迎的数据集，可以从NDN中受益。

1158
01:18:30,401 --> 01:18:34,986
所以我们只会将那些数据集复制到仓库中。

1159
01:18:34,986 --> 01:18:41,576
所以这就是一个高层次的视角，接下来我将把它交给兆宁来负责。

1160
01:18:41,576 --> 01:18:45,693
实际的执行和细节。

1161
01:18:49,024 --> 01:18:50,581
>> 大家好，你们能听见我说话吗？

1162
01:18:51,785 --> 01:18:54,270
>> 是的。

1163
01:18:54,270 --> 01:18:56,817
>> 嗨，你能听见我吗？

1164
01:18:56,817 --> 01:18:59,546
>> 是的，我能听见你。

1165
01:18:59,546 --> 01:19:02,900
>> 好的，大家好，我的名字是兆宁，

1166
01:19:02,900 --> 01:19:05,832
我将完成这次谈话的剩余部分。

1167
01:19:05,832 --> 01:19:10,060
首先，我想从NDN-Repo的概述开始讲起。

1168
01:19:10,060 --> 01:19:13,843
所以，在幻灯片上，你可以看到有两个图表。

1169
01:19:13,843 --> 01:19:19,923
左边的图表展示了应用程序如何将文件插入到仓库中。

1170
01:19:19,923 --> 01:19:25,450
右边的图表展示了应用程序如何从仓库中检索数据。

1171
01:19:25,450 --> 01:19:28,512
所以，基本上这是一个反应式的过程。

1172
01:19:28,512 --> 01:19:31,005
仓库只是坐在那里等待着

1173
01:19:31,005 --> 01:19:35,762
应用程序用于发送请求，以进行插入或数据检索。

1174
01:19:35,762 --> 01:19:39,900
这是一个评估，下一张幻灯片，请？

1175
01:19:43,052 --> 01:19:48,102
那么，我们为什么要在NDN仓库上进行数据复制呢？

1176
01:19:48,102 --> 01:19:51,230
因此，首先通过部署一组分布式仓库节点，

1177
01:19:51,230 --> 01:19:55,452
等待通过整个系统的可用性和性能。

1178
01:19:55,452 --> 01:19:59,831
因为请求不必只发送到一个地方，

1179
01:19:59,831 --> 01:20:02,762
它可以发送到许多不同的地方。

1180
01:20:02,762 --> 01:20:07,540
为此，我们考虑使用任何测试，基本上是这样。

1181
01:20:08,990 --> 01:20:14,660
所有的仓库都可以发布相同的路由公告，而且

1182
01:20:14,660 --> 01:20:19,452
一个兴趣将被转发到最近的仓库。

1183
01:20:19,452 --> 01:20:25,274
通过在多个仓库节点上复制数据文件，

1184
01:20:25,274 --> 01:20:28,335
我们避免了单点故障。

1185
01:20:28,335 --> 01:20:33,061
为了实现这一点，我们考虑使用一致性哈希。

1186
01:20:33,061 --> 01:20:36,921
为了决定哪个文件应该被复制到哪个节点上。

1187
01:20:36,921 --> 01:20:40,194
接下来的几张幻灯片里，我将会讲解这是如何做到的。

1188
01:20:42,377 --> 01:20:44,189
下一张幻灯片，请。

1189
01:20:44,189 --> 01:20:49,525
所以，一致性哈希的高层次概念是

1190
01:20:49,525 --> 01:20:55,110
我们将存储库节点和文件都放置在同一个哈希环上。

1191
01:20:55,110 --> 01:20:57,898
所以正如你在右边的图表上看到的，

1192
01:20:57,898 --> 01:21:01,587
我们有多个仓库节点，比如A、B、C、D等等。

1193
01:21:01,587 --> 01:21:05,579
我们将这些节点哈希到一个哈希环上。

1194
01:21:05,579 --> 01:21:10,676
与此同时，我们也将文件或数据哈希到这个环上。

1195
01:21:10,676 --> 01:21:15,888
所以举个例子，假设有一个叫做filename的文件，

1196
01:21:15,888 --> 01:21:21,305
我们使用哈希函数H1并将其哈希到节点B和C之间的某个位置。

1197
01:21:21,305 --> 01:21:26,038
我们采用一个约定，即这个文件将会被复制，

1198
01:21:26,038 --> 01:21:31,459
将会被存储在比它小的最近的节点，这种情况下是节点B。

1199
01:21:32,742 --> 01:21:36,287
好的，所以为了提高水平，

1200
01:21:36,287 --> 01:21:40,426
我们还可以使用多个哈希函数，以便

1201
01:21:40,426 --> 01:21:45,997
以便同一个文件可以在多个节点上复制。

1202
01:21:48,277 --> 01:21:49,241
下一张幻灯片，请。

1203
01:21:53,216 --> 01:21:56,369
为了使一致性哈希工作正常运行，

1204
01:21:56,369 --> 01:22:00,750
为了使一致性哈希工作正常运行，我们需要有一个成员管理协议。

1205
01:22:00,750 --> 01:22:05,867
该协议使得每个仓库节点都能够全局查看所有节点的列表。

1206
01:22:05,867 --> 01:22:11,002
以便它们每个人都能够构建这样的环。

1207
01:22:11,002 --> 01:22:16,506
并且每个节点还需要迅速了解到一个新节点已经加入或者

1208
01:22:16,506 --> 01:22:18,975
一个现有的节点已经出现故障。

1209
01:22:18,975 --> 01:22:22,881
所以为了让这个工作正常运行，我们目前正在考虑

1210
01:22:22,881 --> 01:22:27,274
因此，每个节点会定期对它的下一个邻居发送ping信号。

1211
01:22:27,274 --> 01:22:33,565
这个ping消息将包含一个带有时间戳的成员列表。

1212
01:22:33,565 --> 01:22:38,559
这样这个成员列表将会在环中传递。

1213
01:22:38,559 --> 01:22:43,562
这样可以让每个人都知道当前成员列表的情况。

1214
01:22:43,562 --> 01:22:50,647
为了快速发现故障，我们可以广播故障消息，

1215
01:22:50,647 --> 01:22:55,923
以便它能立即传播给每个人。

1216
01:22:55,923 --> 01:23:00,218
为了让新节点加入，我们可以设置一个预定义的命名空间，用于

1217
01:23:00,218 --> 01:23:02,493
为了让新节点加入，我们可以设置一个预定义的命名空间，用于例子中的repo_group/join。每当有新节点加入时，它就可以向这个前缀发送一个兴趣。

1218
01:23:02,493 --> 01:23:08,797
每当有新节点加入时，它就可以向这个前缀发送一个兴趣。

1219
01:23:08,797 --> 01:23:16,010
这个兴趣将以任播的方式路由到其中一个节点，

1220
01:23:16,010 --> 01:23:21,223
该节点将把这个新节点加入到数组中。

1221
01:23:21,223 --> 01:23:24,431
是的，这就是我们处理会员管理的方式。

1222
01:23:24,431 --> 01:23:27,674
在下一张幻灯片中，我将讨论我们如何插入和

1223
01:23:27,674 --> 01:23:30,167
从这个复制的仓库中检索数据。

1224
01:23:30,167 --> 01:23:31,350
下一张幻灯片，请。

1225
01:23:34,242 --> 01:23:39,600
因此，为了将数据插入仓库，我们考虑使用任播技术。

1226
01:23:39,600 --> 01:23:43,445
物理上，应用程序发送插入请求，

1227
01:23:43,445 --> 01:23:48,990
这个请求将以任播方式路由至最近的邻居节点。

1228
01:23:48,990 --> 01:23:52,475
例如，在右边的图中，

1229
01:23:52,475 --> 01:23:55,729
假设这个请求被路由到了H。

1230
01:23:55,729 --> 01:24:00,664
然后节点H会查看这个哈希环，并决定，

1231
01:24:00,664 --> 01:24:05,929
好的，这个文件将会在节点B、D和F上进行复制。

1232
01:24:05,929 --> 01:24:11,316
然后它会通过这三个节点发送请求。

1233
01:24:11,316 --> 01:24:14,341
让他们复制这个文件。

1234
01:24:14,341 --> 01:24:17,580
从仓库中检索数据是一个类似的过程。

1235
01:24:17,580 --> 01:24:21,736
基本上，应用程序对其中一个节点感兴趣，但是

1236
01:24:21,736 --> 01:24:24,423
这个节点可能并不一定持有数据。

1237
01:24:24,423 --> 01:24:28,237
所以它会查看哈希环，然后做出决定，以及

1238
01:24:28,237 --> 01:24:31,132
确定哪个节点持有这个数据。

1239
01:24:31,132 --> 01:24:37,735
然后从那个节点检索文件，并将其发送回应用程序。

1240
01:24:37,735 --> 01:24:39,236
下一张幻灯片，请。

1241
01:24:43,368 --> 01:24:49,345
很抱歉打断一下，但是

1242
01:24:49,345 --> 01:24:52,485
您只剩下几分钟了。

1243
01:24:52,485 --> 01:24:54,767
>> 好的，这是我的最后一张幻灯片。

1244
01:24:54,767 --> 01:24:58,700
所以这里有两种情况，有一个现有的节点失败了。

1245
01:24:58,700 --> 01:25:03,298
在这种情况下，我们可以采用一个约定，即下一个顺时针方向的节点是

1246
01:25:03,298 --> 01:25:05,606
负责故障恢复。

1247
01:25:05,606 --> 01:25:09,847
例如，假设节点B发生了故障并且

1248
01:25:09,847 --> 01:25:13,979
节点D在这种情况下将负责

1249
01:25:13,979 --> 01:25:19,228
负责对它与B共享的文件进行故障恢复。

1250
01:25:19,228 --> 01:25:24,439
然后它查看哈希环并确定A将负责对它与B共享的文件进行故障恢复。

1251
01:25:24,439 --> 01:25:29,749
它会在B出故障后处理这些文件，并启动故障恢复过程。

1252
01:25:29,749 --> 01:25:33,032
当你了解了连接（joins）的时候，这也相当简单。

1253
01:25:33,032 --> 01:25:38,059
基本上，下一个顺时针方向的节点将会计算出哪些文件将被移动到新节点。

1254
01:25:38,059 --> 01:25:42,727
将会计算出哪些文件将被移动到新节点。

1255
01:25:42,727 --> 01:25:43,817
下一张幻灯片，请。

1256
01:25:46,613 --> 01:25:50,075
所以最后，我想谈谈一些未来的工作。

1257
01:25:50,075 --> 01:25:57,498
所以首先，我认为应该采取的一步是增强仓库的文件语义。

1258
01:25:57,498 --> 01:26:03,470
因为最初仓库的设计是用来存放单独的数据包的。

1259
01:26:03,470 --> 01:26:08,564
然而，在我们实际部署过程中，我们发现大多数应用程序，

1260
01:26:08,564 --> 01:26:12,154
将单个文件插入和从仓库中检索出来。

1261
01:26:12,154 --> 01:26:16,942
通过使用文件语义，一些事情可以设计得更简单。

1262
01:26:16,942 --> 01:26:21,231
例如，我刚才谈到的复制过程。

1263
01:26:21,231 --> 01:26:25,395
还有我认为更新仓库协议规范也很重要，并且

1264
01:26:25,395 --> 01:26:28,038
实现仓库复制过程。

1265
01:26:28,038 --> 01:26:30,527
我刚才谈到的算法。

1266
01:26:30,527 --> 01:26:35,258
我们还在考虑在Python仓库上发布一份技术报告，以及

1267
01:26:35,258 --> 01:26:36,653
实施情况。

1268
01:26:36,653 --> 01:26:39,040
好的，就这些，谢谢。

1269
01:26:42,320 --> 01:26:43,292
>> 非常感谢。

1270
01:26:43,292 --> 01:26:48,009
我们在聊天中又有了一些讨论。

1271
01:26:48,009 --> 01:26:52,096
我建议你看一看。

1272
01:26:52,096 --> 01:26:57,534
有几个问题和一些评论。

1273
01:26:57,534 --> 01:27:03,963
现在正好是下午5点，我们原定的结束时间是下午5点。

1274
01:27:03,963 --> 01:27:07,966
所以我要感谢大家坚持到现在。

1275
01:27:07,966 --> 01:27:11,984
长时间以来，感谢所有的演讲者。

1276
01:27:11,984 --> 01:27:17,755
我将把最后的部分交给Lofty来完成，我猜这就是结论了。

1277
01:27:17,755 --> 01:27:20,744
非常感谢大家。

1278
01:27:20,744 --> 01:27:27,482
好的，谢谢你，Marie Josie，我想我们已经到了NDN Count 2020的尾声了。

1279
01:27:27,482 --> 01:27:31,513
再次感谢所有的会议主席，

1280
01:27:31,513 --> 01:27:36,400
会议小组主席、小组成员以及所有的报告者。

1281
01:27:36,400 --> 01:27:42,376
只有几个简短的通知，一个是，下周您应该会收到一封电子邮件

1282
01:27:42,376 --> 01:27:48,111
来自NIST会议工作人员的请求，希望您就此次活动的情况提供反馈。

1283
01:27:48,111 --> 01:27:51,287
这是我们第一次远程举办NDN社区活动，所以

1284
01:27:51,287 --> 01:27:53,263
我相信我们下次能做得更好。

1285
01:27:53,263 --> 01:27:58,161
以及第二件事是，有些与会者在问我们是否会

1286
01:27:58,161 --> 01:28:00,038
制作幻灯片供大家使用。

1287
01:28:00,038 --> 01:28:04,118
我将给所有的演讲者发一封邮件，以获得他们的许可，将幻灯片发布到网上。

1288
01:28:04,118 --> 01:28:07,058
获得授权将幻灯片发布到网上。

1289
01:28:07,058 --> 01:28:13,135
再次感谢大家，下次见了。

1290
01:28:13,135 --> 01:28:14,394
再见，大家。

1291
01:28:14,394 --> 01:28:16,284
谢谢。

1292
01:28:16,284 --> 01:28:19,110
>> 非常感谢，顺便说一下，Lofty，

1293
01:28:19,110 --> 01:28:23,115
即使这是你第一次尝试，但进行得非常顺利。

1294
01:28:23,115 --> 01:28:25,970
恭喜你和你的团队。

1295
01:28:25,970 --> 01:28:28,683
>> 谢谢，我们会在这里见面的。

1296
01:28:32,833 --> 01:28:38,201
>> 好的，感谢NIST主办这次会议，我认为这是一次非常棒的会议。

1297
01:28:38,201 --> 01:28:39,723
谢谢。

