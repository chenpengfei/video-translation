1
00:00:00,410 --> 00:00:02,670
欢迎大家参加

2
00:00:02,670 --> 00:00:05,175
今天节目的第二环节

3
00:00:05,175 --> 00:00:06,930
专注于命名数据网络（NDN）

4
00:00:06,930 --> 00:00:09,305
针对数据密集型应用，

5
00:00:09,305 --> 00:00:11,050
将会有五场演讲，

6
00:00:11,050 --> 00:00:13,420
它们之间是相互关联的，正如你将会发现的。

7
00:00:13,420 --> 00:00:16,720
来自Edmund Yeh的第一次演讲

8
00:00:16,720 --> 00:00:18,430
~!@#$%^&*()

9
00:00:18,430 --> 00:00:20,975
数据密集型科学实验。

10
00:00:20,975 --> 00:00:23,020
埃德蒙是一位教授

11
00:00:23,020 --> 00:00:24,160
的电气与计算机工程

12
00:00:24,160 --> 00:00:27,530
东北大学的工程学院

13
00:00:27,600 --> 00:00:30,460
致力于研究大量

14
00:00:30,460 --> 00:00:32,410
致力于通信和网络问题的研究，

15
00:00:32,410 --> 00:00:36,615
包括用于数据密集型应用的网络技术。

16
00:00:36,615 --> 00:00:39,010
Edmund, 请继续，我们需要~!@#$%^&*()

17
00:00:39,010 --> 00:00:40,990
要注意时间，因为我们

18
00:00:40,990 --> 00:00:42,490
我们有一个小时时间来进行

19
00:00:42,490 --> 00:00:46,460
我们有一个小时时间来进行五个报告。请开始吧。

20
00:00:47,030 --> 00:00:49,965
>> 谢谢你，Lotfi，你能听到我说话吗？

21
00:00:49,965 --> 00:00:51,450
>> 是的。

22
00:00:51,450 --> 00:00:54,120
>> 很好。谢谢你。

23
00:00:54,120 --> 00:00:55,890
让我确认一下

24
00:00:55,890 --> 00:01:00,750
我的幻灯片正在分享中吗？

25
00:01:00,750 --> 00:01:02,205
>> 还没有。

26
00:01:02,205 --> 00:01:04,360
你得再分享一次[重叠]。

27
00:01:07,250 --> 00:01:14,675
>> 现在你能看到了吗？

28
00:01:14,675 --> 00:01:17,000
>> 是的。直接全屏就好。

29
00:01:17,000 --> 00:01:18,780
>> 好的？

30
00:01:18,950 --> 00:01:20,700
>> 好的？

31
00:01:20,700 --> 00:01:23,200
>> 非常感谢您的介绍

32
00:01:23,200 --> 00:01:27,050
非常高兴能来到NDN，感到很平静。

33
00:01:28,860 --> 00:01:31,600
去年我在这里，

34
00:01:31,600 --> 00:01:34,400
实际上谈论着

35
00:01:35,370 --> 00:01:38,745
NDN用于数据密集型科学。

36
00:01:38,745 --> 00:01:40,460
实际上，我在谈论的是

37
00:01:40,460 --> 00:01:41,720
一个前期项目

39
00:01:44,680 --> 00:01:46,700
这是后续项目。

40
00:01:46,700 --> 00:01:50,034
该项目也得到了美国国家科学基金会的资助。

41
00:01:50,034 --> 00:01:51,410
数据密集型科学

42
00:01:51,410 --> 00:01:54,840
实验称为N-DISE。

43
00:01:54,860 --> 00:01:57,290
我将概述我们尝试做的事情。

44
00:01:57,290 --> 00:01:58,640
我们正在尝试做

45
00:01:58,640 --> 00:02:00,185
我们正在尝试做一些最近的发展。

46
00:02:00,185 --> 00:02:02,570
正如洛奇提到的，

47
00:02:02,570 --> 00:02:03,920
我的演讲将会有后续内容。

48
00:02:03,920 --> 00:02:05,330
将会有一系列的任务进行。

49
00:02:05,330 --> 00:02:09,790
这些内容将对这里提到的主题进行扩展。

50
00:02:10,820 --> 00:02:14,750
我的幻灯片应该在正常播放吧。

51
00:02:15,420 --> 00:02:17,530
数据密集型科学

52
00:02:17,530 --> 00:02:20,785
涵盖了许多不同的领域，

53
00:02:20,785 --> 00:02:23,705
像大型强子对撞机这样的。

54
00:02:23,705 --> 00:02:25,755
这是高能物理学，

55
00:02:25,755 --> 00:02:27,190
这是我们正在处理的这个特定项目中的主要例子。

56
00:02:27,190 --> 00:02:29,110
处理这个特定项目。

57
00:02:29,110 --> 00:02:32,495
LSST，大型综合巡天望远镜。

58
00:02:32,495 --> 00:02:36,765
SKA，即平方公里阵列，是

59
00:02:36,765 --> 00:02:39,310
天文学和天体物理学领域，它将会在每个夜晚处理大量数据。

60
00:02:39,310 --> 00:02:42,360
将会在每个夜晚处理大量数据。

61
00:02:42,360 --> 00:02:45,735
基因组学是一个新兴领域，它

62
00:02:45,735 --> 00:02:47,740
已经被研究过

63
00:02:47,740 --> 00:02:49,690
已经被研究过，在这个特定的项目中。

64
00:02:49,690 --> 00:02:52,434
这些不同的领域，

65
00:02:52,434 --> 00:02:56,730
分享类似的挑战，它们

66
00:02:56,730 --> 00:03:00,895
包括如何建立索引，

67
00:03:00,895 --> 00:03:03,670
安全地保存、存储、分发、分析，

68
00:03:03,670 --> 00:03:05,125
并从数据中学习，

69
00:03:05,125 --> 00:03:07,510
并在协同使用中

70
00:03:07,510 --> 00:03:09,660
计算存储和网络资源。

71
00:03:09,660 --> 00:03:12,550
即便这些资源很充足，

72
00:03:12,550 --> 00:03:16,180
当你必须处理数据集和~!@#$%^&*()

73
00:03:16,180 --> 00:03:18,355
数据量的大小

74
00:03:18,355 --> 00:03:20,065
我们在这里遇到的，

75
00:03:20,065 --> 00:03:22,520
你仍然面临着许多挑战。

76
00:03:22,520 --> 00:03:24,820
目前，领域专家们正在处理

77
00:03:24,820 --> 00:03:27,550
这些系统问题在

78
00:03:27,550 --> 00:03:30,430
这些系统问题在独立的领域中使用渐进式解决方案developed often in isolation.

79
00:03:30,430 --> 00:03:32,560
这些系统问题通常是独立开发的。

80
00:03:32,560 --> 00:03:34,915
有很多重复的努力，

81
00:03:34,915 --> 00:03:38,080
主要是因为

82
00:03:38,080 --> 00:03:39,940
我们今天使用的架构现在

83
00:03:39,940 --> 00:03:42,130
非常适合这些应用程序。

84
00:03:42,130 --> 00:03:45,480
我们在这里提倡的是一种新的方法。

85
00:03:45,480 --> 00:03:46,885
数据为中心的方法来

86
00:03:46,885 --> 00:03:48,590
系统和网络设计，

87
00:03:48,590 --> 00:03:51,880
并提供系统支持通过

88
00:03:51,880 --> 00:03:53,410
整个数据生命周期

89
00:03:53,410 --> 00:03:55,360
从数据产生，

90
00:03:55,360 --> 00:03:58,134
命名数据，直接保护数据，

91
00:03:58,134 --> 00:04:00,595
通过名称传递数据，

92
00:04:00,595 --> 00:04:04,345
实现可扩展的数据检索，

93
00:04:04,345 --> 00:04:07,915
具有对网络内缓存的原生支持，

94
00:04:07,915 --> 00:04:10,759
自动化的联合缓存和转发，

95
00:04:10,759 --> 00:04:13,314
多播传送。

96
00:04:13,314 --> 00:04:15,235
我们正在尝试去

97
00:04:15,235 --> 00:04:17,575
我们正在尝试去开发一个通用框架来支持

98
00:04:17,575 --> 00:04:20,440
数据密集型科学以支持

99
00:04:20,440 --> 00:04:22,300
不同类型的应用领域

100
00:04:22,300 --> 00:04:24,025
采用相同的方法。

101
00:04:24,025 --> 00:04:28,120
这一切都是基于NDN方法。

102
00:04:28,120 --> 00:04:32,050
现在，这个特定的项目是在

103
00:04:32,050 --> 00:04:35,965
2020年由NSF CC* Start计划资助。

104
00:04:35,965 --> 00:04:39,190
它是在之前的项目基础上发展起来的。

105
00:04:39,190 --> 00:04:41,190
它我提到的名字叫做SANDIE，

106
00:04:41,190 --> 00:04:45,670
该团队运行的时间是从2017年到2001年。

107
00:04:46,130 --> 00:04:49,750
该团队由东北人组成，

108
00:04:49,750 --> 00:04:51,250
在那里我领导着这个团队，

109
00:04:51,250 --> 00:04:53,350
在加州理工学院，哈维·纽曼教授

110
00:04:53,350 --> 00:04:56,775
来自加州理工学院物理系的哈维·纽曼教授正在领导这个团队。

111
00:04:56,775 --> 00:05:00,120
加州大学洛杉矶分校，那里的联合主要研究员们，

112
00:05:00,120 --> 00:05:01,770
加州大学洛杉矶分校的联合主要研究员们，其中包括教授Lisa Zhang和教授Jason Cong，

113
00:05:01,770 --> 00:05:04,320
教授Jason Cong，

114
00:05:04,320 --> 00:05:06,490
他们正在带头进行努力

115
00:05:06,490 --> 00:05:11,040
拥塞控制和FPGA加速，

116
00:05:11,040 --> 00:05:13,350
和田纳西科技大学，那里的联合首席研究员是

117
00:05:13,350 --> 00:05:16,060
和田纳西科技大学，那里的联合首席研究员是Susmit Shannigrahi，他正在研究基因组学的应用。

118
00:05:16,060 --> 00:05:19,525
研究基因组学的应用。

119
00:05:19,525 --> 00:05:21,280
我们当然是在合作伙伴关系中做这件事的

120
00:05:21,280 --> 00:05:23,005
与LHC团队一起，

121
00:05:23,005 --> 00:05:24,370
与基因组学合作者一起，在

122
00:05:24,370 --> 00:05:26,120
NDN项目团队。

123
00:05:26,120 --> 00:05:27,965
但这里的挑战，

124
00:05:27,965 --> 00:05:29,750
尤其是试图解决的难题，

125
00:05:29,750 --> 00:05:32,465
地址的问题是LHC数据量是

126
00:05:32,465 --> 00:05:35,230
由于增长了大约10倍

127
00:05:35,230 --> 00:05:36,930
高亮度大型强子对撞机

128
00:05:36,930 --> 00:05:39,585
计划于2027年开始。

129
00:05:39,585 --> 00:05:41,350
因此，我们正在考察

130
00:05:41,350 --> 00:05:45,976
再增加10倍已经~!@#$%^&*()

131
00:05:45,976 --> 00:05:48,395
它们基于极高的数据量。

132
00:05:48,395 --> 00:05:49,340
我们还将会

133
00:05:49,340 --> 00:05:51,785
获得更复杂的数据。

134
00:05:51,785 --> 00:05:53,915
我们还在研究

135
00:05:53,915 --> 00:05:56,975
人类基因组数据和地球生物基因组数据，

136
00:05:56,975 --> 00:05:59,975
接近艾字节量级。

137
00:05:59,975 --> 00:06:01,940
所有这些应用程序都需要使用

138
00:06:01,940 --> 00:06:03,800
多样化的计算存储，

139
00:06:03,800 --> 00:06:05,135
多样化的计算存储，网络资源越来越需要。

140
00:06:05,135 --> 00:06:07,280
多样化的计算存储，网络资源越来越需要。

141
00:06:07,280 --> 00:06:10,165
我们的方法是建立使用这些多样化资源的能力。

142
00:06:10,165 --> 00:06:12,435
我们的方法是建立

143
00:06:12,435 --> 00:06:14,430
一个以数据为中心的生态系统，

144
00:06:14,430 --> 00:06:16,415
提供敏捷集成的，

145
00:06:16,415 --> 00:06:18,170
互操作的、可扩展的、强健的，

146
00:06:18,170 --> 00:06:20,120
和可信赖的解决方案用于

147
00:06:20,120 --> 00:06:22,385
异构数据密集型领域。

148
00:06:22,385 --> 00:06:24,840
这是我们的长远目标。

149
00:06:24,980 --> 00:06:28,160
现在N-DISE项目的近期目标是

150
00:06:28,160 --> 00:06:31,040
是要部署、投入使用并进行投产

151
00:06:31,040 --> 00:06:32,915
首个原型投产就绪

152
00:06:32,915 --> 00:06:37,160
基于NDN的千万亿级数据分发缓存，

153
00:06:37,160 --> 00:06:39,290
基于NDN的千万亿级数据分发缓存，访问计算系统，服务于主要科学计划。

154
00:06:39,290 --> 00:06:42,730
服务于主要科学计划。

155
00:06:42,730 --> 00:06:44,270
我们将要去

156
00:06:44,270 --> 00:06:45,770
我们将要去LHC高能物理作为

157
00:06:45,770 --> 00:06:47,150
领先的目标用例

158
00:06:47,150 --> 00:06:48,600
，与生物基因组相结合，

159
00:06:48,600 --> 00:06:51,390
结合人类基因组项目，

160
00:06:51,390 --> 00:06:52,920
次级用例，

161
00:06:52,920 --> 00:06:54,869
和ATLAS、LSST，

162
00:06:54,869 --> 00:06:57,420
SKA作为未来的使用案例。

163
00:06:57,420 --> 00:06:59,810
我们将要利用

164
00:06:59,810 --> 00:07:01,145
我们将要利用NDN协议，它们已经开发出来并且已经

165
00:07:01,145 --> 00:07:02,810
已经开发出来并且已经

166
00:07:02,810 --> 00:07:05,180
在之前的会议中讨论过。

167
00:07:05,180 --> 00:07:06,590
高吞吐量转发

168
00:07:06,590 --> 00:07:07,970
缓存方法已经

169
00:07:07,970 --> 00:07:09,270
由东北部和其他机构开发的~!@#$%^&*()

170
00:07:09,270 --> 00:07:11,280
东北部和其他机构。

171
00:07:11,280 --> 00:07:13,234
集装箱化技术，

172
00:07:13,234 --> 00:07:16,685
正在加州理工学院开发中，

173
00:07:16,685 --> 00:07:20,060
集成了 FPGA 加速子系统

174
00:07:20,060 --> 00:07:23,470
UCLA 正在研究的。

175
00:07:23,470 --> 00:07:25,970
我们的目标是通过

176
00:07:25,970 --> 00:07:27,470
宽域网络或吞吐量

177
00:07:27,470 --> 00:07:29,960
接近每秒100吉比特

178
00:07:29,960 --> 00:07:32,690
并显著减少下载时间

179
00:07:32,690 --> 00:07:35,135
通过使用优化的缓存。

180
00:07:35,135 --> 00:07:39,215
我们在这里非常追求性能。

181
00:07:39,215 --> 00:07:42,400
对于非常大的数据量

182
00:07:42,400 --> 00:07:45,125
使用NDN方法。

183
00:07:45,125 --> 00:07:48,594
我们正在建立一个持久的测试平台。

184
00:07:48,594 --> 00:07:51,340
配备高性能NDN数据缓存服务器。

185
00:07:51,340 --> 00:07:55,445
我们将在SC21展示那个测试平台，

186
00:07:55,445 --> 00:07:58,150
即将在不到两周的时间里举行。

187
00:07:58,150 --> 00:08:01,270
即将在不到两周的时间里举行，SC21之后仍将保持作为这个项目的持续性实验平台。

188
00:08:01,270 --> 00:08:04,465
该项目的持续性实验平台。

189
00:08:04,465 --> 00:08:06,115
让我现在来谈谈

190
00:08:06,115 --> 00:08:11,570
一些近期的NDN发展情况。

191
00:08:13,020 --> 00:08:16,150
请告诉我我还剩下多少时间，

192
00:08:16,150 --> 00:08:17,890
但我会尽量快速地进行

193
00:08:17,890 --> 00:08:19,700
我会相对快速地进行。

194
00:08:19,700 --> 00:08:22,325
我们一直在研究开发

195
00:08:22,325 --> 00:08:25,675
消费者和生产者用于NDN-DPDK。

196
00:08:25,675 --> 00:08:29,450
一款新的消费者-生产者应用程序

197
00:08:29,450 --> 00:08:30,890
基于NDNgo库，

198
00:08:30,890 --> 00:08:32,270
该系统是由美国国家标准与技术研究院（NIST）开发的。

199
00:08:32,270 --> 00:08:34,375
，已经开发完成。

200
00:08:34,375 --> 00:08:37,730
已经取代了额外的NDN和OSS插件，

201
00:08:37,730 --> 00:08:39,785
去年我描述的，

202
00:08:39,785 --> 00:08:41,395
由SANDIE项目实施。

203
00:08:41,395 --> 00:08:43,259
为了进一步提高吞吐量，

204
00:08:43,259 --> 00:08:47,410
我们开发了新的C++ NDNc库，

205
00:08:47,410 --> 00:08:49,790
通过应用程序通信的API

206
00:08:49,790 --> 00:08:50,840
通过NDN-DPDK与应用程序通信的API，期待使用memif，

207
00:08:50,840 --> 00:08:52,330
期待使用memif，

208
00:08:52,330 --> 00:08:54,605
它是一个共享内存包接口。

209
00:08:54,605 --> 00:08:55,760
提供高性能

210
00:08:55,760 --> 00:08:58,220
数据包传输。这一切都是由

211
00:08:58,220 --> 00:08:59,960
加州理工学院的团队。

212
00:08:59,960 --> 00:09:02,150
我们还将研究容器技术。

213
00:09:02,150 --> 00:09:03,290
NDN-DPDK的应用情况。

214
00:09:03,290 --> 00:09:04,460
NDN-DPDK的应用情况。

215
00:09:04,460 --> 00:09:06,845
多种服务器设备和接口。

216
00:09:06,845 --> 00:09:09,290
具体来说，使用 Docker 容器，

217
00:09:09,290 --> 00:09:11,825
可以让你托管客户操作系统，

218
00:09:11,825 --> 00:09:14,405
状态恢复，轻松升级。

219
00:09:14,405 --> 00:09:16,770
我们已完全实现了Docker容器化。

220
00:09:16,770 --> 00:09:18,450
我们已完全实现了Docker容器化的NDN-DPDK转发器，

221
00:09:18,450 --> 00:09:19,835
消费者和生产者。

222
00:09:19,835 --> 00:09:21,575
这是一个联合努力，包括

223
00:09:21,575 --> 00:09:24,555
加州理工学院和美国国家标准与技术研究院，事实上。

224
00:09:24,555 --> 00:09:26,700
我们也一直在研究

225
00:09:26,700 --> 00:09:29,730
我们也一直在研究基于速率的NDN拥塞控制。This is headed by Professor [inaudible] UCLA.

226
00:09:29,730 --> 00:09:34,110
这是由加州大学洛杉矶分校的[听不清]教授领导的。

227
00:09:34,110 --> 00:09:37,700
NDN的动态多路径转发和在

228
00:09:37,700 --> 00:09:39,080
网络缓存呈现

229
00:09:39,080 --> 00:09:41,140
传统的拥堵

230
00:09:41,140 --> 00:09:42,905
控制方法不适用。

231
00:09:42,905 --> 00:09:44,250
因此，我们正在开发

232
00:09:44,250 --> 00:09:45,480
基于速率的拥塞控制

233
00:09:45,480 --> 00:09:47,070
我们正在比较

234
00:09:47,070 --> 00:09:48,530
我们的想法是进行比较

235
00:09:48,530 --> 00:09:50,000
消费者兴趣发送率

236
00:09:50,000 --> 00:09:52,970
与相应的数据到达率

237
00:09:52,970 --> 00:09:54,305
以检测拥塞情况，

238
00:09:54,305 --> 00:09:56,120
然后设置兴趣率 accordingly

239
00:09:56,120 --> 00:09:58,285
相应地设置发送率。

240
00:09:58,285 --> 00:10:00,650
康教授的团队正在研究

241
00:10:00,650 --> 00:10:02,405
Professor Kang's team is researching FPGA acceleration to accelerate the NDN forwarder.

242
00:10:02,405 --> 00:10:04,550
加速NDN转发器。

243
00:10:04,550 --> 00:10:06,230
这项努力的初步重点

244
00:10:06,230 --> 00:10:08,300
是在转发器的输入阶段，

245
00:10:08,300 --> 00:10:11,920
我们正在检测到一个瓶颈。

246
00:10:11,920 --> 00:10:12,770
我们的想法是

247
00:10:12,770 --> 00:10:14,270
加速哈希函数并且

248
00:10:14,270 --> 00:10:16,670
用于线程调度的查找表。

249
00:10:16,670 --> 00:10:18,080
对于这两个领域，

250
00:10:18,080 --> 00:10:20,300
对于这两个领域，拥塞控制和FPGA加速。

251
00:10:20,300 --> 00:10:21,890
稍后将有关于这两个领域，拥塞控制和FPGA加速的讨论会展开这些主题。

252
00:10:21,890 --> 00:10:24,605
将扩展这些主题的讨论会。

253
00:10:24,605 --> 00:10:26,840
我们还在初步探索集成

254
00:10:26,840 --> 00:10:28,759
的基因组学工作流程。

255
00:10:28,759 --> 00:10:30,830
这是由教授领导的Shannigrahi at Tennessee Tech。

256
00:10:30,830 --> 00:10:33,035
Tennessee Tech的Shannigrahi。

257
00:10:33,035 --> 00:10:35,605
我们已经测试了Docker容器。

258
00:10:35,605 --> 00:10:37,770
在太平洋研究平台上，

259
00:10:37,770 --> 00:10:39,410
PRP，在太平洋研究平台上，和Google云平台，通过与基因组学工作流程的结合使用。

260
00:10:39,410 --> 00:10:41,615
通过与基因组学工作流程的结合使用。

261
00:10:41,615 --> 00:10:42,350
ongoing integration of containers with ~!@#$%^&*()

262
00:10:42,350 --> 00:10:44,180
持续集成容器与 ~!@#$%^&*()

263
00:10:44,180 --> 00:10:46,460
基于Kubernetes的系统或部署

264
00:10:46,460 --> 00:10:49,710
和在基因组学工作流中的应用。

265
00:10:50,000 --> 00:10:53,450
在东北大学，我们一直专注于

266
00:10:53,450 --> 00:10:57,205
抱歉，多少分钟？[重叠的部分]

267
00:10:57,205 --> 00:10:58,740
>> 请稍等一分钟。

268
00:10:58,740 --> 00:11:00,810
>> 请稍等一分钟。我会很快的。

269
00:11:00,810 --> 00:11:02,765
在东北我们一直在~!@#$%^&*()

270
00:11:02,765 --> 00:11:04,850
升级本地测试环境。

271
00:11:04,850 --> 00:11:06,860
我们已经实现了

272
00:11:06,860 --> 00:11:09,350
我们已经实现了一个容器化的NDN-DPDK转发器，

273
00:11:09,350 --> 00:11:10,580
我们已经实现了一个容器化的NDN-DPDK转发器，基于C语言的消费者，以及NIST开发的文件服务器。

274
00:11:10,580 --> 00:11:13,340
和NIST开发的文件服务器。

275
00:11:13,340 --> 00:11:14,810
我们已经升级了与NIST开发的文件服务器。

276
00:11:14,810 --> 00:11:16,370
提供了转发缓存算法来

277
00:11:16,370 --> 00:11:18,350
最新的NDN-DPDK转发器与

278
00:11:18,350 --> 00:11:19,684
进行了广泛的

279
00:11:19,684 --> 00:11:22,025
进行了吞吐量和缓存延迟测试。

280
00:11:22,025 --> 00:11:23,600
现在，我将要谈论

281
00:11:23,600 --> 00:11:25,310
WAN测试平台，

282
00:11:25,310 --> 00:11:27,560
我们已经组建了这个。

283
00:11:27,560 --> 00:11:30,260
我们已经升级了东北部的服务器。

284
00:11:30,260 --> 00:11:30,920
并将其迁移到

285
00:11:30,920 --> 00:11:32,480
将其迁移到MGHPCC以便

286
00:11:32,480 --> 00:11:33,680
访问100吉比特

287
00:11:33,680 --> 00:11:35,280
每秒网络带宽。

288
00:11:35,280 --> 00:11:36,745
加州理工学院已经升级了

289
00:11:36,745 --> 00:11:38,740
它的连接性与StarLight合作得很好。

290
00:11:38,740 --> 00:11:39,700
现在他们有一个2通过100吉比特连接到

291
00:11:39,700 --> 00:11:41,350
the StarLight exchange point in

292
00:11:41,350 --> 00:11:42,460
芝加哥的StarLight交换点在

293
00:11:42,460 --> 00:11:45,525
芝加哥和StarLight SC21展位。

294
00:11:45,525 --> 00:11:47,600
我们购买了两台新服务器来~!@#$%^&*()

295
00:11:47,600 --> 00:11:50,720
我们在芝加哥和SC21展位放置了新的服务器。

296
00:11:50,720 --> 00:11:52,250
我们已经增加了加州大学洛杉矶分校

297
00:11:52,250 --> 00:11:53,810
田纳西科技站点

298
00:11:53,810 --> 00:11:56,135
支持10吉比特连接。

299
00:11:56,135 --> 00:11:57,560
为了发送NDN~!@#$%^&*()

300
00:11:57,560 --> 00:11:58,760
为了在网络中直接打包，

301
00:11:58,760 --> 00:11:59,810
我们已经建立了VLAN

302
00:11:59,810 --> 00:12:01,160
站点之间的连接

303
00:12:01,160 --> 00:12:03,710
在由Internet2支持的测试床中，

304
00:12:03,710 --> 00:12:06,020
CENIC、ESnet和UCSD。

305
00:12:06,020 --> 00:12:08,240
这是我们测试平台的图片。

306
00:12:08,240 --> 00:12:10,130
我们将会在SC21上使用这个，

307
00:12:10,130 --> 00:12:12,890
我们之后也会用它来作为持久的测试平台。

308
00:12:12,890 --> 00:12:15,410
你可以看到我们这里有东北大学。

309
00:12:15,410 --> 00:12:16,880
芝加哥的StarLight，

310
00:12:16,880 --> 00:12:19,685
SC21 StarLight 展位在这里，

311
00:12:19,685 --> 00:12:21,410
田纳西科技大学，加州理工学院我们有

312
00:12:21,410 --> 00:12:23,705
我们有两台机器，还有加州大学洛杉矶分校。

313
00:12:23,705 --> 00:12:28,700
这个想法仅仅是

314
00:12:28,700 --> 00:12:30,290
期待着即将在不到两周内举行的SC21，

315
00:12:30,290 --> 00:12:31,880
即将在不到两周内到来。

316
00:12:31,880 --> 00:12:34,070
我们将要演示N-DISE的数据访问

317
00:12:34,070 --> 00:12:35,120
分布式缓存

318
00:12:35,120 --> 00:12:36,770
在这个测试平台上的系统，

319
00:12:36,770 --> 00:12:38,270
专注于吞吐量和

320
00:12:38,270 --> 00:12:39,650
下载延迟实验

321
00:12:39,650 --> 00:12:42,870
与CMS数据集一起。

322
00:12:43,120 --> 00:12:46,550
我们希望获得非常可观的增长

323
00:12:46,550 --> 00:12:49,595
SC21相比SC19的表现，

324
00:12:49,595 --> 00:12:50,750
这是两年前的事情。

325
00:12:50,750 --> 00:12:53,825
我们因为新冠疫情无法在2020年做到这一点。

326
00:12:53,825 --> 00:12:56,690
在SC21之后，我们将会关注以下话题。

327
00:12:56,690 --> 00:12:58,640
我们将会关注以下话题。

328
00:12:58,640 --> 00:13:00,335
我只是把它放在那里。

329
00:13:00,335 --> 00:13:02,345
由于时间有限。

330
00:13:02,345 --> 00:13:03,590
我们想要做许多事情

331
00:13:03,590 --> 00:13:06,065
在SC21之后去做。

332
00:13:06,065 --> 00:13:07,955
这个项目将会在SC21之后去做，持续至少再运行一年，

333
00:13:07,955 --> 00:13:09,545
将继续运行至少再一年，

334
00:13:09,545 --> 00:13:11,030
如果不是两年的话，那么

335
00:13:11,030 --> 00:13:12,815
将会有很多工作要做。

336
00:13:12,815 --> 00:13:15,005
我们非常兴奋并且我们希望

337
00:13:15,005 --> 00:13:18,530
将会获得显著的性能提升，

338
00:13:18,530 --> 00:13:20,510
将会获得显著的性能提升，那个SC21将会推动我们向前发展，我们当然会、、、

339
00:13:20,510 --> 00:13:22,985
推动我们向前发展，我们当然、、、

340
00:13:22,985 --> 00:13:24,590
寻求长期合作

341
00:13:24,590 --> 00:13:26,120
领域科学、网络、

342
00:13:26,120 --> 00:13:28,325
和计算机系统社群在这一努力中。

343
00:13:28,325 --> 00:13:31,050
在这一努力中。非常感谢您。

344
00:13:31,060 --> 00:13:34,010
>> 非常感谢你，埃德蒙。

345
00:13:34,010 --> 00:13:37,535
为了节省时间，我只问一个简单的问题。

346
00:13:37,535 --> 00:13:39,140
到目前为止，你是否了解什么是吞吐量性能

347
00:13:39,140 --> 00:13:41,120
你是否了解什么是吞吐量性能

348
00:13:41,120 --> 00:13:43,685
您能在SC21上展示吗？

349
00:13:43,685 --> 00:13:45,590
是的，这是一个非常好的问题。

350
00:13:45,590 --> 00:13:46,670
我们仍在努力中。

351
00:13:46,670 --> 00:13:50,630
~!@#$%^&*()

352
00:13:50,630 --> 00:13:52,580
在尝试做现场演示时，你可能会遇到很多事情。

353
00:13:52,580 --> 00:13:54,410
在尝试做现场演示时，

354
00:13:54,410 --> 00:13:55,670
尽管我们非常

355
00:13:55,670 --> 00:13:56,930
我们非常有信心我们会得到

356
00:13:56,930 --> 00:14:00,440
超过每秒10吉比特，

357
00:14:00,440 --> 00:14:01,820
我认为，不过

358
00:14:01,820 --> 00:14:04,370
我们正在努力突破那个限制，

359
00:14:04,370 --> 00:14:06,380
朝着最终目标努力

360
00:14:06,380 --> 00:14:07,490
每秒100吉比特。

361
00:14:07,490 --> 00:14:08,990
但我们也在专注

362
00:14:08,990 --> 00:14:11,390
在减少下载延迟上，

363
00:14:11,390 --> 00:14:12,470
所以这里有两个

364
00:14:12,470 --> 00:14:14,675
这里发生了不同的事情。

365
00:14:14,675 --> 00:14:17,030
>> 非常感谢您。

366
00:14:17,030 --> 00:14:17,855
>> 非常感谢您。

367
00:14:17,855 --> 00:14:22,085
>> 我们的下一位演讲者是Catalin Iordache。

368
00:14:22,085 --> 00:14:24,440
我们的下一位演讲者是Catalin Iordache。Catalin, 你可以开始分享你的屏幕了。

369
00:14:24,440 --> 00:14:26,525
请继续并开始分享您的屏幕。

370
00:14:26,525 --> 00:14:28,025
Catalin 毕业于

371
00:14:28,025 --> 00:14:30,755
毕业于布加勒斯特理工大学

372
00:14:30,755 --> 00:14:31,820
毕业并获得硕士学位

373
00:14:31,820 --> 00:14:33,695
高级计算机架构。

374
00:14:33,695 --> 00:14:35,300
在过去的几年里，

375
00:14:35,300 --> 00:14:37,505
他一直是加州理工学院的一名承包商，

376
00:14:37,505 --> 00:14:39,275
他一直是加州理工学院的一名承包商，在SANDIE项目上工作，并且目前在N-DISE项目上。

377
00:14:39,275 --> 00:14:41,450
并且目前在N-DISE项目上。

378
00:14:41,450 --> 00:14:44,540
他将会告诉我们关于它的情况。

379
00:14:44,540 --> 00:14:46,715
卡塔琳，请开始吧。

380
00:14:46,715 --> 00:14:50,940
>> 谢谢你，洛夫提。你能听见我说话吗？

381
00:14:53,350 --> 00:14:58,160
>> 是的。只是[重叠的声音]很好。

382
00:14:58,160 --> 00:14:59,660
>> 完美。非常感谢您，

383
00:14:59,660 --> 00:15:01,175
和感谢您邀请我参加

384
00:15:01,175 --> 00:15:02,810
参加这次社区会议。

385
00:15:02,810 --> 00:15:04,655
这是我第一次说，

386
00:15:04,655 --> 00:15:06,110
这是我第一次说，过去的三年我将要去讨论的事情。

387
00:15:06,110 --> 00:15:07,850
将要去讨论我正在做的事情。

388
00:15:07,850 --> 00:15:11,585
利用NDN来进行这些项目的工作。

389
00:15:11,585 --> 00:15:14,960
今天的主题将是这个NDNc，

390
00:15:14,960 --> 00:15:18,425
它是什么，以及我们为什么要这么做？

391
00:15:18,425 --> 00:15:21,650
为了解释它，

392
00:15:21,650 --> 00:15:23,645
我首先想说，

393
00:15:23,645 --> 00:15:25,820
他们俩都在为SANDIE项目工作，

395
00:15:27,110 --> 00:15:28,790
此时该项目。

396
00:15:28,790 --> 00:15:30,875
此时该项目的主要目标是

397
00:15:30,875 --> 00:15:32,450
此时该项目的主要目标是both projects on应用方面始终是~!@#$%^&*()

398
00:15:32,450 --> 00:15:34,460
应用方面始终是

399
00:15:34,460 --> 00:15:36,095
部署NDN在~!@#$%^&*()

400
00:15:36,095 --> 00:15:36,650
大规模

401
00:15:36,650 --> 00:15:38,090
数据密集型科学实验

402
00:15:38,090 --> 00:15:41,340
例如LHC，高能物理学。

403
00:15:41,770 --> 00:15:46,130
这一直是我们的目标，

404
00:15:46,130 --> 00:15:49,250
今天我首先要向你们展示

405
00:15:49,250 --> 00:15:50,780
今天我首先要向你们展示的是，如何目前数据正在被访问和传递，

406
00:15:50,780 --> 00:15:52,490
正在被访问和传递，

407
00:15:52,490 --> 00:15:53,840
正在被访问和传递的CMS，其中一个大型实验就是我看到的。

408
00:15:53,840 --> 00:15:56,240
我看到的两个大型实验。

409
00:15:56,240 --> 00:15:58,610
would look like in such an environment,

410
00:15:58,610 --> 00:16:00,650
在这样的环境下看起来会是什么样的，

411
00:16:00,650 --> 00:16:02,480
至少按照我们所设想的方式。

412
00:16:02,480 --> 00:16:05,240
接下来我将讨论三重性能

413
00:16:05,240 --> 00:16:07,895
的这种应用，最后，

414
00:16:07,895 --> 00:16:10,640
这将引出NDNc是什么，

415
00:16:10,640 --> 00:16:14,280
以及未来的计划。

416
00:16:14,530 --> 00:16:19,115
首先，今天在CMS中数据访问是怎样的？

417
00:16:19,115 --> 00:16:21,380
我们有这张图表。

418
00:16:21,380 --> 00:16:22,925
在底部您有

419
00:16:22,925 --> 00:16:25,880
在底部您有B侧和C地点。As you can see both sides have ~!@#$%^&*()

420
00:16:25,880 --> 00:16:28,190
如您所见，两边都有

421
00:16:28,190 --> 00:16:30,065
访问某些存储空间，

422
00:16:30,065 --> 00:16:31,880
和存储空间包含

423
00:16:31,880 --> 00:16:34,560
来自CMS实验的数据。

424
00:16:35,620 --> 00:16:38,420
我的意思是，除了B地点，你还有其他地点以及相同的~!@#$%^&*()

425
00:16:38,420 --> 00:16:40,760
也有许多地点和相同的

426
00:16:40,760 --> 00:16:42,500
对于C地点。尽管

427
00:16:42,500 --> 00:16:43,520
这些站点是相连的

428
00:16:43,520 --> 00:16:46,775
至或所谓的区域XRootD重定向器，

429
00:16:46,775 --> 00:16:49,610
它了解其下所有站点的信息，

430
00:16:49,610 --> 00:16:52,055
以及关于全球重定向器的信息。

431
00:16:52,055 --> 00:16:54,050
在这张图表中，

432
00:16:54,050 --> 00:16:58,115
你在美国和欧盟都有一个重定向器。

433
00:16:58,115 --> 00:17:01,085
在这种情况下，对于我们的网站A来说，

434
00:17:01,085 --> 00:17:04,205
或者在左手边的角落里

435
00:17:04,205 --> 00:17:06,755
是用户应用程序运行的地方，

436
00:17:06,755 --> 00:17:08,750
是科学家们实际运行(他们的科学应用程序的地方)，

437
00:17:08,750 --> 00:17:11,900
他们的科学应用程序，

438
00:17:11,900 --> 00:17:13,535
科学数据在CMS中。

439
00:17:13,535 --> 00:17:15,665
在这种情况下，我们有两个应用程序。

440
00:17:15,665 --> 00:17:16,730
在第一种情况下，

441
00:17:16,730 --> 00:17:18,995
应用程序实际上会请求数据。

442
00:17:18,995 --> 00:17:21,245
它首先会做的事情是，

443
00:17:21,245 --> 00:17:22,520
这个应用程序会

444
00:17:22,520 --> 00:17:23,510
实际上会在本地查找，

445
00:17:23,510 --> 00:17:24,785
它就存在于那里，

446
00:17:24,785 --> 00:17:26,195
那么就没有必要了

447
00:17:26,195 --> 00:17:27,620
那么就没有必要再进一步搜索了。

448
00:17:27,620 --> 00:17:29,045
在第一种情况下，

449
00:17:29,045 --> 00:17:30,080
您会看到数据

450
00:17:30,080 --> 00:17:31,460
它实际上在A地点。

451
00:17:31,460 --> 00:17:33,365
但在第二种情况下，

452
00:17:33,365 --> 00:17:37,175
这些是应用程序，

453
00:17:37,175 --> 00:17:38,660
实际上再次查找数据

454
00:17:38,660 --> 00:17:40,880
它在A地点进行本地搜索，但没有找到。

455
00:17:40,880 --> 00:17:43,715
它之后做的是进行第二步，

456
00:17:43,715 --> 00:17:45,455
它之后做的是进行第二步，那就是询问它的区域重定向器关于一个网站，

457
00:17:45,455 --> 00:17:48,110
它的区域重定向器关于一个网站，

458
00:17:48,110 --> 00:17:49,805
它的数据可能是什么。

459
00:17:49,805 --> 00:17:51,710
这个重定向器会查看

460
00:17:51,710 --> 00:17:54,545
如果文件在那里，它会查看站点B。

461
00:17:54,545 --> 00:17:58,340
如果没有，那么它会转到全局重定向器。

462
00:17:58,340 --> 00:17:59,780
这个重定向器会查看

463
00:17:59,780 --> 00:18:01,880
这位欧盟的主管，

464
00:18:01,880 --> 00:18:04,625
或许也包括其他地区。

465
00:18:04,625 --> 00:18:06,410
当数据被找到时，

466
00:18:06,410 --> 00:18:07,520
最终，在这种情况下，

467
00:18:07,520 --> 00:18:11,300
如果是C地点，那么申请地点，

468
00:18:11,300 --> 00:18:12,845
他们将会被通知说

469
00:18:12,845 --> 00:18:14,360
这是IP地址在哪里，

470
00:18:14,360 --> 00:18:15,530
这种情况下，数据是

471
00:18:15,530 --> 00:18:17,720
在这种情况下，数据是来自C站点的，然后应用程序将会

472
00:18:17,720 --> 00:18:18,980
连接到那个IP并且

473
00:18:18,980 --> 00:18:20,390
实际上读取数据。

474
00:18:20,390 --> 00:18:22,324
像我说的，这些应用程序

475
00:18:22,324 --> 00:18:24,635
被称为XRootD。

476
00:18:24,635 --> 00:18:26,855
XRootD是一个被称为XRootD的框架，它是~!@#$%^&*()

477
00:18:26,855 --> 00:18:28,910
它是一个框架，它是~!@#$%^&*()

478
00:18:28,910 --> 00:18:31,280
基本上是定义的管理工具

479
00:18:31,280 --> 00:18:32,645
用于服务器上

480
00:18:32,645 --> 00:18:35,750
用于分发和读取数据等操作。

481
00:18:35,750 --> 00:18:38,630
用于分发和读取数据等操作。

482
00:18:38,630 --> 00:18:39,815
因为它是一个框架。

483
00:18:39,815 --> 00:18:41,030
它们同样也能够使得开发者实现各种类型

484
00:18:41,030 --> 00:18:42,560
开发者实现各种类型

485
00:18:42,560 --> 00:18:44,525
的插件。

486
00:18:44,525 --> 00:18:46,220
例如，您可以开发

487
00:18:46,220 --> 00:18:47,975
您可以为此开发您自己的文件系统插件，

488
00:18:47,975 --> 00:18:49,430
或者是缓存插件或者是一个

489
00:18:49,430 --> 00:18:51,155
安全插件等等。

490
00:18:51,155 --> 00:18:52,880
我的意思是列表很长。

491
00:18:52,880 --> 00:18:57,575
但它是一个C++框架，

492
00:18:57,575 --> 00:19:00,185
而且它的源代码是开源的。

493
00:19:00,185 --> 00:19:02,630
但他们也在用Golang开发一些东西，

494
00:19:02,630 --> 00:19:04,595
但这只是刚开始。

495
00:19:04,595 --> 00:19:07,130
我们的情况下，

496
00:19:07,130 --> 00:19:08,840
我们想要开发这个插件，

497
00:19:08,840 --> 00:19:09,740
它被称为一个开放的

498
00:19:09,740 --> 00:19:11,045
存储系统插件，

499
00:19:11,045 --> 00:19:12,920
和它实际的实现

500
00:19:12,920 --> 00:19:14,225
的文件系统。

501
00:19:14,225 --> 00:19:15,770
它的核心仅仅是

502
00:19:15,770 --> 00:19:18,035
导出的C++动态库

503
00:19:18,035 --> 00:19:21,740
只是一个单一的符号

504
00:19:21,740 --> 00:19:23,270
为了让这些能够到达

505
00:19:23,270 --> 00:19:25,415
了解如何加载这个库。

506
00:19:25,415 --> 00:19:27,650
在实施过程中

507
00:19:27,650 --> 00:19:30,530
插件实际上需要

508
00:19:30,530 --> 00:19:31,865
提供实施方案

509
00:19:31,865 --> 00:19:35,410
每个帖子都是系统切分后共同创作的。

510
00:19:35,410 --> 00:19:37,420
例如，你可能已经实施了

511
00:19:37,420 --> 00:19:38,830
用于打开，用于关闭，用于读取，

512
00:19:38,830 --> 00:19:40,700
用于打开目录，用于读取目录，

513
00:19:40,700 --> 00:19:44,345
以及所有其他发布插件和调用。

514
00:19:44,345 --> 00:19:46,025
这基本上就是插件，

515
00:19:46,025 --> 00:19:48,020
我们设想的实际上是要

516
00:19:48,020 --> 00:19:51,125
嵌入一个NDN消费者，

517
00:19:51,125 --> 00:19:53,615
在这个问题中嵌入一个插件。

518
00:19:53,615 --> 00:19:56,240
该消费者应该能够进行翻译。

519
00:19:56,240 --> 00:19:59,735
在文件系统调用和NDN名称之间，

520
00:19:59,735 --> 00:20:02,525
然后根据那个名称构建兴趣包，

521
00:20:02,525 --> 00:20:04,350
将其通过NDN网络发送过去。

522
00:20:04,350 --> 00:20:05,920
将其通过NDN网络发送过去，并且另一端会有生产者对数据进行访问。

523
00:20:05,920 --> 00:20:07,360
它们能够访问数据。

524
00:20:07,360 --> 00:20:08,680
它们将会发送回数据，

525
00:20:08,680 --> 00:20:10,540
然后消费者将读取数据。

526
00:20:10,540 --> 00:20:12,235
我们将验证数据是否有效，

527
00:20:12,235 --> 00:20:15,130
然后将其重新放回到XRootD框架中。

528
00:20:15,130 --> 00:20:17,770
在我们的情况下，

529
00:20:17,770 --> 00:20:20,630
我们做了这个，

530
00:20:20,630 --> 00:20:22,880
我们还必须得出了一个命名方案。

531
00:20:22,880 --> 00:20:24,425
我们还必须得出了一个命名方案。

532
00:20:24,425 --> 00:20:25,970
例如，对于B

533
00:20:25,970 --> 00:20:28,340
打开或fstat文件系统调用，

534
00:20:28,340 --> 00:20:30,170
我们有这个名字，

535
00:20:30,170 --> 00:20:32,525
其前缀为NDN XRootD。

536
00:20:32,525 --> 00:20:34,160
然后你有了元数据，

537
00:20:34,160 --> 00:20:38,030
它基本上请求了一个元包，

538
00:20:38,030 --> 00:20:40,040
它也是在请求时

539
00:20:40,040 --> 00:20:43,235
文件系统是打开的还是fstat。

540
00:20:43,235 --> 00:20:45,440
数据包

541
00:20:45,440 --> 00:20:47,090
兴趣包含了大量

542
00:20:47,090 --> 00:20:48,995
包含了大量关于文件的信息。

543
00:20:48,995 --> 00:20:50,300
那么基本上在绿色区域里，

544
00:20:50,300 --> 00:20:51,830
你有文件路径。

545
00:20:51,830 --> 00:20:52,790
现在，例如，对于

546
00:20:52,790 --> 00:20:54,170
读取文件系统调用，

547
00:20:54,170 --> 00:20:55,310
有一个不同的名字。

548
00:20:55,310 --> 00:20:57,995
我们有相同的前缀和XRootD，

549
00:20:57,995 --> 00:21:00,110
你有超级，然后你有

550
00:21:00,110 --> 00:21:01,340
段号和

551
00:21:01,340 --> 00:21:02,895
文件的版本。

552
00:21:02,895 --> 00:21:04,660
那么另一方面的制作人

553
00:21:04,660 --> 00:21:06,010
不会翻译

554
00:21:06,010 --> 00:21:07,570
段号到偏移量

555
00:21:07,570 --> 00:21:09,860
在相应的文件中。

556
00:21:09,970 --> 00:21:13,310
这就是我们已经做过的。

557
00:21:13,310 --> 00:21:16,670
这是我们第一次实现这个功能时所使用的~!@#$%^&*()

558
00:21:16,670 --> 00:21:19,475
这个NDNCX库与~!@#$%^&*()

559
00:21:19,475 --> 00:21:24,605
NFD我们在上面运行了一系列测试，

560
00:21:24,605 --> 00:21:26,825
我们被困在这里了。

561
00:21:26,825 --> 00:21:29,375
低于每秒一千兆比特的性能。

562
00:21:29,375 --> 00:21:31,730
如您在这两张图表中所见，

563
00:21:31,730 --> 00:21:34,020
在上面的第一张图表中，

564
00:21:34,200 --> 00:21:36,790
在我们对延迟应用接口后，

565
00:21:36,790 --> 00:21:40,370
吞吐量也下降了。

566
00:21:40,390 --> 00:21:43,280
它在运作。这是一个成功的实验，

567
00:21:43,280 --> 00:21:45,665
但卡车司机的表现并不理想。

568
00:21:45,665 --> 00:21:49,340
我们还比较了我们的消费者，它是

569
00:21:49,340 --> 00:21:51,140
嵌入在库中

570
00:21:51,140 --> 00:21:53,810
与NDN分块嵌入在库中，

571
00:21:53,810 --> 00:21:55,820
他们实际上表现出了

572
00:21:55,820 --> 00:21:58,055
他们实际上表现出了比那些应用程序更好。But either way,

573
00:21:58,055 --> 00:21:59,720
但无论如何，

574
00:21:59,720 --> 00:22:01,415
表现并不是很好。

575
00:22:01,415 --> 00:22:03,860
但我们继续

576
00:22:03,860 --> 00:22:05,540
测试这个插件只是为了

577
00:22:05,540 --> 00:22:07,025
看到NDN可以工作，

578
00:22:07,025 --> 00:22:10,815
和我们的一位同事，贾斯蒂斯。

579
00:22:10,815 --> 00:22:14,230
他进行了一系列测试并进行了比较。

580
00:22:14,230 --> 00:22:17,575
在这张图表中，您将看到具有多种存储解决方案的NDN。

581
00:22:17,575 --> 00:22:18,970
在这张图表中，您将看到

582
00:22:18,970 --> 00:22:21,400
在这张图表中，您将看到CMS工作的成功率，those user application that I

583
00:22:21,400 --> 00:22:22,870
was talking about earlier.

584
00:22:22,870 --> 00:22:25,180
我之前提到的。

585
00:22:25,180 --> 00:22:27,590
这是成功与失败的比率。

586
00:22:27,590 --> 00:22:29,275
他将其与...进行了比较。

587
00:22:29,275 --> 00:22:30,550
Ceph相比于Hadoop，

588
00:22:30,550 --> 00:22:32,425
反对使用

589
00:22:32,425 --> 00:22:34,410
分别任职于费米实验室的不同董事，

590
00:22:34,410 --> 00:22:35,965
分别任职于加州理工学院和欧洲核子研究中心，

591
00:22:35,965 --> 00:22:39,685
和针对所有不同类型的缓存。

592
00:22:39,685 --> 00:22:42,235
在这边右边，这是NDN。

593
00:22:42,235 --> 00:22:45,235
我们可以看到，至少对于这个测试来说，

594
00:22:45,235 --> 00:22:49,775
它的表现确实不错。

595
00:22:49,775 --> 00:22:51,640
展望未来，你可以

596
00:22:51,640 --> 00:22:53,480
也可以看出完成这些工作所需的时间

597
00:22:53,480 --> 00:22:56,710
可以完成这些工作所需的时间平均使用NDN库

598
00:22:56,710 --> 00:22:58,480
平均使用NDN库

599
00:22:58,480 --> 00:23:00,520
与另一种解决方案相比。

600
00:23:00,520 --> 00:23:02,740
这个想法不错，但随后我们知道

601
00:23:02,740 --> 00:23:04,660
我们知道，如果你想要

602
00:23:04,660 --> 00:23:06,970
使用成千上万的工作岗位，

603
00:23:06,970 --> 00:23:08,665
这在生产中发生，

604
00:23:08,665 --> 00:23:11,455
那么三重奏本会更好。

605
00:23:11,455 --> 00:23:14,055
我们继续寻找

606
00:23:14,055 --> 00:23:16,515
为了我们应用程序的性能表现。

607
00:23:16,515 --> 00:23:18,210
我们知道NFD~!@#$%^&*()

608
00:23:18,210 --> 00:23:20,545
是主要的瓶颈之一。

609
00:23:20,545 --> 00:23:22,345
幸运的是，同时我认为

610
00:23:22,345 --> 00:23:24,755
NDN团队在

611
00:23:24,755 --> 00:23:26,560
NIST已经在进行工作

612
00:23:26,560 --> 00:23:28,985
在NDN-DPDK转发器上。

613
00:23:28,985 --> 00:23:30,970
他们一发现那件事，

614
00:23:30,970 --> 00:23:32,110
我们实现了

615
00:23:32,110 --> 00:23:33,340
我们自己的DPDK消费者和

616
00:23:33,340 --> 00:23:34,689
生产者应用程序

617
00:23:34,689 --> 00:23:37,675
它们正在生成一个文件传输。

618
00:23:37,675 --> 00:23:40,235
我们在2019年的超级计算会议上演示了那个。

619
00:23:40,235 --> 00:23:47,740
我们获得了一个性能

620
00:23:47,740 --> 00:23:49,985
大约6.7吉比特

621
00:23:49,985 --> 00:23:52,885
每秒在广域网络上。

622
00:23:52,885 --> 00:23:56,300
但随之而来的缺点就是

623
00:23:56,300 --> 00:23:57,610
但事实上，

624
00:23:57,610 --> 00:23:59,375
没有适用于我们的NDN API，

625
00:23:59,375 --> 00:24:00,430
所以我们不得不自己实现

626
00:24:00,430 --> 00:24:02,450
几乎从零开始。

627
00:24:02,450 --> 00:24:06,620
对我们来说，这不是正确的方法。

628
00:24:06,620 --> 00:24:08,440
我们想要专注于其他事情，

629
00:24:08,440 --> 00:24:10,720
我们不打算从头开始重建NDN。

630
00:24:10,720 --> 00:24:13,175
但最糟糕的事情

631
00:24:13,175 --> 00:24:14,830
对我们来说，实际上是要部署

632
00:24:14,830 --> 00:24:19,120
需要在机器上部署这些应用程序。

633
00:24:19,120 --> 00:24:20,260
需要在CMS上部署这些应用程序，因为它们全部使用旧中心的机器。

634
00:24:20,260 --> 00:24:23,395
全部使用旧中心的机器。

635
00:24:23,395 --> 00:24:25,620
实际上开始是一件很费劲的事情。

636
00:24:25,620 --> 00:24:27,065
这种类型的DPDK应用程序

637
00:24:27,065 --> 00:24:29,365
的操作系统等等。

638
00:24:29,365 --> 00:24:30,670
虽然表现是

639
00:24:30,670 --> 00:24:31,990
虽然表现是非常好且有前途的，

640
00:24:31,990 --> 00:24:33,970
实际的可用性

641
00:24:33,970 --> 00:24:35,200
它以及还有

642
00:24:35,200 --> 00:24:37,135
发展并不是那么好。

643
00:24:37,135 --> 00:24:40,205
我们继续向前看，更进一步地探索。

644
00:24:40,205 --> 00:24:42,335
这个NDNgo库是

645
00:24:42,335 --> 00:24:44,065
也是由NIST开发的。

646
00:24:44,065 --> 00:24:46,055
我们开发的会议目标，

647
00:24:46,055 --> 00:24:47,215
消费者和生产者

648
00:24:47,215 --> 00:24:49,000
~!@#$%^&*()

649
00:24:49,000 --> 00:24:50,605
只是为了模拟文件传输。

650
00:24:50,605 --> 00:24:52,180
我们获得了大约2.2

651
00:24:52,180 --> 00:24:54,890
我们获得了大约2.2吉比特每秒的速度，仅仅是来自一个用户。We expecting maybe more because it already~!@#$%^&*()

652
00:24:54,890 --> 00:24:58,975
我们期待会有更多，因为它已经~!@#$%^&*()

653
00:24:58,975 --> 00:25:00,850
使用了许多这是接口

654
00:25:00,850 --> 00:25:03,445
但后来我们了解到这个库可以连接到NDN-DPDK。

655
00:25:03,445 --> 00:25:05,075
但后来我们了解到这个库

656
00:25:05,075 --> 00:25:06,820
但后来我们了解到这个库并不是为了这类事情而建造的，

657
00:25:06,820 --> 00:25:11,000
但更多是为了管理或货代。

658
00:25:11,310 --> 00:25:13,360
这是结果

659
00:25:13,360 --> 00:25:15,805
我们在2019年的超级计算会议上的表现。

660
00:25:15,805 --> 00:25:17,830
我们的表现

661
00:25:17,830 --> 00:25:20,000
大约每秒6.7吉比特。

662
00:25:20,000 --> 00:25:22,985
实验仅持续了三个小时，

663
00:25:22,985 --> 00:25:24,365
再次涉及DPDK

664
00:25:24,365 --> 00:25:26,395
消费者-生产者应用程序。

665
00:25:26,395 --> 00:25:29,135
那么我们到达了[听不清]处，

666
00:25:29,135 --> 00:25:31,555
正如严教授先前提到的，

667
00:25:31,555 --> 00:25:33,275
我们的目标是实现每秒100吉比特的速度。

668
00:25:33,275 --> 00:25:35,245
实现每秒100吉比特的速度。

669
00:25:35,245 --> 00:25:38,215
这可以提供总体吞吐量。

670
00:25:38,215 --> 00:25:40,810
我们在这里设计了这张图。

671
00:25:40,810 --> 00:25:43,280
你有一个NDN网络，

672
00:25:43,280 --> 00:25:46,210
你正在使用NDN-DPDK转发器。

673
00:25:46,210 --> 00:25:47,365
那么在一端，

674
00:25:47,365 --> 00:25:49,210
您有Ceph存储系统，它有

675
00:25:49,210 --> 00:25:52,135
访问CMS数据的权限。

676
00:25:52,135 --> 00:25:54,370
您有一台主机，它具有~!@#$%^&*()

677
00:25:54,370 --> 00:25:58,300
专用网卡在我们

678
00:25:58,300 --> 00:26:01,070
也可以运行Docker容器，

679
00:26:01,070 --> 00:26:02,170
可以运行Docker容器的地方，NDN-DPDK转发器运行在

680
00:26:02,170 --> 00:26:03,850
一个Docker容器中运行的NDN-DPDK转发器

681
00:26:03,850 --> 00:26:05,005
一个Docker容器和

682
00:26:05,005 --> 00:26:07,585
使用那个网络卡。

683
00:26:07,585 --> 00:26:10,240
那么你可能有

684
00:26:10,240 --> 00:26:12,100
一个使用的生产者

685
00:26:12,100 --> 00:26:14,500
memif（内存接口），它是用C++编写的。

686
00:26:14,500 --> 00:26:17,695
它速度快且可以访问存储空间，

687
00:26:17,695 --> 00:26:20,125
但也可以使用其他解决方案

688
00:26:20,125 --> 00:26:22,750
其他文件传输服务器

689
00:26:22,750 --> 00:26:26,230
像一个稍后将会介绍的那样。

690
00:26:26,230 --> 00:26:28,840
在左边，你有消费者。

691
00:26:28,840 --> 00:26:31,060
这又是在左手边。

692
00:26:31,060 --> 00:26:33,865
你可以拥有一台或多台主机。

693
00:26:33,865 --> 00:26:36,575
然后你还有一块专用的网卡。

694
00:26:36,575 --> 00:26:37,630
将被用于

695
00:26:37,630 --> 00:26:40,210
NDN-DPDK转发器

696
00:26:40,210 --> 00:26:41,605
运行Docker容器。

697
00:26:41,605 --> 00:26:43,745
那么其他的Docker容器将会

698
00:26:43,745 --> 00:26:46,050
实际上是XRootD插件，它们

699
00:26:46,050 --> 00:26:50,975
嵌入NDN消费者至其中。

700
00:26:50,975 --> 00:26:52,270
那么在那边，

701
00:26:52,270 --> 00:26:53,630
我们有成千上万的

702
00:26:53,630 --> 00:26:55,600
我们有成千上万的CMS作业正在访问这个XRootD应用程序。

703
00:26:55,600 --> 00:26:57,520
正在访问这个XRootD应用程序。

704
00:26:57,520 --> 00:26:58,975
然后他们将发送

705
00:26:58,975 --> 00:27:01,170
并跨网络请求数据。

706
00:27:01,170 --> 00:27:08,610
那么NDNc是什么？抱歉。

707
00:27:08,610 --> 00:27:14,085
>> 等一下，我正在运行那个文件。

708
00:27:14,085 --> 00:27:16,805
抱歉。是的，NDNc

709
00:27:16,805 --> 00:27:18,820
基本上是一个小型库，

710
00:27:18,820 --> 00:27:20,215
一组实际上的功能集合，

711
00:27:20,215 --> 00:27:22,780
将ndn-cxx支持重新加入到

712
00:27:22,780 --> 00:27:24,455
NDN-DPDK并且它使用

713
00:27:24,455 --> 00:27:27,130
内存共享数据包接口 memif。

714
00:27:27,130 --> 00:27:29,615
目前，我们已经实现了

715
00:27:29,615 --> 00:27:31,360
我们实现的GraphQL客户端，它使得

716
00:27:31,360 --> 00:27:33,370
我们配置转发器，

717
00:27:33,370 --> 00:27:35,555
像创建一个面孔，插入一个FibEntry，

718
00:27:35,555 --> 00:27:36,120
或删除

719
00:27:36,120 --> 00:27:38,570
来自货运代理的一些信息。

720
00:27:38,570 --> 00:27:40,620
目前，正如我所说，

721
00:27:40,620 --> 00:27:41,950
目前，正如我所说，有一个传输层，它是memif但是它是单线程的，

722
00:27:41,950 --> 00:27:44,170
是memif，但它是单线程的，

723
00:27:44,170 --> 00:27:46,840
也有一个面向对象，它允许我们能够

724
00:27:46,840 --> 00:27:48,295
发送一个或多个数据包

725
00:27:48,295 --> 00:27:49,795
在网络时期。

726
00:27:49,795 --> 00:27:53,095
它还提供了PIT令牌支持，

727
00:27:53,095 --> 00:27:55,930
它还提供了PIT令牌支持，这是ndn-cxx所不具备的功能。Yeah, we also have

728
00:27:55,930 --> 00:27:58,000
是的，我们还有

729
00:27:58,000 --> 00:28:00,580
一些你可以使用的抽象类

730
00:28:00,580 --> 00:28:02,320
来构建你的消费者-生产者应用程序

731
00:28:02,320 --> 00:28:04,495
在此之上还应有一些拥塞窗口控制，

732
00:28:04,495 --> 00:28:06,300
在此之前已经有了重传机制。

733
00:28:06,300 --> 00:28:08,845
我们有一个固定窗口和一个加性增大乘性减小(AIMD)机制。

734
00:28:08,845 --> 00:28:10,630
我们计划不久后会添加更多内容。

735
00:28:10,630 --> 00:28:13,090
我们还有一个日志记录器，同时也使用了CMake。

736
00:28:13,090 --> 00:28:16,460
我们还为部署所有这些内容编写了Dockerfile。

737
00:28:16,460 --> 00:28:18,320
我们使用了NDNc，

738
00:28:18,320 --> 00:28:19,690
我们已经构建了两个应用程序。

739
00:28:19,690 --> 00:28:21,820
我们已经构建了PING消费者应用程序，并且还构建了

740
00:28:21,820 --> 00:28:23,350
高效传输消费者

741
00:28:23,350 --> 00:28:24,920
和生产者应用程序。

742
00:28:24,920 --> 00:28:26,480
目前为止一切都好。

743
00:28:26,480 --> 00:28:28,630
仅凭一个消费者，

744
00:28:28,630 --> 00:28:32,015
秒的最大传输速率是4.3千兆比特。

745
00:28:32,015 --> 00:28:35,525
每秒传输6,600字节的有效载荷大小。

746
00:28:35,525 --> 00:28:38,315
我们认为这是前进的方向，并且我们希望在此基础上继续发展。

747
00:28:38,315 --> 00:28:42,130
我们认为这是向前迈进的方向，并且我们希望在此基础上继续构建。

748
00:28:42,130 --> 00:28:43,990
像我说的，我们会

749
00:28:43,990 --> 00:28:45,310
像继续带来更多

750
00:28:45,310 --> 00:28:46,750
提高标杆以

751
00:28:46,750 --> 00:28:49,745
识别可能的瓶颈，也许

752
00:28:49,745 --> 00:28:53,110
实现我们自己的一些方法，而不使用

753
00:28:53,110 --> 00:28:54,465
实现我们自己的一些方法，而不使用ndn-cxx的所有内容，增加多线程支持。

754
00:28:54,465 --> 00:28:56,630
增加多线程支持。

755
00:28:56,630 --> 00:29:00,530
既然我们也被要求制作一个愿望清单，

756
00:29:00,530 --> 00:29:01,820
我刚做了一个，

757
00:29:01,820 --> 00:29:03,815
实际上，

758
00:29:03,815 --> 00:29:05,290
也许会有更多人愿意

759
00:29:05,290 --> 00:29:06,910
加入我们的努力，我不知道。

760
00:29:06,910 --> 00:29:07,600
也许有一些其他人在这个社区

761
00:29:07,600 --> 00:29:09,220
也许有一些其他人在这个社区

762
00:29:09,220 --> 00:29:10,570
可能也和我们一样

763
00:29:10,570 --> 00:29:12,985
寻找吞吐量性能。

764
00:29:12,985 --> 00:29:15,385
一起工作将会很好。

765
00:29:15,385 --> 00:29:18,530
一起工作在这个项目上。谢谢。

766
00:29:19,050 --> 00:29:22,750
>> 很好，谢谢。有一些讨论在

767
00:29:22,750 --> 00:29:25,865
the Slack 频道上有人在询问关于

768
00:29:25,865 --> 00:29:27,365
你是如何能够

769
00:29:27,365 --> 00:29:29,770
实现超过五千兆比特的性能。

770
00:29:29,770 --> 00:29:31,945
你显示的是6.7，对吗？

771
00:29:31,945 --> 00:29:32,770
是的。

772
00:29:32,770 --> 00:29:34,780
>> 一个好问题是，

773
00:29:34,780 --> 00:29:37,015
>> 一个好问题是，what's on top of~!@#$%^&*()

774
00:29:37,015 --> 00:29:38,380
你的展位清单

775
00:29:38,380 --> 00:29:39,640
吞吐量性能？

776
00:29:39,640 --> 00:29:41,830
下一个瓶颈是什么？

777
00:29:41,830 --> 00:29:45,040
你打算解决吗？

778
00:29:45,040 --> 00:29:47,710
是的，这是一个好问题。

779
00:29:47,710 --> 00:29:51,190
这是一个新的网络，

780
00:29:51,190 --> 00:29:55,300
我们大约有4到5个月的时间承担不起这个费用。

781
00:29:55,300 --> 00:29:59,210
它还很年轻，这是一个新项目。

782
00:30:00,030 --> 00:30:02,795
像我说的，我们需要做基准测试。

783
00:30:02,795 --> 00:30:04,870
我们需要了解很多东西才能明白瓶颈在哪里。

784
00:30:04,870 --> 00:30:05,945
当然，在目前

785
00:30:05,945 --> 00:30:07,315
它是单线程的。

786
00:30:07,315 --> 00:30:09,785
最简单的方法就是采用多线程。

787
00:30:09,785 --> 00:30:11,910
但我认为在我们做那件事之前，

788
00:30:11,910 --> 00:30:13,145
我们希望能够

789
00:30:13,145 --> 00:30:15,430
获得最佳性能

790
00:30:15,430 --> 00:30:16,975
脱离单线程。

791
00:30:16,975 --> 00:30:19,085
是的，我们不知道。

792
00:30:19,085 --> 00:30:20,620
确切地说，如果我们有

793
00:30:20,620 --> 00:30:22,075
瓶颈在哪里以及这些瓶颈是什么，

794
00:30:22,075 --> 00:30:24,740
但我们需要做更多的测试。

795
00:30:24,740 --> 00:30:28,355
>> 好的，很好。再次感谢。

796
00:30:28,355 --> 00:30:30,070
您可以继续讨论

797
00:30:30,070 --> 00:30:32,095
在Slack频道上。

798
00:30:32,095 --> 00:30:35,005
您可以在那里处理一些事情。

799
00:30:35,005 --> 00:30:39,320
我们的下一位演讲嘉宾是宋思辰。

800
00:30:39,320 --> 00:30:42,570
宋思辰是一名硕士研究生，在

801
00:30:42,570 --> 00:30:46,050
宋思辰是一名硕士研究生，在加州大学洛杉矶分校担任研究助理，在互联网研究实验室从事NDN的研究工作。

802
00:30:46,050 --> 00:30:48,660
在互联网研究实验室从事NDN的研究工作。

803
00:30:48,660 --> 00:30:50,865
包括拥塞控制

804
00:30:50,865 --> 00:30:52,605
他还负责缓解措施。

805
00:30:52,605 --> 00:30:55,260
他将向我们介绍他的工作内容，包括

806
00:30:55,260 --> 00:30:56,460
网络拥塞控制

807
00:30:56,460 --> 00:30:58,865
支持这个项目。

808
00:30:58,865 --> 00:31:01,690
请继续，Sichen。

809
00:31:01,690 --> 00:31:05,995
>> 谢谢。你能看到我的屏幕吗？

810
00:31:05,995 --> 00:31:07,300
是否在场？

811
00:31:07,300 --> 00:31:09,095
>> 是的，可以开始了。是的。

812
00:31:09,095 --> 00:31:12,235
>> 它在场吗？

813
00:31:12,235 --> 00:31:14,230
>> 是的，它在屏幕上。

814
00:31:14,230 --> 00:31:21,020
>> 好的，谢谢。我是来自加州大学洛杉矶分校的Sichen，

815
00:31:21,020 --> 00:31:23,765
我将会讲述我们的工作，

816
00:31:23,765 --> 00:31:26,615
我们的基于速率的拥塞控制。

817
00:31:26,615 --> 00:31:29,960
让我们从问题描述开始。

818
00:31:29,960 --> 00:31:31,880
TCP/IP generally rely on window-based mechanisms.

819
00:31:31,880 --> 00:31:34,985
TCP/IP 通常基于窗口机制。

820
00:31:34,985 --> 00:31:37,385
这些算法是

821
00:31:37,385 --> 00:31:38,900
估算管道尺寸，

822
00:31:38,900 --> 00:31:41,030
的最大数量

823
00:31:41,030 --> 00:31:42,290
字节内

824
00:31:42,290 --> 00:31:44,075
不会破坏网络的情况下。

825
00:31:44,075 --> 00:31:46,010
调整冷凝器窗口

826
00:31:46,010 --> 00:31:47,570
两个P表示管道尺寸。

827
00:31:47,570 --> 00:31:48,980
在印度，有

828
00:31:48,980 --> 00:31:50,600
动态多遍次贫困和

829
00:31:50,600 --> 00:31:52,250
破坏性的缓存

830
00:31:52,250 --> 00:31:54,470
管道尺寸的概念。

831
00:31:54,470 --> 00:31:57,005
所以我们希望致力于工作

832
00:31:57,005 --> 00:31:58,730
一种拥塞控制算法

833
00:31:58,730 --> 00:32:02,000
该战场名为命名数据网络。

834
00:32:02,000 --> 00:32:04,580
算法应该能够适应

835
00:32:04,580 --> 00:32:07,625
可用带宽或我们的活动路径，

836
00:32:07,625 --> 00:32:09,155
并且它还应该是

837
00:32:09,155 --> 00:32:12,510
对往返时间的变化不敏感。

838
00:32:12,880 --> 00:32:16,535
我们希望通过让

839
00:32:16,535 --> 00:32:19,040
最终消费者进行测量和

840
00:32:19,040 --> 00:32:21,515
调整这些传输率。

841
00:32:21,515 --> 00:32:24,515
我们有四个按重要性排序的目标。

842
00:32:24,515 --> 00:32:26,840
设计应当是

843
00:32:26,840 --> 00:32:28,280
能够防止长队形成

844
00:32:28,280 --> 00:32:32,180
形成积压并且具有高带宽使用量。

845
00:32:32,180 --> 00:32:34,130
不依赖于数据包丢失

846
00:32:34,130 --> 00:32:35,810
作为拥塞信号。

847
00:32:35,810 --> 00:32:40,550
最后，它应该保证良好的公平性。

848
00:32:40,550 --> 00:32:43,920
至少不应该有人挨饿。

849
00:32:45,250 --> 00:32:47,450
为了这次演讲，我希望

850
00:32:47,450 --> 00:32:50,990
为了这次演讲，我希望谈论我们在工作中的进展情况。

851
00:32:50,990 --> 00:32:53,270
这部分的进展情况

852
00:32:53,270 --> 00:32:56,900
我会讲述我们当前的设计。

853
00:32:56,900 --> 00:32:59,960
所以关于拥塞控制以及相关内容

854
00:32:59,960 --> 00:33:02,495
一个有趣的观察结果

855
00:33:02,495 --> 00:33:04,055
测量干扰

856
00:33:04,055 --> 00:33:06,875
在消费者和他们的缓存之间。

857
00:33:06,875 --> 00:33:11,450
让我们从设计的基本概念开始。

858
00:33:11,450 --> 00:33:14,330
让我们从设计的基本概念开始。

859
00:33:14,330 --> 00:33:17,090
是为了控制发送方的利益。

860
00:33:17,090 --> 00:33:20,225
使用速率控制而非拥塞窗口

861
00:33:20,225 --> 00:33:22,730
我们一轮接一轮地进行。

862
00:33:22,730 --> 00:33:24,470
我们每一轮重新开始时，

863
00:33:24,470 --> 00:33:26,525
每次都不断地向我们发送相同的内容，

864
00:33:26,525 --> 00:33:28,430
消费者以相同的发送速率

865
00:33:28,430 --> 00:33:30,260
消费者以相同的发送速率

866
00:33:30,260 --> 00:33:32,825
用这条蓝线表示。

867
00:33:32,825 --> 00:33:34,775
这一直持续进行着

868
00:33:34,775 --> 00:33:36,185
最大往返时延

869
00:33:36,185 --> 00:33:37,985
在我们的转发路径中。

870
00:33:37,985 --> 00:33:39,650
这使得消费者

871
00:33:39,650 --> 00:33:40,970
观察效果

872
00:33:40,970 --> 00:33:45,620
这些速率在我们的多条折叠路径上。

873
00:33:45,620 --> 00:33:48,320
随后，一项测量

874
00:33:48,320 --> 00:33:49,430
数据到达率将会

875
00:33:49,430 --> 00:33:51,050
开始计时。

876
00:33:51,050 --> 00:33:53,150
在这段时间里，消费者

877
00:33:53,150 --> 00:33:54,590
尝试继续发送

878
00:33:54,590 --> 00:33:55,670
尝试获取

879
00:33:55,670 --> 00:33:58,385
准确的数据到达率测量。

880
00:33:58,385 --> 00:34:00,005
在这些部分结束之后，

881
00:34:00,005 --> 00:34:03,050
在这些部分结束之后，

882
00:34:03,050 --> 00:34:04,250
消费者需要做出

883
00:34:04,250 --> 00:34:06,395
消费者需要做出是否有拥堵的决定。

884
00:34:06,395 --> 00:34:07,805
这是通过

885
00:34:07,805 --> 00:34:09,650
阈值化差异

886
00:34:09,650 --> 00:34:11,420
数据到达率测量

887
00:34:11,420 --> 00:34:13,565
以及当前的利率发送率。

888
00:34:13,565 --> 00:34:15,785
如果有或多或少相同，

889
00:34:15,785 --> 00:34:17,270
消费者会认为有~!@#$%^&*()

890
00:34:17,270 --> 00:34:19,655
没有拥堵并且持续增长

891
00:34:19,655 --> 00:34:21,860
利率走势是否遵循~!@#$%^&*()

892
00:34:21,860 --> 00:34:23,450
类似于立方曲线

893
00:34:23,450 --> 00:34:25,895
到TCP立方的概念。

894
00:34:25,895 --> 00:34:29,645
在持续无拥堵地前行后，

895
00:34:29,645 --> 00:34:32,300
最终，消费者将得到更上一层的

896
00:34:32,300 --> 00:34:34,205
Ultimately, consumers will experience an improved level of network capacity and a congestion will be caused.

897
00:34:34,205 --> 00:34:36,425
将会引起拥堵。

898
00:34:36,425 --> 00:34:38,584
当这种情况发生时，

899
00:34:38,584 --> 00:34:42,095
预计消费者将会

900
00:34:42,095 --> 00:34:44,030
观察他显示出的兴趣

901
00:34:44,030 --> 00:34:45,380
速率将会更快于

902
00:34:45,380 --> 00:34:46,760
数据到达率

903
00:34:46,760 --> 00:34:49,160
并因此保持它们之间的差异，

904
00:34:49,160 --> 00:34:50,990
消费者将能够察觉

905
00:34:50,990 --> 00:34:53,090
在这一点上的拥堵情况

906
00:34:53,090 --> 00:34:55,670
触发了成倍的减少

907
00:34:55,670 --> 00:34:57,634
为了避免拥堵。

908
00:34:57,634 --> 00:35:00,050
当然，网络拥堵并不总是由这个消费者引起的。

909
00:35:00,050 --> 00:35:02,630
并不总是由这个消费者引起的，

910
00:35:02,630 --> 00:35:05,450
但也可能是由外部因素引起的。

911
00:35:05,450 --> 00:35:06,860
当交通拥堵时

912
00:35:06,860 --> 00:35:08,824
造成的外部因素。

913
00:35:08,824 --> 00:35:10,400
例如，一个瓶颈

914
00:35:10,400 --> 00:35:11,780
带宽突然下降了，

915
00:35:11,780 --> 00:35:14,060
我们作为消费者期待会看到

916
00:35:14,060 --> 00:35:15,950
一些意想不到的下降

917
00:35:15,950 --> 00:35:18,110
数据到达率以及如何

918
00:35:18,110 --> 00:35:19,520
在拥堵时迅速作出反应以及如何尽可能快地

919
00:35:19,520 --> 00:35:21,080
迅速地当

920
00:35:21,080 --> 00:35:22,520
消费者观察到一个~!@#$%^&*()

921
00:35:22,520 --> 00:35:24,965
数据到达率下降。

922
00:35:24,965 --> 00:35:26,405
它也将触发

923
00:35:26,405 --> 00:35:27,830
乘法减少

924
00:35:27,830 --> 00:35:30,125
扩展到更广泛的拥堵。

925
00:35:30,125 --> 00:35:33,199
有了这个基本概念，

926
00:35:33,199 --> 00:35:34,985
我将会讲述~!@#$%^&*()

927
00:35:34,985 --> 00:35:37,220
一个有趣的观察

928
00:35:37,220 --> 00:35:38,945
在我们的评估过程中，

929
00:35:38,945 --> 00:35:41,120
这是测量干扰。

930
00:35:41,120 --> 00:35:44,010
在消费者和他们的缓存之间。

931
00:35:44,860 --> 00:35:48,335
让我们从我们正在使用的场景开始。

932
00:35:48,335 --> 00:35:49,849
我们有两个消费者，

933
00:35:49,849 --> 00:35:51,860
C1和C2获取

934
00:35:51,860 --> 00:35:54,950
按顺序获取相同的数据对象。

935
00:35:54,950 --> 00:35:57,095
C2提早开始，所以它能够最初取得更多进展。

936
00:35:57,095 --> 00:35:59,400
能够最初取得更多进展。

937
00:35:59,400 --> 00:36:01,300
这里的货运代理F1有

938
00:36:01,300 --> 00:36:03,900
这里的货运代理F1有一个非常大的内容存储库。我们期望在C1启动后，

939
00:36:03,900 --> 00:36:06,980
我们期望在C1启动后，

940
00:36:06,980 --> 00:36:08,960
在最初阶段将会由此得到满足

941
00:36:08,960 --> 00:36:11,510
在最初阶段将会由此得到满足, 订单缓存已经有了，其带宽对转发器是

942
00:36:11,510 --> 00:36:14,510
sufficient for the initial phase, as there is already an order cache, and its bandwidth to the forwarder is much higher than the bandwidth to

943
00:36:14,510 --> 00:36:16,010
的带宽要远高于向

944
00:36:16,010 --> 00:36:17,725
的带宽要远高于向 the producer. It will eventually bring ~!@#$%^&*()

945
00:36:17,725 --> 00:36:19,870
It will eventually bring ~!@#$%^&*()

946
00:36:19,870 --> 00:36:22,390
缓存并能够赶上

947
00:36:22,390 --> 00:36:24,625
与其他早先开始的消费者一起

948
00:36:24,625 --> 00:36:28,080
与其他早先开始的消费者一起，早早地然后作为生产者感到满意。

949
00:36:28,080 --> 00:36:32,510
我们的评估显示，在我们的设计中，

950
00:36:32,510 --> 00:36:35,525
消费者C1将会保持

951
00:36:35,525 --> 00:36:37,070
满足于缓存大部分

952
00:36:37,070 --> 00:36:38,795
在稳态中的大部分时间里，

953
00:36:38,795 --> 00:36:41,030
所以他没能完全赶上。

954
00:36:41,030 --> 00:36:43,475
我们希望理解其中的原因。

955
00:36:43,475 --> 00:36:45,320
所以我们来看一下

956
00:36:45,320 --> 00:36:47,180
我们来看一下C1的观点，观察接下来会发生什么。

957
00:36:47,180 --> 00:36:49,250
观察接下来会发生什么。

958
00:36:49,250 --> 00:36:51,680
当然，最初的话，C1

959
00:36:51,680 --> 00:36:54,020
将由内容存储满足并且

960
00:36:54,020 --> 00:36:57,050
观察到的往返延迟

961
00:36:57,050 --> 00:36:58,670
将会是往返延迟

962
00:36:58,670 --> 00:37:01,190
到缓存中

963
00:37:01,190 --> 00:37:03,455
如果C1最终赶上了，

964
00:37:03,455 --> 00:37:05,990
它将会被生产者满足，并且

965
00:37:05,990 --> 00:37:07,580
这将导致往返延迟事件。

966
00:37:07,580 --> 00:37:09,875
这将是对生产者的往返延迟。

967
00:37:09,875 --> 00:37:12,845
然而，中间还有一个阶段。

968
00:37:12,845 --> 00:37:15,770
在这个阶段，通过

969
00:37:15,770 --> 00:37:17,030
C1的兴趣时刻

970
00:37:17,030 --> 00:37:18,455
前往货运代理商，

971
00:37:18,455 --> 00:37:20,510
早起者的利益

972
00:37:20,510 --> 00:37:21,980
已经通过了货代。

973
00:37:21,980 --> 00:37:24,770
所以货代只是聚合了那些利益。

974
00:37:24,770 --> 00:37:27,695
然而，早期的C2状态

975
00:37:27,695 --> 00:37:30,260
那时还没有回到缓存中。

976
00:37:30,260 --> 00:37:33,440
所以C1无法得到缓存的满足。

977
00:37:33,440 --> 00:37:35,450
所以C1会稍微等一会儿

978
00:37:35,450 --> 00:37:37,760
为了请求的数据

979
00:37:37,760 --> 00:37:40,340
其他消费者回来然后

980
00:37:40,340 --> 00:37:43,715
用来满足自身的利益。

981
00:37:43,715 --> 00:37:46,175
我们可以看到两次往返延迟，

982
00:37:46,175 --> 00:37:47,960
观察到的相似之处，在于……

983
00:37:47,960 --> 00:37:50,195
两个其他的终止状态。

984
00:37:50,195 --> 00:37:51,830
还有，往返延迟

985
00:37:51,830 --> 00:37:53,540
它观察到的取决于

986
00:37:53,540 --> 00:37:55,190
进度差异

987
00:37:55,190 --> 00:37:57,110
在两个消费者之间。

988
00:37:57,110 --> 00:37:59,540
由于C1正在试图追赶并且

989
00:37:59,540 --> 00:38:02,270
它的发送速度比另一个消费者快，

990
00:38:02,270 --> 00:38:05,180
我们会认为那是一个往返延迟，

991
00:38:05,180 --> 00:38:07,010
我们将逐步进行改变，因为

992
00:38:07,010 --> 00:38:08,810
进度差异是

993
00:38:08,810 --> 00:38:10,685
逐渐变化。

994
00:38:10,685 --> 00:38:12,605
如果我们仔细观察

995
00:38:12,605 --> 00:38:14,300
在这个中间阶段，

996
00:38:14,300 --> 00:38:16,100
你会发现不仅会

997
00:38:16,100 --> 00:38:18,980
C1看到了逐渐增加的往返延迟。

998
00:38:18,980 --> 00:38:23,180
但由于其他方式获取的数据

999
00:38:23,180 --> 00:38:25,835
将被用来满足C1的利益需求，

1000
00:38:25,835 --> 00:38:29,300
C1的数据到达率将显示为

1001
00:38:29,300 --> 00:38:30,920
C2的兴趣发送率

1002
00:38:30,920 --> 00:38:32,660
或C2的数据到达率。

1003
00:38:32,660 --> 00:38:34,565
嗯，与此同时C1正在

1004
00:38:34,565 --> 00:38:36,185
正在努力追赶，

1005
00:38:36,185 --> 00:38:39,050
将会比C2发送得更快。

1006
00:38:39,050 --> 00:38:40,340
这意味着C1，将会比C2发送得更快。

1007
00:38:40,340 --> 00:38:43,400
也将会看到不匹配的情况

1008
00:38:43,400 --> 00:38:44,690
其利息发送率和

1009
00:38:44,690 --> 00:38:46,160
数据到达率是

1010
00:38:46,160 --> 00:38:48,530
发送速度比接收速度快。

1011
00:38:48,530 --> 00:38:50,645
这两个都是，

1012
00:38:50,645 --> 00:38:52,640
that there is a congestion,

1013
00:38:52,640 --> 00:38:54,875
存在拥堵，

1014
00:38:54,875 --> 00:38:57,950
这在这种情况下并不成立，正如我们所知。

1015
00:38:57,950 --> 00:39:02,555
人们可能会问，这是一个问题吗？

1016
00:39:02,555 --> 00:39:05,150
因为C1得到了满足

1017
00:39:05,150 --> 00:39:08,300
缓存得到了有效利用。

1018
00:39:08,300 --> 00:39:10,595
这个瓶颈带宽被使用了。

1019
00:39:10,595 --> 00:39:12,515
这个首发和

1020
00:39:12,515 --> 00:39:14,495
也被有效利用。

1021
00:39:14,495 --> 00:39:18,620
嗯，我们需要研究一下这个问题。

1022
00:39:18,620 --> 00:39:21,140
我们需要研究的问题是，让我们...

1023
00:39:21,140 --> 00:39:23,930
说我改变了瓶颈环节

1024
00:39:23,930 --> 00:39:26,480
从第一个发起者到

1025
00:39:26,480 --> 00:39:30,500
转发者的价值非常低。

1026
00:39:30,500 --> 00:39:34,295
我们知道C1甚至都不使用这个链接。

1027
00:39:34,295 --> 00:39:36,440
当发生这种情况时，

1028
00:39:36,440 --> 00:39:38,360
虚假拥堵依然存在。

1029
00:39:38,360 --> 00:39:40,160
~!@#$%^&*()

1030
00:39:40,160 --> 00:39:42,770
试图追上第一个出发者，

1031
00:39:42,770 --> 00:39:45,005
它将始终检测到

1032
00:39:45,005 --> 00:39:47,780
它将放弃其带宽并造成拥堵。

1033
00:39:47,780 --> 00:39:49,430
因此，

1034
00:39:49,430 --> 00:39:51,950
C2的瓶颈环节

1035
00:39:51,950 --> 00:39:53,960
交给货运代理的那部分

1036
00:39:53,960 --> 00:39:55,865
没有被C1使用，

1037
00:39:55,865 --> 00:39:57,560
将会有一个限速因素

1038
00:39:57,560 --> 00:39:59,810
的C1性能表现以及

1039
00:39:59,810 --> 00:40:02,195
也是瓶颈环节

1040
00:40:02,195 --> 00:40:04,925
没有在这种情况下得到有效利用。

1041
00:40:04,925 --> 00:40:08,015
所以我认为这是一个有趣的问题，它

1042
00:40:08,015 --> 00:40:10,940
说明我们最初的设计

1043
00:40:10,940 --> 00:40:13,355
不符合要求的，

1044
00:40:13,355 --> 00:40:15,500
我们需要宽容。

1045
00:40:15,500 --> 00:40:17,670
穿越时光变迁的人。

1046
00:40:17,670 --> 00:40:19,270
我们也认为

1047
00:40:19,270 --> 00:40:21,070
这个问题可能会出现在

1048
00:40:21,070 --> 00:40:23,350
其他拥塞控制算法

1049
00:40:23,350 --> 00:40:25,060
依赖于最小的

1050
00:40:25,060 --> 00:40:26,395
往返时延测量，

1051
00:40:26,395 --> 00:40:29,600
例如TCP Vegas或PBR。

1052
00:40:30,420 --> 00:40:32,590
我们发现有

1053
00:40:32,590 --> 00:40:35,190
解决这个问题的真正潜在方法。

1054
00:40:35,190 --> 00:40:38,270
消费者方面是第一个问题，

1055
00:40:38,270 --> 00:40:42,275
如果消费者将会重新排序

1056
00:40:42,275 --> 00:40:44,165
它的段请求持有者

1057
00:40:44,165 --> 00:40:47,760
每当它看到往返时间增加时。

1058
00:40:47,890 --> 00:40:50,450
例如，当C1

1059
00:40:50,450 --> 00:40:52,235
看到往返时间增加，

1060
00:40:52,235 --> 00:40:55,490
它将重新排序它的段请求持有者和

1061
00:40:55,490 --> 00:40:57,170
C2现在将做同样的事情。

1062
00:40:57,170 --> 00:40:59,390
因为C1和C2就在手边，

1063
00:40:59,390 --> 00:41:01,100
我们将会有一个不同的

1064
00:41:01,100 --> 00:41:03,470
利息发放持有人。

1065
00:41:03,470 --> 00:41:05,870
因此，如果C1通过数据得到满足

1066
00:41:05,870 --> 00:41:08,300
被其他消费者请求，

1067
00:41:08,300 --> 00:41:10,100
它将能够

1068
00:41:10,100 --> 00:41:12,260
增加数据重排序或循环

1069
00:41:12,260 --> 00:41:14,240
增加行程时间样本的抖动，以便在中间阶段实现其转折。

1070
00:41:14,240 --> 00:41:16,940
将会取决于它是否在中间阶段。

1071
00:41:16,940 --> 00:41:20,060
另一种方式是请求货运代理提供帮助。

1072
00:41:20,060 --> 00:41:21,380
如果货运代理能够提供

1073
00:41:21,380 --> 00:41:23,840
消费者也可以了解是否积累了排队。

1074
00:41:23,840 --> 00:41:26,045
消费者也可以了解这一点，

1075
00:41:26,045 --> 00:41:27,620
其往返延迟时间

1076
00:41:27,620 --> 00:41:29,990
它观察到的正在增加，

1077
00:41:29,990 --> 00:41:32,030
它并不一定意味着

1078
00:41:32,030 --> 00:41:33,860
它并不一定意味着拥堵并且不会在那些情况下增加带宽。

1079
00:41:33,860 --> 00:41:36,900
在那些情况下增加带宽。

1080
00:41:37,270 --> 00:41:40,895
关于我们工作的下一步，

1081
00:41:40,895 --> 00:41:42,260
我们希望探索

1082
00:41:42,260 --> 00:41:44,000
探索一些非立方体的方法来

1083
00:41:44,000 --> 00:41:45,515
控制利益发送，

1084
00:41:45,515 --> 00:41:47,690
并且继续我们的研究工作

1085
00:41:47,690 --> 00:41:49,010
算法行为和

1086
00:41:49,010 --> 00:41:51,195
缓存和多路径转发。

1087
00:41:51,195 --> 00:41:53,170
最后，我们希望探索

1088
00:41:53,170 --> 00:41:55,270
一些潜在的货代反馈

1089
00:41:55,270 --> 00:41:57,160
提升性能的好处或者

1090
00:41:57,160 --> 00:41:57,955
设计

1091
00:41:57,955 --> 00:42:00,330
拥塞控制算法。

1092
00:42:00,330 --> 00:42:03,575
这就是我今天的演讲内容。

1093
00:42:03,575 --> 00:42:07,920
非常感谢，如果有任何问题，我们会提出来。

1094
00:42:08,380 --> 00:42:10,505
非常感谢，Sicheng，我们正在

1095
00:42:10,505 --> 00:42:11,570
我们正在快要没时间了。

1096
00:42:11,570 --> 00:42:12,830
我们有很多问题需要讨论。

1097
00:42:12,830 --> 00:42:15,990
这场演讲的内容和人们的反应。

1098
00:42:16,150 --> 00:42:19,655
是的，这是端到端的。

1099
00:42:19,655 --> 00:42:22,714
中间节点没有参与。

1100
00:42:22,714 --> 00:42:25,700
是的，是的。这是一个很好的问题。

1101
00:42:25,700 --> 00:42:30,275
所以我们希望从端到端开始，

1102
00:42:30,275 --> 00:42:33,200
首先因为它简单，而且，

1103
00:42:33,200 --> 00:42:36,770
我们希望能够很好地理解什么

1104
00:42:36,770 --> 00:42:38,630
那些是最终消费者可以~!@#$%^&*()

1105
00:42:38,630 --> 00:42:40,700
需要做的事情以及缺失的东西。

1106
00:42:40,700 --> 00:42:42,350
所以稍后我们可以移动到

1107
00:42:42,350 --> 00:42:45,380
一个更好的设计同时涉及更多的参与方，

1108
00:42:45,380 --> 00:42:48,090
尤其是涉及到的货运代理。

1109
00:42:50,030 --> 00:42:53,585
请继续在Slack频道上进行。

1110
00:42:53,585 --> 00:42:55,270
回答一些有趣的问题

1111
00:42:55,270 --> 00:42:57,405
在测量间隔期间，

1112
00:42:57,405 --> 00:42:58,800
考虑到

1113
00:42:58,800 --> 00:43:01,500
队列拥堵等问题。

1114
00:43:01,500 --> 00:43:03,005
为了节省时间，我们将

1115
00:43:03,005 --> 00:43:04,880
为了节省时间，我们将移交给下一位发言人。Thank you again Sichen.

1116
00:43:04,880 --> 00:43:06,465
再次感谢思辰。

1117
00:43:06,465 --> 00:43:08,570
下一位发言人是石俊霄。

1118
00:43:08,570 --> 00:43:10,355
他是美国国家标准与技术研究院的一名研究员，

1119
00:43:10,355 --> 00:43:12,785
他是核心NDN开发者，

1120
00:43:12,785 --> 00:43:14,130
他一直在开发

1121
00:43:14,130 --> 00:43:17,400
NDN网络自2013年以来一直在那里进行转发。

1122
00:43:17,400 --> 00:43:18,885
他将要谈论的是The~!@#$%^&*()

1123
00:43:18,885 --> 00:43:21,030
他将要谈论的是NDN-DPDK文件服务器，它是为了支持

1124
00:43:21,030 --> 00:43:22,700
发展以支持

1125
00:43:22,700 --> 00:43:25,010
这个项目。继续。

1126
00:43:25,010 --> 00:43:25,920
>> 正如你所说，那是俊晓。

1127
00:43:25,920 --> 00:43:26,820
我正在谈论的是

1128
00:43:26,820 --> 00:43:28,775
NDN-DPDK文件服务器

1129
00:43:28,775 --> 00:43:31,750
适用于数据密集型科学应用。

1130
00:43:31,970 --> 00:43:34,440
NDN-DPDK启动了

1131
00:43:34,440 --> 00:43:36,420
作为一个高速NDN转发器，

1132
00:43:36,420 --> 00:43:38,820
我们实现了每秒100吉字节的传输速度，

1133
00:43:38,820 --> 00:43:42,260
在ICN标准文件中的秒内

1134
00:43:42,260 --> 00:43:44,970
采用关键算法并减少

1135
00:43:44,970 --> 00:43:46,440
通过使用减少开销

1136
00:43:46,440 --> 00:43:48,935
的数据平面开发工具包。

1137
00:43:48,935 --> 00:43:51,570
今天的重点是文件服务器。

1138
00:43:51,570 --> 00:43:53,795
我们今年新开发的。

1139
00:43:53,795 --> 00:43:55,085
我们今年新开发的这个文件服务是因为我们已经有了做这件事的动机。

1140
00:43:55,085 --> 00:43:57,445
我们开发这个文件服务是因为我们已经有了...

1141
00:43:57,445 --> 00:43:59,290
与快速应用程序很搭配。

1142
00:43:59,290 --> 00:44:01,530
与快速应用程序很搭配。

1143
00:44:01,530 --> 00:44:03,525
他们使用的是数据密集型科学。

1144
00:44:03,525 --> 00:44:06,410
他们主要处理大数据或大型文件。

1145
00:44:06,410 --> 00:44:09,135
在大型强子对撞机的情况下，

1146
00:44:09,135 --> 00:44:13,715
它每天将处理数太字节的数据。

1147
00:44:13,715 --> 00:44:14,830
每天都有

1148
00:44:14,830 --> 00:44:15,850
已经存在

1149
00:44:15,850 --> 00:44:18,220
基于IP的复制系统，

1150
00:44:18,220 --> 00:44:19,775
以及基于IP的客户端，

1151
00:44:19,775 --> 00:44:22,070
因此，我们无法一夜之间改变。

1152
00:44:22,070 --> 00:44:23,785
一种常见的做法是

1153
00:44:23,785 --> 00:44:25,590
NDN文件服务器正在使用中

1154
00:44:25,590 --> 00:44:27,300
~!@#$%^&*()

1155
00:44:27,300 --> 00:44:30,215
提到的NDN Python仓库在今天早些时候。

1156
00:44:30,215 --> 00:44:32,255
但该仓库的缺点在于，

1157
00:44:32,255 --> 00:44:35,010
是当我们向仓库中插入一个文件时，

1158
00:44:35,010 --> 00:44:36,970
它需要将文件纠正为

1159
00:44:36,970 --> 00:44:39,020
在插入过程中的数据包，

1160
00:44:39,020 --> 00:44:40,745
使存储需求翻倍

1161
00:44:40,745 --> 00:44:42,740
并且有数以太字节的数据。

1162
00:44:42,740 --> 00:44:45,220
这在索引的情况下是不可行的。

1163
00:44:45,220 --> 00:44:47,440
NDN-DPDK文件服务器

1164
00:44:47,440 --> 00:44:48,840
它的工作方式不同。

1165
00:44:48,840 --> 00:44:51,930
它可以从现有存储中读取数据并且

1166
00:44:51,930 --> 00:44:53,525
然后在上面创建一个数据包

1167
00:44:53,525 --> 00:44:55,245
请求的飞行重量，

1168
00:44:55,245 --> 00:44:57,860
因此它不会使用更多的存储空间。

1169
00:44:57,860 --> 00:45:00,550
作为一种协议，文件服务器有两个步骤，

1170
00:45:00,550 --> 00:45:03,125
第一步是检索元数据。

1171
00:45:03,125 --> 00:45:07,765
元数据包含一个版本NDN前缀。

1172
00:45:07,765 --> 00:45:09,360
获取这个特定版本

1173
00:45:09,360 --> 00:45:10,045
的文件，

1174
00:45:10,045 --> 00:45:12,675
并且它包含了文件大小和时间戳。

1175
00:45:12,675 --> 00:45:14,270
它是的扩展

1176
00:45:14,270 --> 00:45:16,860
实时数据检索协议。

1177
00:45:16,860 --> 00:45:18,930
第二步被称为

1178
00:45:18,930 --> 00:45:21,215
一个文件内容片段

1179
00:45:21,215 --> 00:45:23,170
按照段落来说，目前，

1180
00:45:23,170 --> 00:45:24,495
它不支持

1181
00:45:24,495 --> 00:45:25,980
方程式符号因为它的~!@#$%^&*()

1182
00:45:25,980 --> 00:45:27,815
在使用场景中不需要，

1183
00:45:27,815 --> 00:45:29,910
但如果有必要的话，我们可以考虑添加这个功能。

1184
00:45:29,910 --> 00:45:32,090
我们有硬件加密加速器。

1185
00:45:32,090 --> 00:45:33,555
当然，当你考虑这个因素时，

1186
00:45:33,555 --> 00:45:35,315
你可以使用条件控制。

1187
00:45:35,315 --> 00:45:37,310
在之前的谈话中提到过。

1188
00:45:37,310 --> 00:45:39,430
这是作为文件服务器的一种方式，

1189
00:45:39,430 --> 00:45:41,250
访问底层存储

1190
00:45:41,250 --> 00:45:43,520
正在使用 io_uring。

1191
00:45:43,520 --> 00:45:44,990
正在使用 io_uring。

1192
00:45:44,990 --> 00:45:47,670
一种用于Linux的新异步I/O API。

1193
00:45:47,670 --> 00:45:50,170
它自Linux内核起就可用。

1194
00:45:50,170 --> 00:45:53,640
5.2版本中可用，并在后续的内核版本中得到增强。

1195
00:45:53,640 --> 00:45:56,030
io_uring的好处是，

1196
00:45:56,030 --> 00:45:57,700
它通过我们的系统发出请求。

1197
00:45:57,700 --> 00:46:00,185
成本 [噪声] 以及使用 read 或 aio_read。

1198
00:46:00,185 --> 00:46:02,500
应用程序的工作方式

1199
00:46:02,500 --> 00:46:04,950
例如NDN-DPDK文件服务器，

1200
00:46:04,950 --> 00:46:07,420
它准备了一个包含读取请求的内容，

1201
00:46:07,420 --> 00:46:09,910
该文件描述符、一个目标缓冲区，

1202
00:46:09,910 --> 00:46:11,945
和作为字节偏移量，它是

1203
00:46:11,945 --> 00:46:13,620
提交到内核

1205
00:46:15,105 --> 00:46:18,240
提交不需要系统成本，

1206
00:46:18,240 --> 00:46:20,915
和内核将会处理

1207
00:46:20,915 --> 00:46:23,045
这个请求，当它的

1208
00:46:23,045 --> 00:46:24,430
完成后它又回来了

1209
00:46:24,430 --> 00:46:25,890
在另一个完成后的终结中，

1210
00:46:25,890 --> 00:46:26,890
这是一个相关的过程。

1211
00:46:26,890 --> 00:46:27,790
此为一个冷却过程。

1212
00:46:27,790 --> 00:46:29,830
进一步比如发送一个数据包。

1213
00:46:29,830 --> 00:46:33,140
~!@#$%^&*()

1214
00:46:33,140 --> 00:46:34,845
这张图是一个

1215
00:46:34,845 --> 00:46:36,780
这张图是一个文件服务器的架构。

1216
00:46:36,780 --> 00:46:38,130
一台文件服务器连接到

1217
00:46:38,130 --> 00:46:40,330
一个本地NDN-DPDK转发器

1218
00:46:40,330 --> 00:46:41,525
所以我共享了内存

1219
00:46:41,525 --> 00:46:43,085
数据包接口，内存接口，

1220
00:46:43,085 --> 00:46:46,185
与国家发展和改革委员会图书馆的工作相同。

1221
00:46:46,185 --> 00:46:48,220
Then, the input test can be performed

1222
00:46:48,220 --> 00:46:49,450
低依赖性

1223
00:46:49,450 --> 00:46:51,165
几个生产者线程。

1224
00:46:51,165 --> 00:46:53,145
在我们的生产者线程内

1225
00:46:53,145 --> 00:46:54,570
即将到来的利益是

1226
00:46:54,570 --> 00:46:55,920
分类为原样[噪音]

1227
00:46:55,920 --> 00:46:58,455
对元数据感兴趣或对段落感兴趣。

1228
00:46:58,455 --> 00:47:00,650
对元数据感兴趣，它已经引起了极大的关注。

1229
00:47:00,650 --> 00:47:03,440
立即处理元数据，数据包。

1230
00:47:03,440 --> 00:47:05,230
针对细分市场的兴趣来说，它是

1231
00:47:05,230 --> 00:47:07,025
转换为读者请求，

1232
00:47:07,025 --> 00:47:10,185
然后发送到内核中的io_uring。

1233
00:47:10,185 --> 00:47:13,110
当io_reader请求完成后，

1234
00:47:13,110 --> 00:47:15,360
它以红色的形式返回给生产者，

1235
00:47:15,360 --> 00:47:16,685
然后它变成了

1236
00:47:16,685 --> 00:47:18,035
段数据，它~!@#$%^&*()

1237
00:47:18,035 --> 00:47:19,860
被发送到输出线程。

1238
00:47:19,860 --> 00:47:22,085
我们使用

1239
00:47:22,085 --> 00:47:24,980
这个打开的文件描述符表

1240
00:47:24,980 --> 00:47:26,475
在问题生产者线程中。

1241
00:47:26,475 --> 00:47:27,850
这个数据的目的是为了在问题生产者线程中重用结构。

1242
00:47:27,850 --> 00:47:29,145
结构是为了重用

1243
00:47:29,145 --> 00:47:30,345
一个用于

1244
00:47:30,345 --> 00:47:32,365
访问同一个文件的兴趣。

1245
00:47:32,365 --> 00:47:34,590
它包含了一个哈希表，

1246
00:47:34,590 --> 00:47:37,055
它通过文件名索引文件描述符，

1247
00:47:37,055 --> 00:47:38,730
因此我们就不需要

1248
00:47:38,730 --> 00:47:40,610
所以我们就不需要多次打开同一个文件。

1249
00:47:40,610 --> 00:47:42,425
当一个文件不再被

1250
00:47:42,425 --> 00:47:44,310
正在进行的读取请求不再使用时，

1251
00:47:44,310 --> 00:47:45,400
它将进入

1252
00:47:45,400 --> 00:47:47,520
它将进入清理队列并最终关闭。

1253
00:47:47,520 --> 00:47:51,120
我们进行了一些初步的基准测试。

1254
00:47:51,120 --> 00:47:52,560
使用了两台物理机。

1255
00:47:52,560 --> 00:47:53,845
我们运行了前向和~!@#$%^&*()

1256
00:47:53,845 --> 00:47:56,010
我们在物理机上运行了一个文件服务器。

1257
00:47:56,010 --> 00:47:58,290
底层存储使用的是MBME，

1258
00:47:58,290 --> 00:47:59,640
而且那超过了100

1259
00:47:59,640 --> 00:48:01,055
千兆位每秒的链路，

1260
00:48:01,055 --> 00:48:02,265
另一台机器运行

1261
00:48:02,265 --> 00:48:03,905
条件感知抓取器，

1262
00:48:03,905 --> 00:48:05,314
实现了

1263
00:48:05,314 --> 00:48:08,045
立方体状的条件控制算法

1264
00:48:08,045 --> 00:48:09,660
我们尝试传输

1265
00:48:09,660 --> 00:48:12,155
一个20千兆比特的单个文件

1266
00:48:12,155 --> 00:48:16,085
在特定拓扑结构中解决这些问题。

1267
00:48:16,085 --> 00:48:18,740
我们尝试了不同的段落大小，

1268
00:48:18,740 --> 00:48:20,660
我们进行了五次试验。

1269
00:48:20,660 --> 00:48:24,170
我们可以看到，如果我们使用

1270
00:48:24,170 --> 00:48:25,690
一个更大的段大小，那

1271
00:48:25,690 --> 00:48:27,620
我们可以得到更好的输入，

1272
00:48:27,620 --> 00:48:29,425
为了更大的段大小

1273
00:48:29,425 --> 00:48:30,555
为了更大的段大小，八千字节，我们在这个单元得到了这个好的输入，

1274
00:48:30,555 --> 00:48:33,265
我们在这个单元得到了这个好的输入，

1275
00:48:33,265 --> 00:48:36,090
我们在这个单元得到了这个好的输入，它是每秒1800兆字节，and this is roughly 60 percent of

1276
00:48:36,090 --> 00:48:39,240
这大约是理论最大值的60%

1277
00:48:39,240 --> 00:48:40,710
理论最大值

1278
00:48:40,710 --> 00:48:42,080
顺序读取加速

1279
00:48:42,080 --> 00:48:44,380
of this particular MVM device -> 特定的这款MVM设备上

1280
00:48:44,380 --> 00:48:46,305
在文件服务器端。

1281
00:48:46,305 --> 00:48:50,295
当然，NDN-DPDK也有一个转发器，

1282
00:48:50,295 --> 00:48:53,255
我们持续改进转发器。

1283
00:48:53,255 --> 00:48:56,055
我们今年做出的重要改进是，

1284
00:48:56,055 --> 00:49:00,125
是为了缓解输入的瓶颈。

1285
00:49:00,125 --> 00:49:02,950
因为在我们的IC和第20篇论文中输入为

1286
00:49:02,950 --> 00:49:04,665
线程被识别为

1287
00:49:04,665 --> 00:49:06,780
转发器的瓶颈。

1288
00:49:06,780 --> 00:49:09,275
现在我们可以使用多重输入。

1289
00:49:09,275 --> 00:49:10,920
作为线程转发器，

1290
00:49:10,920 --> 00:49:13,235
但这个功能是

1291
00:49:13,235 --> 00:49:14,590
受限于隐居和

1292
00:49:14,590 --> 00:49:15,830
他们的旅行限制，

1293
00:49:15,830 --> 00:49:17,465
因为这是一个当前的藏身之处

1294
00:49:17,465 --> 00:49:19,265
他们只懂IP。

1295
00:49:19,265 --> 00:49:21,670
这整个文件，我们只让它成功运行了

1296
00:49:21,670 --> 00:49:24,550
Mellanox ConnectX-5上的VXLAN传输

1297
00:49:24,550 --> 00:49:26,675
是一种适配器。

1298
00:49:26,675 --> 00:49:28,460
它的工作原理是当

1299
00:49:28,460 --> 00:49:30,360
一个数据包到达硬件时，

1300
00:49:30,360 --> 00:49:31,935
我们有一个序列

1301
00:49:31,935 --> 00:49:34,820
收到了调整国际空间站规则的通知。

1302
00:49:34,820 --> 00:49:36,740
那些规则，他们提到过。

1303
00:49:36,740 --> 00:49:38,070
源 IP 地址和

1304
00:49:38,070 --> 00:49:41,355
目的端口设置为VXLAN端口。

1305
00:49:41,355 --> 00:49:42,450
接着，硬件

1306
00:49:42,450 --> 00:49:43,835
在计算哈希值时

1307
00:49:43,835 --> 00:49:46,870
UDP 5元组，自EBX镜头起，

1308
00:49:46,870 --> 00:49:48,110
UDP源端口，

1309
00:49:48,110 --> 00:49:49,740
是一个随机数，

1310
00:49:49,740 --> 00:49:51,560
这意味着，每个数据包

1311
00:49:51,560 --> 00:49:53,540
可能会有不同的哈希值。

1312
00:49:53,540 --> 00:49:56,475
我们可以说硬件会捡起杀戮。

1313
00:49:56,475 --> 00:49:57,780
根据哈希值使用

1314
00:49:57,780 --> 00:49:59,545
根据哈希值的最后一部分，

1315
00:49:59,545 --> 00:50:01,010
所以如果我们有两个击杀，

1316
00:50:01,010 --> 00:50:05,415
它不能同时进入两个输入作为线程。

1317
00:50:05,415 --> 00:50:07,385
这有效缓解了

1318
00:50:07,385 --> 00:50:09,325
这有效缓解了瓶颈的输入。

1319
00:50:09,325 --> 00:50:11,585
当然，接下来的演讲是

1320
00:50:11,585 --> 00:50:14,055
关于FPGA加速，

1321
00:50:14,055 --> 00:50:16,210
它会替换所有吗？

1322
00:50:16,210 --> 00:50:19,720
这些以及输入线程的一部分。

1323
00:50:19,720 --> 00:50:22,050
为了衡量效果，

1324
00:50:22,050 --> 00:50:23,440
我们需要一个基准，

1325
00:50:23,440 --> 00:50:25,190
为了简化基准，

1326
00:50:25,190 --> 00:50:26,420
我们创建了一个

1327
00:50:26,420 --> 00:50:28,965
我们创建了一个交互式基准测试Web应用程序，

1328
00:50:28,965 --> 00:50:32,585
它是NDN-DPDK代码库的一部分。

1329
00:50:32,585 --> 00:50:34,110
如果你有一个拓扑图

1330
00:50:34,110 --> 00:50:35,800
像这样，然后你可以输入

1331
00:50:35,800 --> 00:50:37,630
一些参数然后系统会

1332
00:50:37,630 --> 00:50:38,980
将其自动化为一个基准

1333
00:50:38,980 --> 00:50:40,775
为您展示并作为结果呈现。

1334
00:50:40,775 --> 00:50:42,425
您在双向之后所需要的是，

1335
00:50:42,425 --> 00:50:44,375
我们做了一个基准测试来看看~!@#$%^&*()

1336
00:50:44,375 --> 00:50:45,660
我们如何有效地缓解

1337
00:50:45,660 --> 00:50:46,875
瓶颈的输入。

1338
00:50:46,875 --> 00:50:49,355
橙色部分是当我们有

1339
00:50:49,355 --> 00:50:50,650
只有一个输入线程和

1340
00:50:50,650 --> 00:50:52,565
蓝色部分是两个输入线程。

1341
00:50:52,565 --> 00:50:54,065
~!@#$%^&*()

1342
00:50:54,065 --> 00:50:55,585
只有一个输入线程，

1343
00:50:55,585 --> 00:50:57,570
输入线程成为了瓶颈，

1344
00:50:57,570 --> 00:50:59,875
当我们有六个，四个线程时，

1345
00:50:59,875 --> 00:51:04,425
它的速度是每秒109吉比特。

1346
00:51:04,425 --> 00:51:06,025
但是当我们有两个输入线程时，

1347
00:51:06,025 --> 00:51:08,150
我们达到了134千兆比特

1348
00:51:08,150 --> 00:51:10,120
我们达到了134千兆比特每秒，但这就是速度。如果我们有更多的转发线程

We've reached 134 terabits per second, but that's the speed. If we have even more forwarding threads

1349
00:51:10,120 --> 00:51:12,510
如果我们有更多的转发线程

1350
00:51:12,510 --> 00:51:13,940
随着超速者减速，

1351
00:51:13,940 --> 00:51:15,100
~!@#$%^&*()

1352
00:51:15,100 --> 00:51:19,230
一些内存和带宽限制，

1353
00:51:19,230 --> 00:51:22,340
我们都在不断深入挖掘这个领域。

1354
00:51:22,340 --> 00:51:25,240
此外，我们还尝试了

1355
00:51:25,240 --> 00:51:27,900
降低CPU使用率时

1356
00:51:27,900 --> 00:51:29,955
转发不是处理流量。

1357
00:51:29,955 --> 00:51:32,320
在测量YaNFD论文时，

1358
00:51:32,320 --> 00:51:35,880
NDN-DPDK使用的是100% CPU轮询，

1359
00:51:35,880 --> 00:51:37,980
所以轮询是基本的工作方式，

1360
00:51:37,980 --> 00:51:39,930
DPDK的工作方式是固定的，我无法改变这一点，

1361
00:51:39,930 --> 00:51:41,145
但这并非必须的。

1362
00:51:41,145 --> 00:51:43,010
使用100%的CPU资源，

1363
00:51:43,010 --> 00:51:44,435
所以我们引入了

1364
00:51:44,435 --> 00:51:47,380
因此我们引入了一个新的编译时选项：threadsleep。

1365
00:51:47,380 --> 00:51:50,255
如果一个线程在池中处理了0个数据包，

1366
00:51:50,255 --> 00:51:52,230
它是睡眠状态，哪怕只有一纳秒，

1367
00:51:52,230 --> 00:51:54,329
如果我仅仅添加持续性，

1368
00:51:54,329 --> 00:51:57,410
我们逐渐增加睡眠时间。

1369
00:51:57,410 --> 00:51:59,145
我们可以看到，如果我们有~!@#$%^&*()

1370
00:51:59,145 --> 00:52:02,220
一个带有线程睡眠选项的[听不清]。

1371
00:52:02,220 --> 00:52:03,660
使用设置基准来

1372
00:52:03,660 --> 00:52:05,270
仅稍微减少它们。

1373
00:52:05,270 --> 00:52:08,315
但当它不在处理时

1374
00:52:08,315 --> 00:52:11,430
任何不休眠的流量，

1375
00:52:11,430 --> 00:52:13,420
它将消耗14个CPU成本，

1376
00:52:13,420 --> 00:52:15,185
它在休眠状态下只会使用

1377
00:52:15,185 --> 00:52:18,015
在加起来时只会使用一半的CPU成本。

1378
00:52:18,015 --> 00:52:20,960
NDN-DPDK 代码库是

1379
00:52:20,960 --> 00:52:22,175
在 GitHub 上开源，

1380
00:52:22,175 --> 00:52:23,525
今年如你所见

1381
00:52:23,525 --> 00:52:24,900
我对文件服务器所做的操作，

1382
00:52:24,900 --> 00:52:26,749
作为交互式的基准，

1383
00:52:26,749 --> 00:52:27,900
也可以改善

1384
00:52:27,900 --> 00:52:29,970
用户文档，所以你可以按照那份文档

1385
00:52:29,970 --> 00:52:31,860
可以按照那份文档进行操作

1386
00:52:31,860 --> 00:52:34,125
可以按照那份文档进行操作，数据开始安装了。We also expanded the platform support.

1387
00:52:34,125 --> 00:52:37,140
我们还扩大了平台支持。

1388
00:52:37,140 --> 00:52:39,920
我们一直支持DB11 PVM。

1389
00:52:39,920 --> 00:52:43,420
我们现在允许使用IP，其思想是

1390
00:52:43,420 --> 00:52:47,290
与使用AFXDP驱动程序的适配器相同。

1391
00:52:47,290 --> 00:52:50,220
我们也支持了PLUDP。

1392
00:52:50,220 --> 00:52:52,230
我们还增加了对VX Nintendo传输的支持。

1393
00:52:52,230 --> 00:52:55,660
我们还增加了对容器网络的支持。

1394
00:52:55,660 --> 00:52:59,130
一个用于文件实验平台的文件。

1395
00:52:59,130 --> 00:53:01,480
谢谢。

1396
00:53:03,680 --> 00:53:06,325
>> 谢谢，俊霄，

1397
00:53:06,325 --> 00:53:08,190
我们只剩下五分钟了。

1398
00:53:08,190 --> 00:53:09,250
在这个环节中，我们只剩下

1399
00:53:09,250 --> 00:53:11,470
所以我们不接受提问，我们将继续进行

1400
00:53:11,470 --> 00:53:16,250
下一个演讲由Michael Lo进行。

1401
00:53:16,250 --> 00:53:18,375
我们将给予你Michael

1402
00:53:18,375 --> 00:53:19,890
等待将是十分钟。

1403
00:53:19,890 --> 00:53:23,570
距离下一个环节大概还有五分钟。

1404
00:53:23,570 --> 00:53:26,435
您可以开始共享屏幕了。

1405
00:53:26,435 --> 00:53:27,750
>> 你能看到屏幕吗？

1406
00:53:27,750 --> 00:53:30,710
>> 迈克尔？对不起。

1407
00:53:30,710 --> 00:53:31,720
>> 对不起，你[听不清][重叠的声音]。

1408
00:53:31,720 --> 00:53:33,875
>> 继续开始分享吧，

1409
00:53:33,875 --> 00:53:35,405
在我介绍你的时候继续开始分享吧，Michael Lo, 是

1410
00:53:35,405 --> 00:53:37,590
迈克尔·罗，是

1411
00:53:37,590 --> 00:53:39,990
迈克尔·罗，是一名在加州大学洛杉矶分校（UCLA）攻读研究生的学生，与教授Jason Cong合作

1412
00:53:39,990 --> 00:53:42,790
与教授Jason Cong在

1413
00:53:42,790 --> 00:53:46,235
领域特定计算中心。

1414
00:53:46,235 --> 00:53:47,160
他将要讲话

1415
00:53:47,160 --> 00:53:48,755
关于FPGA加速

1416
00:53:48,755 --> 00:53:50,375
关于NDN转发

1417
00:53:50,375 --> 00:53:52,355
或者刚才陈俊霄提到的。

1418
00:53:52,355 --> 00:53:54,410
请继续，迈克尔。

1419
00:53:54,410 --> 00:53:56,535
>> 你能看到屏幕吗？

1420
00:53:56,535 --> 00:53:58,550
>> 还没有。

1421
00:54:01,130 --> 00:54:03,825
>> 我能看到它。

1422
00:54:03,825 --> 00:54:07,130
>> 是的。现在怎么样？

1423
00:54:07,680 --> 00:54:10,370
>> 我能看到它。

1424
00:54:13,590 --> 00:54:17,020
>> 我将讨论我们在进展上的情况

1425
00:54:17,020 --> 00:54:18,940
基于FPGA的加速

1426
00:54:18,940 --> 00:54:21,085
用于转发管道。

1427
00:54:21,085 --> 00:54:23,185
作为一个快速的背景介绍，我们所有人

1428
00:54:23,185 --> 00:54:25,690
作为一个快速的背景介绍，我们所有人都了解NDN是如何工作的。如果一个节点正在寻找特定的数据，

1429
00:54:25,690 --> 00:54:28,195
如果一个节点正在寻找特定的数据，

1430
00:54:28,195 --> 00:54:30,145
它不必去找生产者。

1431
00:54:30,145 --> 00:54:32,905
已经有了那些数据

1432
00:54:32,905 --> 00:54:34,510
如果它的下一个近邻节点已经

1433
00:54:34,510 --> 00:54:37,585
与基于IP的系统相比，你必须要

1434
00:54:37,585 --> 00:54:39,430
转发你的请求到

1435
00:54:39,430 --> 00:54:41,215
指定的目的地。

1436
00:54:41,215 --> 00:54:43,435
使用NDN，你无需这样做。

1437
00:54:43,435 --> 00:54:45,745
这是一个快速的概述

1438
00:54:45,745 --> 00:54:47,830
的转发管道。

1439
00:54:47,830 --> 00:54:49,420
的转发管道 for /a/b,

1440
00:54:49,420 --> 00:54:51,100
的转发管道为/a/b，

1441
00:54:51,100 --> 00:54:55,690
如果它位于相邻的节点中，

1442
00:54:55,690 --> 00:54:56,740
那么你可以简单地抓住

1443
00:54:56,740 --> 00:54:58,495
数据就在封底里。

1444
00:54:58,495 --> 00:55:00,280
如果那些数据不存在，

1445
00:55:00,280 --> 00:55:01,000
你必须经过

1446
00:55:01,000 --> 00:55:02,335
整个转发逻辑。

1447
00:55:02,335 --> 00:55:03,790
你必须插入到

1448
00:55:03,790 --> 00:55:05,215
待处理的利息表

1449
00:55:05,215 --> 00:55:06,550
然后你必须去

1450
00:55:06,550 --> 00:55:07,975
通过路由表并找出

1451
00:55:07,975 --> 00:55:12,410
它将发送到的下一个节点是什么。

1452
00:55:12,690 --> 00:55:15,310
它将发送到的下一个节点是什么。One problem with the NDN architecture is that we

1453
00:55:15,310 --> 00:55:19,900
在NDN架构中，我们

1454
00:55:19,900 --> 00:55:20,800
注意到它使用了

1455
00:55:20,800 --> 00:55:22,150
它使用了层次化名称而不是固定的32位或者128位地址。

1456
00:55:22,150 --> 00:55:26,860
它使用分层的命名方式，而不是固定的32位或者128位地址。

1457
00:55:26,860 --> 00:55:29,860
这也是NDN的一个优势。

1458
00:55:29,860 --> 00:55:32,005
您可以使用不同长度的变量名。

1459
00:55:32,005 --> 00:55:34,910
为了表示您的数据，它们不是固定的。

1460
00:55:34,920 --> 00:55:39,160
这对上游用户来说很棒。

1461
00:55:39,160 --> 00:55:40,390
他们可以随意指定他们想要的。

1462
00:55:40,390 --> 00:55:42,565
然而，我们需要处理它，

1463
00:55:42,565 --> 00:55:44,410
我们需要找到某种方法来

1464
00:55:44,410 --> 00:55:46,300
将其转化为一个独一无二的或者

1465
00:55:46,300 --> 00:55:47,965
将其转化为一个独一无二的固定长度的标识符，以便

1466
00:55:47,965 --> 00:55:51,110
使得处理过程变得更加容易。

1467
00:55:51,180 --> 00:55:53,800
需要满足两个标准。

1468
00:55:53,800 --> 00:55:55,450
每个前缀需要具有

1469
00:55:55,450 --> 00:55:57,940
一个独特的哈希或一个独特的名称。

1470
00:55:57,940 --> 00:55:59,590
如果我们想将其表示为

1471
00:55:59,590 --> 00:56:01,210
一个固定数量的位，

1472
00:56:01,210 --> 00:56:03,310
然后我们使用某种哈希算法。

1473
00:56:03,310 --> 00:56:06,250
在这种情况下，它是一个SIP哈希。

1474
00:56:06,250 --> 00:56:08,440
在这种情况下，它是一个SIP哈希算法。

1475
00:56:08,440 --> 00:56:10,690
NDN与之稍有不同

1476
00:56:10,690 --> 00:56:15,040
NDN与之稍有不同，主要区别在于通常使用的SIP哈希。

1477
00:56:15,040 --> 00:56:17,185
NDN与之稍有不同，主要区别在于

1478
00:56:17,185 --> 00:56:18,670
NDN中使用的SIP哈希是

1479
00:56:18,670 --> 00:56:19,960
每个前缀的末尾，

1480
00:56:19,960 --> 00:56:21,070
你必须经历

1481
00:56:21,070 --> 00:56:23,550
额外六轮的

1482
00:56:23,550 --> 00:56:25,680
这些异或和额外的

1483
00:56:25,680 --> 00:56:27,240
加法和旋转操作

1484
00:56:27,240 --> 00:56:29,665
生成64位哈希。

1485
00:56:29,665 --> 00:56:31,525
我将简要说明一个例子。

1486
00:56:31,525 --> 00:56:33,010
我们举个例子，我们有

1487
00:56:33,010 --> 00:56:38,800
这个/aaaaa/bbbbb/ccccc/ddddd。

1488
00:56:38,800 --> 00:56:41,665
首先我们遍历字符串。

1489
00:56:41,665 --> 00:56:44,395
我们看到斜杠a是一个前缀。

1490
00:56:44,395 --> 00:56:47,680
我们需要进行六轮计算。

1491
00:56:47,680 --> 00:56:48,580
我们到目前为止完成的轮数是

1492
00:56:48,580 --> 00:56:49,600
我们到目前为止完成的轮数是

1493
00:56:49,600 --> 00:56:51,535
我们到目前为止完成的轮数是六，我们已经生成了一个哈希值。Now as we traverse even more,

1494
00:56:51,535 --> 00:56:53,440
我们继续遍历下去，

1495
00:56:53,440 --> 00:56:55,000
我们最终达到了八字节。

1496
00:56:55,000 --> 00:56:57,640
我们需要进行两轮计算。

1497
00:56:57,640 --> 00:56:59,290
我们已经进行了八轮计算。

1498
00:56:59,290 --> 00:57:01,465
我们已经进行了八轮计算。正如你所看到的，到目前为止我们仍然只生成了一个哈希值。

1499
00:57:01,465 --> 00:57:02,785
我们已经进行了八轮计算。正如你所看到的，到目前为止我们仍然只生成了一个哈希值。

1500
00:57:02,785 --> 00:57:04,675
遍历整个字符串，

1501
00:57:04,675 --> 00:57:07,780
我们需要进行30轮计算才能

1502
00:57:07,780 --> 00:57:11,875
我们需要进行30轮计算才能得到一个25个字符的名字。

1503
00:57:11,875 --> 00:57:14,515
正如你所见，这可能会变得

1504
00:57:14,515 --> 00:57:16,870
在你所输入的名称上，这可能会变得在计算上更为复杂，取决于

1505
00:57:16,870 --> 00:57:18,070
在你所输入的名称上，

1506
00:57:18,070 --> 00:57:20,155
尤其是如果你有很多

1507
00:57:20,155 --> 00:57:24,260
尤其是如果你有很多前缀在你的名字里，并且它们是简短的。总结一下，我们已经做了30轮。

1508
00:57:24,480 --> 00:57:26,950
总结一下，我们已经做了30轮

1509
00:57:26,950 --> 00:57:28,060
了计算工作。

1510
00:57:28,060 --> 00:57:30,010
完成了计算工作。一个25字符的输入，我们只产生了四个哈希。

1511
00:57:30,010 --> 00:57:33,340
我们只产生了四个哈希。

1512
00:57:33,340 --> 00:57:35,830
在调度表中查找

1513
00:57:35,830 --> 00:57:37,840
在调度表中查找

1514
00:57:37,840 --> 00:57:39,940
在你的调度表中查找

1515
00:57:39,940 --> 00:57:42,160
线程现在处理这个输入。

1516
00:57:42,160 --> 00:57:47,200
使用调度表的许多缺点

1517
00:57:47,200 --> 00:57:49,570
你需要尝试去弄清楚如何

1518
00:57:49,570 --> 00:57:51,160
去弄清楚如何

1519
00:57:51,160 --> 00:57:52,510
去弄清楚桌子有多大，

1520
00:57:52,510 --> 00:57:55,975
否则你会遇到问题。

1521
00:57:55,975 --> 00:57:58,540
否则你会遇到问题。

1522
00:57:58,540 --> 00:58:00,115
需要一个指定的前缀深度。

1523
00:58:00,115 --> 00:58:01,450
那么根据你的表格大小，

1524
00:58:01,450 --> 00:58:02,890
你使用最后的n位

1525
00:58:02,890 --> 00:58:05,810
将哈希用于索引那个表。

1526
00:58:07,020 --> 00:58:09,400
这可能会导致

1527
00:58:09,400 --> 00:58:12,370
这可能会导致一些关于弹跳你的表格的问题。

1528
00:58:12,370 --> 00:58:13,570
一个问题是如果你有太大的表格，

1529
00:58:13,570 --> 00:58:14,725
如果你的表格太大，

1530
00:58:14,725 --> 00:58:16,240
那么你的确很差劲

1531
00:58:16,240 --> 00:58:18,460
在查找期间的位置性

1532
00:58:18,460 --> 00:58:21,250
因为一个哈希值可能会

1533
00:58:21,250 --> 00:58:22,750
映射到同一个索引上，因此下一个哈希值进来时，可能不在缓存中。

1534
00:58:22,750 --> 00:58:24,040
可能不在缓存中。

1535
00:58:24,040 --> 00:58:25,360
你得驱逐~!@#$%^&*()

1536
00:58:25,360 --> 00:58:27,580
条目的输入和引入。

1537
00:58:27,580 --> 00:58:30,220
然后可能又有另一个哈希值传入，

1538
00:58:30,220 --> 00:58:33,310
你修正了前一个条目，就这样继续下去。

1539
00:58:33,310 --> 00:58:35,905
但是，如果你有一个较小的表格，

1540
00:58:35,905 --> 00:58:38,815
它可能导致线程工作负载不平衡。

1541
00:58:38,815 --> 00:58:40,690
这里作为一个例子，

1542
00:58:40,690 --> 00:58:42,790
我们可以使用最后16位

1543
00:58:42,790 --> 00:58:45,205
来索引分派表。

1544
00:58:45,205 --> 00:58:47,275
最后16位是完全相同的，

1545
00:58:47,275 --> 00:58:52,585
但是其他的48位并不相同。

1546
00:58:52,585 --> 00:58:55,240
但在这种情况下，这四个哈希值

1547
00:58:55,240 --> 00:58:57,100
将会被分配到一个线程中。

1548
00:58:57,100 --> 00:58:58,825
将会看到，如果你

1549
00:58:58,825 --> 00:59:00,760
使用这种情况下的最后一点。

1550
00:59:00,760 --> 00:59:02,740
它将会感应到两个不同的线程。

1551
00:59:02,740 --> 00:59:04,090
如果你使用最后18个，

1552
00:59:04,090 --> 00:59:05,800
它将会感应到四个不同的线程。

1553
00:59:05,800 --> 00:59:08,335
但正如我所说，

1554
00:59:08,335 --> 00:59:09,340
随着你使用更多的位，

1555
00:59:09,340 --> 00:59:12,290
你的表格大小将会增加。

1556
00:59:13,380 --> 00:59:16,735
在我们对FPGA进行的设计探索中，

1557
00:59:16,735 --> 00:59:18,955
我们的目标是尝试识别

1558
00:59:18,955 --> 00:59:20,590
任何在计算中的重叠

1559
00:59:20,590 --> 00:59:22,220
尽可能地。

1560
00:59:22,220 --> 00:59:24,090
对于SIP散列算法，

1561
00:59:24,090 --> 00:59:26,280
在计算上有一些重叠。

1562
00:59:26,280 --> 00:59:30,150
那么对于调度层来说，

1563
00:59:30,150 --> 00:59:31,470
我们实际上可以在此时进行它

1564
00:59:31,470 --> 00:59:34,445
哈希计算仍在进行中。

1565
00:59:34,445 --> 00:59:36,940
但这确实取决于深度。

1566
00:59:36,940 --> 00:59:38,650
指定查看是否

1567
00:59:38,650 --> 00:59:41,020
我们实际上可以隐藏这些重叠部分。

1568
00:59:41,020 --> 00:59:43,270
FPGA在这种情况下的一个优势是

1569
00:59:43,270 --> 00:59:45,010
FPGA在这种情况下相对于CPU的一个优势是，

1570
00:59:45,010 --> 00:59:47,530
因为这些组合重叠

1571
00:59:47,530 --> 00:59:49,855
对于这些并行查找，

1572
00:59:49,855 --> 00:59:51,790
它们相对来说很快。

1573
00:59:51,790 --> 00:59:53,485
任务而且它们很短。

1574
00:59:53,485 --> 00:59:55,270
它真的不值得

1575
00:59:55,270 --> 00:59:57,925
为此单独生成一个CPU线程是不值得的。

1576
00:59:57,925 --> 00:59:59,920
本质上你只是在引发

1577
00:59:59,920 --> 01:00:01,930
你只是在触发CPU产生线程开销。

1578
01:00:01,930 --> 01:00:03,520
但是使用FPGA设计，

1579
01:00:03,520 --> 01:00:04,870
你根本就不会遇到这个问题，

1580
01:00:04,870 --> 01:00:06,025
你根本就有这个

1581
01:00:06,025 --> 01:00:08,390
RE 已经嵌入到你的设计中了。

1582
01:00:08,730 --> 01:00:12,685
SIP哈希计算的重叠在哪里？

1583
01:00:12,685 --> 01:00:14,875
在NDN中。

1584
01:00:14,875 --> 01:00:16,960
每次你需要一个前缀的结尾，

1585
01:00:16,960 --> 01:00:19,375
你必须进行最后六轮的计算，

1586
01:00:19,375 --> 01:00:20,785
这实际上并不会

1587
01:00:20,785 --> 01:00:22,705
影响下一个前缀。

1588
01:00:22,705 --> 01:00:24,580
例如，在这种情况下，

1589
01:00:24,580 --> 01:00:25,900
我正在计算前缀

1590
01:00:25,900 --> 01:00:28,795
的/aa在一次时间步中。

1591
01:00:28,795 --> 01:00:31,240
I need to compute ~!@#$%^&*()

1592
01:00:31,240 --> 01:00:35,665
最后六轮和一个前缀 /aa。

1593
01:00:35,665 --> 01:00:37,750
但同时，我也可以开始

1594
01:00:37,750 --> 01:00:40,690
计算/bbbb的前缀。

1595
01:00:40,690 --> 01:00:43,255
我们已经有了一些竞争。

1596
01:00:43,255 --> 01:00:47,270
在最后一个之后，带上这些哈希值。

1597
01:00:47,610 --> 01:00:51,520
在查找过程中还有一点是让我们

1598
01:00:51,520 --> 01:00:54,805
如果我们指定深度等于2，

1599
01:00:54,805 --> 01:00:57,670
我们实际上只需要哈希值在

1600
01:00:57,670 --> 01:00:59,590
/bbbb 需要被发送到

1601
01:00:59,590 --> 01:01:01,000
查找表中的其余部分

1602
01:01:01,000 --> 01:01:02,800
哈希值仍在计算中。

1603
01:01:02,800 --> 01:01:05,995
然而，如果情况并非如此，实际上并没有太多好处，

1604
01:01:05,995 --> 01:01:07,630
例如，假设你的深度是

1605
01:01:07,630 --> 01:01:08,740
指定的更大于

1606
01:01:08,740 --> 01:01:10,240
名称上的前缀数量。

1607
01:01:10,240 --> 01:01:11,290
例如，我们假设

1608
01:01:11,290 --> 01:01:12,670
我的深度等于5，

1609
01:01:12,670 --> 01:01:15,640
那么我们实际上不会真正看到任何好处

1610
01:01:15,640 --> 01:01:17,560
这些查找重叠并行

1611
01:01:17,560 --> 01:01:18,730
hash reputation because I 必须等到名字的结尾才会

1612
01:01:18,730 --> 01:01:22,000
必须等到名字的结尾才会

1613
01:01:22,000 --> 01:01:23,260
在我可以发送它之前必须先计算出来

1614
01:01:23,260 --> 01:01:26,510
到命名分派表。

1615
01:01:26,880 --> 01:01:28,960
我们的设计中也是如此，

1616
01:01:28,960 --> 01:01:31,825
我们实现了一个自定义缓存。

1617
01:01:31,825 --> 01:01:34,675
我们不是要驱逐，比如说，

1618
01:01:34,675 --> 01:01:38,020
一条像在CPU中的64位线路，

1619
01:01:38,020 --> 01:01:39,550
我们实际上只是存储

1620
01:01:39,550 --> 01:01:44,210
我们实际上只是存储那些最近被访问的索引。Here's the overall architectural design.

1621
01:01:44,610 --> 01:01:47,590
这是整体的架构设计。

1622
01:01:47,590 --> 01:01:50,185
在FPGA上非常简单。

1623
01:01:50,185 --> 01:01:53,050
我们有两个内核。

1624
01:01:53,050 --> 01:01:55,150
一个专门负责哈希运算的内核。

1625
01:01:55,150 --> 01:01:55,630
另一个专门负责查找的内核。

1626
01:01:55,630 --> 01:01:57,100
专门负责查找。

1627
01:01:57,100 --> 01:01:59,200
本质上CPU正在发送

1628
01:01:59,200 --> 01:02:02,020
命名输入首先传递给哈希内核。

1629
01:02:02,020 --> 01:02:03,550
在我们的哈希内核中，

1630
01:02:03,550 --> 01:02:05,050
我们可以处理最新的数据。

1631
01:02:05,050 --> 01:02:07,525
并行处理命名字符串。

1632
01:02:07,525 --> 01:02:09,640
查找内核，它们只处理

1633
01:02:09,640 --> 01:02:11,560
一次只查找一个输入

1634
01:02:11,560 --> 01:02:15,910
它使用一个多路复用器进行输入

1635
01:02:15,910 --> 01:02:17,560
采用循环轮询的方式

1636
01:02:17,560 --> 01:02:20,830
来查找请求

1637
01:02:20,830 --> 01:02:22,330
来自每个处理单元

1638
01:02:22,330 --> 01:02:24,490
来自缓存内核。

1639
01:02:24,490 --> 01:02:28,885
这是我们的测试结果或方法论。

1640
01:02:28,885 --> 01:02:31,675
这是一个独立的比较。

1641
01:02:31,675 --> 01:02:34,405
我们只比较了哈希计算

1642
01:02:34,405 --> 01:02:36,670
相比于我们的CPU和查找

1643
01:02:36,670 --> 01:02:39,370
与我们的CPU和查找相比，完成的工作并没有完成

1644
01:02:39,370 --> 01:02:40,690
在一个端到端的过程中，我们

1645
01:02:40,690 --> 01:02:41,980
将其集成到转发器中。

1646
01:02:41,980 --> 01:02:43,945
我们还没有执行那一步。

1647
01:02:43,945 --> 01:02:46,360
但我们将来会尝试去做那一步。

1648
01:02:46,360 --> 01:02:48,280
我们的CPU在这里。

1649
01:02:48,280 --> 01:02:49,930
我们用它来进行比较。

1650
01:02:49,930 --> 01:02:53,110
我们可以看到，它有一个相当小的L1缓存，

1651
01:02:53,110 --> 01:02:56,150
但相对较大的L2和L3缓存。

1652
01:02:56,630 --> 01:02:59,370
是的，在这里。

1653
01:02:59,370 --> 01:03:01,290
我们将其与一个线程进行比较。

1654
01:03:01,290 --> 01:03:03,615
与一个处理单元相比较。

1655
01:03:03,615 --> 01:03:04,980
在水平轴上，

1656
01:03:04,980 --> 01:03:07,080
它是数量

1657
01:03:07,080 --> 01:03:08,460
在查找表中使用的位数，

1658
01:03:08,460 --> 01:03:10,350
然后在垂直轴上是

1659
01:03:10,350 --> 01:03:12,930
查询时指定的深度，

1660
01:03:12,930 --> 01:03:14,190
和在蓝色中是

1661
01:03:14,190 --> 01:03:15,450
CPU所需的时间是，

1662
01:03:15,450 --> 01:03:17,430
和黄金一样，FPGA所需的时间是。

1663
01:03:17,430 --> 01:03:18,870
正如你所看到的，随着你的进行，

1664
01:03:18,870 --> 01:03:21,540
垂直轴，

1665
01:03:21,540 --> 01:03:24,210
你可以开始看到CPU的情况，

1666
01:03:24,210 --> 01:03:25,260
缓存在

1667
01:03:25,260 --> 01:03:26,655
CPU真的开始发挥效果了。

1668
01:03:26,655 --> 01:03:30,195
从深度为2增加到深度为32，

1669
01:03:30,195 --> 01:03:31,440
你其实只是在

1670
01:03:31,440 --> 01:03:33,000
你其实只是在乱缓存。

1671
01:03:33,000 --> 01:03:34,080
你其实只是在乱缓存，至于FPGA，我们并没有真正看到那个问题在哪里。

1672
01:03:34,080 --> 01:03:35,100
我们并没有真正看到那个问题在哪里。

1673
01:03:35,100 --> 01:03:37,695
因为它们都被隐藏起来了。

1674
01:03:37,695 --> 01:03:40,050
是的，然后我们进行比较。

1675
01:03:40,050 --> 01:03:42,030
高达八个处理单元。

1676
01:03:42,030 --> 01:03:44,760
我们注意到的一点是对于

1677
01:03:44,760 --> 01:03:47,550
第四个处理元素

1678
01:03:47,550 --> 01:03:48,315
在FPGA上并且

1679
01:03:48,315 --> 01:03:49,770
在FPGA上的一个处理单元，

1680
01:03:49,770 --> 01:03:52,230
我们没有看到任何进一步的改进。

1681
01:03:52,230 --> 01:03:52,920
我们认为这是

1682
01:03:52,920 --> 01:03:54,030
一些通信开销

1683
01:03:54,030 --> 01:03:56,380
在CPU和FPGA之间。

1684
01:03:57,440 --> 01:04:00,150
作为未来工作的一部分，

1685
01:04:00,150 --> 01:04:02,160
有一件事我之前没有真正提到过

1686
01:04:02,160 --> 01:04:03,980
那是FPGA吗？

1687
01:04:03,980 --> 01:04:05,375
实际上需要

1688
01:04:05,375 --> 01:04:08,090
批处理您的名字输入。

1689
01:04:08,090 --> 01:04:10,100
所以本质上，我们不能做

1690
01:04:10,100 --> 01:04:13,485
任何实时计算。

1691
01:04:13,485 --> 01:04:15,135
假设如果你有

1692
01:04:15,135 --> 01:04:17,715
数据包每微秒到达一次，

1693
01:04:17,715 --> 01:04:19,545
FPGA期望你~!@#$%^&*()

1694
01:04:19,545 --> 01:04:22,620
批量处理，比如说，

1695
01:04:22,620 --> 01:04:23,910
~!@#$%^&*()

1696
01:04:23,910 --> 01:04:25,470
至少32个数据包在

1697
01:04:25,470 --> 01:04:26,580
在它能够之前至少需要一段时间

1698
01:04:26,580 --> 01:04:28,380
在它能够处理它之前至少需要一段时间，就像我之前说的，

1699
01:04:28,380 --> 01:04:29,250
这是为了减少

1700
01:04:29,250 --> 01:04:30,420
通信开销在

1701
01:04:30,420 --> 01:04:32,940
CPU和FPGA当然，

1702
01:04:32,940 --> 01:04:34,590
这在在线环境中是可行的。

1703
01:04:34,590 --> 01:04:36,345
由于你的延迟会非常高。

1704
01:04:36,345 --> 01:04:37,740
作为我们未来工作的一部分，我们正在

1705
01:04:37,740 --> 01:04:39,690
寻求替代

1706
01:04:39,690 --> 01:04:41,310
拥有额外的数据复制

1707
01:04:41,310 --> 01:04:42,960
被从CPU移动到FPGA，

1708
01:04:42,960 --> 01:04:45,975
我们正在考虑仅仅分配

1709
01:04:45,975 --> 01:04:48,000
我们正在考虑仅仅分配一个物理内存空间在CPU侧面，FPGA上。

1710
01:04:48,000 --> 01:04:49,200
我们正在考虑仅仅分配一个物理内存空间在CPU侧面，FPGA上，可以直接访问它。

1711
01:04:49,200 --> 01:04:51,370
可以直接访问它。

1712
01:04:53,930 --> 01:04:55,980
我们也希望支持

1713
01:04:55,980 --> 01:04:57,420
最长前缀匹配。

1714
01:04:57,420 --> 01:04:59,640
以前的论文一直在探索

1715
01:04:59,640 --> 01:05:01,110
最长前缀匹配以及如何减少所需的查找次数

1716
01:05:01,110 --> 01:05:03,105
减少所需的查找次数。

1717
01:05:03,105 --> 01:05:05,670
我们希望将这些设计集成进FPGA设计中，还有，

1718
01:05:05,670 --> 01:05:08,925
我们希望将这些设计集成进FPGA设计中，还有，

1719
01:05:08,925 --> 01:05:11,610
我们希望将这些设计集成进FPGA设计中，还有，NDN兴趣包可能会使用令牌而非命名输入。

1720
01:05:11,610 --> 01:05:15,855
可能会使用令牌而非命名输入。

1721
01:05:15,855 --> 01:05:20,130
这是用于接收数据包的，

1722
01:05:20,130 --> 01:05:21,810
收到请求，我们也希望能够

1723
01:05:21,810 --> 01:05:24,360
收到请求，我们也希望能够支持基于令牌的输入，然后最终，

1724
01:05:24,360 --> 01:05:26,790
我们希望将我们所有的工作整合进入

1725
01:05:26,790 --> 01:05:30,150
我们希望将我们所有的工作整合进入NDN DPDK仓库。>> All right. Thank you very much.

1726
01:05:30,150 --> 01:05:32,925
好的。非常感谢您。

1727
01:05:32,925 --> 01:05:35,295
Slack 上有一些讨论。

1728
01:05:35,295 --> 01:05:36,615
你可以看一看

1729
01:05:36,615 --> 01:05:39,930
我们继续进入下一个环节，

1730
01:05:39,930 --> 01:05:42,870
它被命名为战术与无线，

1731
01:05:42,870 --> 01:05:45,840
它由塔梅尔·拉斐尔共享。

1732
01:05:45,840 --> 01:05:47,250
塔梅尔获得了他的博士学位

1733
01:05:47,250 --> 01:05:48,300
在计算机工程领域

1734
01:05:48,300 --> 01:05:51,029
来自弗吉尼亚理工学院

1735
01:05:51,029 --> 01:05:52,425
他目前是一名

1736
01:05:52,425 --> 01:05:54,870
首席信息安全科学家

1737
01:05:54,870 --> 01:05:56,865
在Mitre公司。

1738
01:05:56,865 --> 01:06:00,180
塔默，请开始。

1739
01:06:00,180 --> 01:06:02,445
>> 你们都能听见我说话吗？

1740
01:06:02,445 --> 01:06:03,645
>> 是的。

1741
01:06:03,645 --> 01:06:07,110
>> 好的，太好了。谢谢你。这个环节，

1742
01:06:07,110 --> 01:06:09,120
我们有三场演讲。

1743
01:06:09,120 --> 01:06:12,435
第一场演讲将由DARPA进行。

1744
01:06:12,435 --> 01:06:13,920
安全移动终端上的DARPA

1745
01:06:13,920 --> 01:06:15,570
安全可靠的网络在

1746
01:06:15,570 --> 01:06:17,640
安全可靠的网络在战术边缘分享。The talk is going to be given

1747
01:06:17,640 --> 01:06:19,320
这场演讲即将由

1748
01:06:19,320 --> 01:06:20,910
即将由Dr. Mary Schurgot加入。

1749
01:06:20,910 --> 01:06:22,290
Dr. Mary Schurgot加入了

1750
01:06:22,290 --> 01:06:24,120
2020年3月加入了美国国防高级研究计划局（DARPA）担任

1751
01:06:24,120 --> 01:06:25,560
the Strategic Technology Office.

1752
01:06:25,560 --> 01:06:27,405
战略技术办公室。

1753
01:06:27,405 --> 01:06:28,890
她的研究兴趣包括

1754
01:06:28,890 --> 01:06:30,330
安全高效的数据共享，

1755
01:06:30,330 --> 01:06:32,340
自动化决策辅助工具，以及

1756
01:06:32,340 --> 01:06:33,405
新型网络设计

1757
01:06:33,405 --> 01:06:34,694
创新范式。

1758
01:06:34,694 --> 01:06:36,450
在加入DARPA之前，玛丽·舒尔戈特博士是

1759
01:06:36,450 --> 01:06:37,320
实践主任

1760
01:06:37,320 --> 01:06:38,310
的机器学习与

1761
01:06:38,310 --> 01:06:40,230
的边缘计算能力，CACI

1762
01:06:40,230 --> 01:06:42,585
之前是LGS Innovations，

1763
01:06:42,585 --> 01:06:43,800
她在那里开发和领导了

1764
01:06:43,800 --> 01:06:45,030
她在那里开发和领导了位于分析、网络安全和网络交叉点的项目。

1765
01:06:45,030 --> 01:06:47,565
分析、网络安全和网络互联。

1766
01:06:47,565 --> 01:06:49,905
Dr. Schurgot，请发言。

1767
01:06:49,905 --> 01:06:52,110
>> 谢谢，塔默。你能听到我说话吗？

1768
01:06:52,110 --> 01:06:54,735
能看到我的屏幕和我吗？

1769
01:06:54,735 --> 01:06:56,820
>> 是的，女士。

1770
01:06:56,820 --> 01:07:00,210
>> 谢谢你，塔默。[笑声] 大家好。

1771
01:07:00,210 --> 01:07:02,130
我很高兴再次来到这里。

1772
01:07:02,130 --> 01:07:03,900
感谢您的邀请。

1773
01:07:03,900 --> 01:07:07,320
我会尽力为您节省一些时间。

1774
01:07:07,320 --> 01:07:09,060
您可能对此比较熟悉

1775
01:07:09,060 --> 01:07:10,935
分享计划，然后我会

1776
01:07:10,935 --> 01:07:12,750
讨论一下我们在这方面的进展情况，然后我会

1777
01:07:12,750 --> 01:07:14,549
讨论一下MINC项目，

1778
01:07:14,549 --> 01:07:16,840
这是我的新程序。

1779
01:07:17,720 --> 01:07:19,860
我又要快速进行了。

1780
01:07:19,860 --> 01:07:20,970
因为我知道这个，所以我得快速地处理这件事。

1781
01:07:20,970 --> 01:07:24,135
这对你们很多人来说是一个复习。

1782
01:07:24,135 --> 01:07:28,140
SHARE项目始于2016年左右，

1783
01:07:28,140 --> 01:07:29,760
实现的目标真的是为了

1784
01:07:29,760 --> 01:07:32,490
实现实际数据共享在

1785
01:07:32,490 --> 01:07:35,220
实现多个安全级别的目标是

1786
01:07:35,220 --> 01:07:36,450
实现共享之间

1787
01:07:36,450 --> 01:07:39,330
美国军队及其联盟伙伴。

1788
01:07:39,330 --> 01:07:41,370
与事情的现状相比

1789
01:07:41,370 --> 01:07:43,230
在战术边缘完成的今天，

1790
01:07:43,230 --> 01:07:45,495
SHARE正试图带来

1791
01:07:45,495 --> 01:07:48,000
安全飞地技术和

1792
01:07:48,000 --> 01:07:49,470
MINC数据网络连接至

1793
01:07:49,470 --> 01:07:52,050
安全手持设备或者移动电话。

1794
01:07:52,050 --> 01:07:54,660
您在底部行看到的内容

1795
01:07:54,660 --> 01:07:56,010
这是三个主要的

1796
01:07:56,010 --> 01:07:57,480
这是三个主要的组成部分，用于分享，

1797
01:07:57,480 --> 01:07:58,560
第一个是

1798
01:07:58,560 --> 01:08:00,315
我们已经证明了我们可以移动

1799
01:08:00,315 --> 01:08:02,190
容器化软件从

1800
01:08:02,190 --> 01:08:04,860
云端到手持设备。

1801
01:08:04,860 --> 01:08:06,210
本质上是安全的

1802
01:08:06,210 --> 01:08:08,070
存储数据的飞地

1803
01:08:08,070 --> 01:08:09,630
不同的敏感度等级

1804
01:08:09,630 --> 01:08:11,550
在移动设备上

1805
01:08:11,550 --> 01:08:13,710
然后我们将其整合进来

1806
01:08:13,710 --> 01:08:15,135
与MINC数据网络一起，

1807
01:08:15,135 --> 01:08:17,025
我们正在进行双重加密

1808
01:08:17,025 --> 01:08:18,720
我们正在使用数据包并且利用NDN进行传输

1809
01:08:18,720 --> 01:08:20,970
利用NDN进行传输

1810
01:08:20,970 --> 01:08:22,590
在整个网络中传输这些数据包，

1811
01:08:22,590 --> 01:08:23,760
将数据缓存在

1812
01:08:23,760 --> 01:08:25,380
终端用户设备

1813
01:08:25,380 --> 01:08:27,735
然后第三个重点领域

1814
01:08:27,735 --> 01:08:29,280
一直都是关于

1815
01:08:29,280 --> 01:08:31,020
配置管理和制定

1816
01:08:31,020 --> 01:08:34,900
便于战斗人员使用SHARE。

1817
01:08:35,450 --> 01:08:37,350
再一次，为了这个人群，

1818
01:08:37,350 --> 01:08:38,025
我真的不需要

1819
01:08:38,025 --> 01:08:39,810
详细讨论MINC数据网络，

1820
01:08:39,810 --> 01:08:42,090
但是在这张幻灯片上，我将指出

1821
01:08:42,090 --> 01:08:43,260
SHARE集成了

1822
01:08:43,260 --> 01:08:45,075
战术突击工具包。

1823
01:08:45,075 --> 01:08:47,160
TAK是一个常用的应用程序，它是

1824
01:08:47,160 --> 01:08:49,950
用于战术边缘。

1825
01:08:49,950 --> 01:08:53,010
它用于交换指挥。

1826
01:08:53,010 --> 01:08:54,270
它用于交换指挥和控制以及情境意识应用程序。

1827
01:08:54,270 --> 01:08:55,590
意识应用程序。

1828
01:08:55,590 --> 01:08:57,450
因此你可以将其视为

1829
01:08:57,450 --> 01:09:00,180
一款运行在手持设备上的应用程序。

1830
01:09:00,180 --> 01:09:02,100
它有一个地图界面。

1831
01:09:02,100 --> 01:09:04,965
用户可以交换聊天消息，

1832
01:09:04,965 --> 01:09:06,900
图片，别人的位置，

1833
01:09:06,900 --> 01:09:08,970
位置信息显示在

1834
01:09:08,970 --> 01:09:11,565
地图上通常显示的是，

1835
01:09:11,565 --> 01:09:13,980
通常有一个客户端-服务器架构

1836
01:09:13,980 --> 01:09:16,620
在TAK生态系统中，SHARE

1837
01:09:16,620 --> 01:09:19,350
在TAK生态系统的整合下，我们向前迈进

1838
01:09:19,350 --> 01:09:20,400
MINC数据网络

1839
01:09:20,400 --> 01:09:22,560
范式和在这里你会

1840
01:09:22,560 --> 01:09:24,660
看到那些数据是

1841
01:09:24,660 --> 01:09:27,540
根据兴趣请求的，而且数据是

1842
01:09:27,540 --> 01:09:29,730
缓存在手持设备上并且

1843
01:09:29,730 --> 01:09:31,950
储存在网络的战略节点上并且

1844
01:09:31,950 --> 01:09:34,200
存储在网络的战略节点上并且那些虚线确实是代表在战术网络中的意思，

1845
01:09:34,200 --> 01:09:36,630
意味着在战术网络中代表的，

1846
01:09:36,630 --> 01:09:38,340
你有上下链接。

1847
01:09:38,340 --> 01:09:39,825
你的移动性很强。

1848
01:09:39,825 --> 01:09:41,820
您的链接非常间歇性。

1849
01:09:41,820 --> 01:09:43,260
那将具有能力去

1850
01:09:43,260 --> 01:09:44,910
在手机上缓存数据

1851
01:09:44,910 --> 01:09:48,100
在这种环境下确实非常宝贵。

1852
01:09:49,250 --> 01:09:53,100
SHARE工作的另一个分支已经是

1853
01:09:53,100 --> 01:09:57,420
与另一个部分的合作

1854
01:09:57,420 --> 01:10:00,930
国防部，这已经是并且是

1855
01:10:00,930 --> 01:10:03,300
整合共享能力

1856
01:10:03,300 --> 01:10:05,355
与5G技术相结合。

1857
01:10:05,355 --> 01:10:07,050
作为SHARE项目的一部分，

1858
01:10:07,050 --> 01:10:10,800
我们已经展示了安全隔离

1859
01:10:10,800 --> 01:10:13,230
我们已经展示了安全隔离，通过电话与那些安全飞地进行了结合。

1860
01:10:13,230 --> 01:10:15,120
但我们也将其与

1861
01:10:15,120 --> 01:10:18,375
网络切片概念。

1862
01:10:18,375 --> 01:10:20,820
在你这里看到的图中，再次，

1863
01:10:20,820 --> 01:10:25,035
您可以看到那些终端用户设备

1864
01:10:25,035 --> 01:10:27,390
正在查看

1865
01:10:27,390 --> 01:10:30,480
共享软件然后进一步

1866
01:10:30,480 --> 01:10:32,220
隔离数据在其传输过程中

1867
01:10:32,220 --> 01:10:33,570
网络是这个概念

1868
01:10:33,570 --> 01:10:34,950
的网络切片。

1869
01:10:34,950 --> 01:10:37,140
我们已经进行了演示

1870
01:10:37,140 --> 01:10:39,750
展示其价值

1871
01:10:39,750 --> 01:10:42,060
MINC数据网络连接~!@#$%^&*()

1872
01:10:42,060 --> 01:10:44,535
安全切片和

1873
01:10:44,535 --> 01:10:45,690
我们已经完成了一些工作，

1874
01:10:45,690 --> 01:10:49,290
我们实际上已经完成了

1875
01:10:49,290 --> 01:10:50,970
我们实际上已经完成了

1876
01:10:50,970 --> 01:10:53,440
完成了SHARE项目。

1877
01:10:54,800 --> 01:10:58,260
再次为SHARE项目画上句号，

1878
01:10:58,260 --> 01:10:59,955
我们正式结束

1879
01:10:59,955 --> 01:11:01,620
我们正式结束共享阶段的工作，并继续进入我的新项目MINC。

1880
01:11:01,620 --> 01:11:04,215
我们正在过渡到我的新项目MINC。

1881
01:11:04,215 --> 01:11:06,855
DARPA正在进行转型。

1882
01:11:06,855 --> 01:11:08,070
我们一直在合作

1883
01:11:08,070 --> 01:11:10,350
我们一直在合作，第75 Ranger团和美国陆军的其他部分

1884
01:11:10,350 --> 01:11:11,880
美国陆军的部分

1885
01:11:11,880 --> 01:11:14,220
针对他们的具体使用案例，

1886
01:11:14,220 --> 01:11:15,750
我们将会过渡

1887
01:11:15,750 --> 01:11:19,450
将技术应用到国防部的各个元素中。

1888
01:11:19,450 --> 01:11:20,660
我们正在继绀

1889
01:11:20,660 --> 01:11:23,075
我们正在继续我们与NIST的对话。

1890
01:11:23,075 --> 01:11:25,200
作为一个社区，

1891
01:11:25,200 --> 01:11:27,615
我们非常渴望继续参与进来，

1892
01:11:27,615 --> 01:11:30,300
和我认为将会有机会当我

1893
01:11:30,300 --> 01:11:32,040
过渡到我的MINC项目

1894
01:11:32,040 --> 01:11:33,780
继续参与其中。

1895
01:11:33,780 --> 01:11:36,190
让我来告诉你关于MINC的事情。

1896
01:11:36,440 --> 01:11:39,255
MINC是一个较新的程序。

1897
01:11:39,255 --> 01:11:40,590
它是在今年的四月时间框架内宣布的。

1898
01:11:40,590 --> 01:11:42,780
今年四月的时间框架内。

1899
01:11:42,780 --> 01:11:44,925
我们还没有宣布

1900
01:11:44,925 --> 01:11:46,920
我们还没有宣布谁被选中参加这个项目，but looking forward to announcing that soon.

1901
01:11:46,920 --> 01:11:49,995
但我们期待不久后就能宣布这一消息。

1902
01:11:49,995 --> 01:11:51,840
MINC代表任务

1903
01:11:51,840 --> 01:11:53,610
集成网络控制。

1904
01:11:53,610 --> 01:11:56,310
MINC的两个主要目标是

1905
01:11:56,310 --> 01:11:57,420
使其更容易

1906
01:11:57,420 --> 01:11:59,070
最初配置一个网络，

1907
01:11:59,070 --> 01:12:00,840
但随后也能够

1908
01:12:00,840 --> 01:12:03,165
采纳那个网络将会对你有益。

1909
01:12:03,165 --> 01:12:05,580
我再次提到的网络，

1910
01:12:05,580 --> 01:12:08,385
这些非常异构吗？

1911
01:12:08,385 --> 01:12:10,950
战术网络

1912
01:12:10,950 --> 01:12:12,150
由许多构成

1913
01:12:12,150 --> 01:12:13,530
遗留硬件，

1914
01:12:13,530 --> 01:12:16,020
许多遗留的战术无线电设备，

1915
01:12:16,020 --> 01:12:17,550
它们特别使其成为一个

1916
01:12:17,550 --> 01:12:19,839
具有挑战性的问题。

1917
01:12:19,850 --> 01:12:22,650
再次，存在对比之间

1918
01:12:22,650 --> 01:12:25,035
今天以及程序将会提供的内容。

1919
01:12:25,035 --> 01:12:26,715
今天我们有很多内容，

1920
01:12:26,715 --> 01:12:28,020
高负荷战斗,

1921
01:12:28,020 --> 01:12:29,955
网络和安全领域，

1922
01:12:29,955 --> 01:12:31,560
我们希望迈向一个未来，在那里

1923
01:12:31,560 --> 01:12:34,230
我们拥有无缝连接的能力，

1924
01:12:34,230 --> 01:12:36,300
我们可以无缝地引入

1925
01:12:36,300 --> 01:12:39,270
我们构建效果链时可以无缝地加入一个环节，

1926
01:12:39,270 --> 01:12:40,860
在构建效果链时能够无缝地加入一个环节，为那些效果链提供网络支持。

1927
01:12:40,860 --> 01:12:43,530
为那些效果链提供网络支持。

1928
01:12:43,530 --> 01:12:45,870
有两个真正关键的特征

1929
01:12:45,870 --> 01:12:47,580
与MINC有关。

1930
01:12:47,580 --> 01:12:49,590
这个想法首先是关于一个始终存在的~!@#$%^&*()

1931
01:12:49,590 --> 01:12:51,795
这个想法首先是关于一个始终存在的~!@#$%^&*(), 在安全控制覆盖层上的目的。

1932
01:12:51,795 --> 01:12:53,220
这个控制的目的

1933
01:12:53,220 --> 01:12:54,420
覆盖层的目的是能够

1934
01:12:54,420 --> 01:12:56,910
用于发现网络资源，

1935
01:12:56,910 --> 01:13:00,195
无论是内容管理系统（CMS）、计算还是存储。

1936
01:13:00,195 --> 01:13:02,715
那么第二个特点

1937
01:13:02,715 --> 01:13:04,110
是能够编写

1938
01:13:04,110 --> 01:13:05,490
这些网络资源在

1939
01:13:05,490 --> 01:13:08,030
需求转化为一个网络中的网络。

1940
01:13:08,030 --> 01:13:09,650
希望你已经开始了

1941
01:13:09,650 --> 01:13:12,155
为了形象化这个想法

1942
01:13:12,155 --> 01:13:14,840
一种软件可编程的软件定义

1943
01:13:14,840 --> 01:13:17,049
网络类型的环境。

1944
01:13:17,049 --> 01:13:20,415
但我们实际上正在尝试重新构想

1945
01:13:20,415 --> 01:13:24,105
为美国国防部定义的软件网络。

1946
01:13:24,105 --> 01:13:25,350
回到这个想法上来说，

1947
01:13:25,350 --> 01:13:27,479
我们拥有异构网络。

1948
01:13:27,479 --> 01:13:29,940
与传统设备相结合

1949
01:13:29,940 --> 01:13:31,680
与商业网络相比，

1950
01:13:31,680 --> 01:13:33,690
与商业网络相比，软件定义网络

1951
01:13:33,690 --> 01:13:35,535
在商业网络中的范式，

1952
01:13:35,535 --> 01:13:40,110
你可以有多种不同的数据套餐，

1953
01:13:40,110 --> 01:13:41,670
多种不同的控制平面，

1954
01:13:41,670 --> 01:13:43,560
所以我们需要能够连接那些

1955
01:13:43,560 --> 01:13:46,110
与一个安全的控制覆盖层相连接。

1956
01:13:46,110 --> 01:13:48,210
这确实是第一部分

1957
01:13:48,210 --> 01:13:49,680
MINC正在尝试做的事情是

1958
01:13:49,680 --> 01:13:53,220
MINC正在尝试做的事情的第一个重点领域是。

1959
01:13:53,220 --> 01:13:55,140
当然，给

1960
01:13:55,140 --> 01:13:57,060
对网络资源的认识，

1961
01:13:57,060 --> 01:13:58,230
所以能够发现

1962
01:13:58,230 --> 01:13:59,730
那些网络资源和

1963
01:13:59,730 --> 01:14:01,110
有完成任务的方法

1964
01:14:01,110 --> 01:14:02,910
那些网络资源，

1965
01:14:02,910 --> 01:14:04,575
那些都将来源于

1966
01:14:04,575 --> 01:14:06,030
一个管理平面或

1967
01:14:06,030 --> 01:14:08,610
一些编排框架。

1968
01:14:08,610 --> 01:14:10,725
希望如此，再一次。

1969
01:14:10,725 --> 01:14:12,630
提到了软件定义网络

1970
01:14:12,630 --> 01:14:13,830
在我开始之前，

1971
01:14:13,830 --> 01:14:15,675
现在希望你开始慢慢地

1972
01:14:15,675 --> 01:14:18,120
设想一种事物的机会

1973
01:14:18,120 --> 01:14:20,370
像名称、数据、网络这样的一般概念

1974
01:14:20,370 --> 01:14:21,690
such as names, data, networks

1975
01:14:21,690 --> 01:14:23,730
信息中心网络。

1976
01:14:23,730 --> 01:14:26,100
我们可以利用MINC的想法是

1977
01:14:26,100 --> 01:14:28,830
利用信息中心网络或者

1978
01:14:28,830 --> 01:14:30,795
利用信息中心网络或者专门的数据网络来实现

1979
01:14:30,795 --> 01:14:32,430
利用信息中心网络或者专门的数据网络来实现，能够构建安全控制覆盖层，该层覆盖在...上。

1980
01:14:32,430 --> 01:14:34,980
on top of the underlying security control overlay that rides

1981
01:14:34,980 --> 01:14:36,240
在底层之上

1982
01:14:36,240 --> 01:14:37,860
异构网络。

1983
01:14:37,860 --> 01:14:39,570
我们正在探索的一些其他概念包括

1984
01:14:39,570 --> 01:14:41,325
从商业领域引入

1985
01:14:41,325 --> 01:14:44,760
包括网络功能虚拟化，

1986
01:14:44,760 --> 01:14:47,160
它与STN（软件定义网络）密切相关，

1987
01:14:47,160 --> 01:14:48,435
以及这个想法

1988
01:14:48,435 --> 01:14:50,775
意图驱动的网络。

1989
01:14:50,775 --> 01:14:53,535
在MINC内部，我们真的想要

1990
01:14:53,535 --> 01:14:55,710
重新构想以意图为驱动的网络连接

1991
01:14:55,710 --> 01:14:57,585
作为以使命为驱动的网络连接。

1992
01:14:57,585 --> 01:14:58,920
我们如何从作为以使命为驱动的网络连接转变为将使命目标转化为网络目标？

1993
01:14:58,920 --> 01:15:02,250
将使命目标转化为网络目标？

1994
01:15:02,250 --> 01:15:05,385
那么我们作为一部分仔细阅读它

1995
01:15:05,385 --> 01:15:07,560
管理平面或作为我们正在进行的一部分

1996
01:15:07,560 --> 01:15:08,730
调用分布式网络

1997
01:15:08,730 --> 01:15:10,930
在MINC中进行编排。

1998
01:15:11,000 --> 01:15:14,745
除了安全控制覆盖层之外，

1999
01:15:14,745 --> 01:15:16,710
我稍微谈了一下那个。

2000
01:15:16,710 --> 01:15:18,420
我们的重点领域是1。

2001
01:15:18,420 --> 01:15:20,310
现在我们拥有了这种能力

2002
01:15:20,310 --> 01:15:23,230
重新在软件中编程，

2003
01:15:23,230 --> 01:15:24,680
我们有这种能力去

2004
01:15:24,680 --> 01:15:27,515
发现网络资源，并且能够坚韧可靠地发现

2005
01:15:27,515 --> 01:15:30,425
发现网络资源并且

2006
01:15:30,425 --> 01:15:32,510
实际上缓存了有关数据

2007
01:15:32,510 --> 01:15:33,830
这些网络资源和

2008
01:15:33,830 --> 01:15:35,915
他们相关的控制参数。

2009
01:15:35,915 --> 01:15:38,210
我们现在有这个机会去

2010
01:15:38,210 --> 01:15:41,045
成为那个分布式网络的一部分来进行管理。

2011
01:15:41,045 --> 01:15:42,680
成为那个分布式网络的一部分

2012
01:15:42,680 --> 01:15:44,975
编排不仅仅是

2013
01:15:44,975 --> 01:15:47,300
配置底层无线电设备

2014
01:15:47,300 --> 01:15:49,385
正在形成这些网络的设备，

2015
01:15:49,385 --> 01:15:50,899
但也要

2016
01:15:50,899 --> 01:15:53,090
建议调动

2017
01:15:53,090 --> 01:15:55,160
更好地利用通信资源

2018
01:15:55,160 --> 01:15:58,915
启用网络和通信。

2019
01:15:58,915 --> 01:16:01,770
那么另一个关注点是

2020
01:16:01,770 --> 01:16:04,650
那么另一个关注点是不仅要管理网络，but the data or information as well.

2021
01:16:04,650 --> 01:16:07,095
但也要管理数据或信息。

2022
01:16:07,095 --> 01:16:08,700
在网络精神中

2023
01:16:08,700 --> 01:16:10,380
功能虚拟化，

2024
01:16:10,380 --> 01:16:13,185
我们正在将该合同泛化以包括

2025
01:16:13,185 --> 01:16:17,220
网络信息与安全管理。

2026
01:16:17,220 --> 01:16:19,035
Then of course, I talked a bit about ~!@#$%^&*()

2027
01:16:19,035 --> 01:16:20,745
面向意图的网络

2028
01:16:20,745 --> 01:16:22,140
在军事任务中，

2029
01:16:22,140 --> 01:16:25,365
这被纳入到重点领域3中，

2030
01:16:25,365 --> 01:16:28,020
这将会被整合进

2031
01:16:28,020 --> 01:16:30,450
这一切将会被整合进一个系统。

2032
01:16:30,450 --> 01:16:32,790
只是快速确认一下时间。

2033
01:16:32,790 --> 01:16:34,635
我只剩下两张幻灯片了。

2034
01:16:34,635 --> 01:16:37,380
我提到过，我们

2035
01:16:37,380 --> 01:16:38,400
还没有宣布谁是

2036
01:16:38,400 --> 01:16:39,900
尚未选定参加该计划的人选，

2037
01:16:39,900 --> 01:16:41,460
但我们将在接下来的几个月启动该计划。

2038
01:16:41,460 --> 01:16:43,245
我们将在接下来的几个月启动该计划。

2039
01:16:43,245 --> 01:16:44,940
我非常期待在接下来的几个月启动该计划，直到一年后能够

2040
01:16:44,940 --> 01:16:46,500
看到一年后能够

2041
01:16:46,500 --> 01:16:48,420
报告关于进展情况

2042
01:16:48,420 --> 01:16:49,980
我们在使用和应用方面取得的进展情况

2043
01:16:49,980 --> 01:16:52,290
应用命名数据网络概念

2044
01:16:52,290 --> 01:16:54,990
形成一个安全的控制覆盖层。

2045
01:16:54,990 --> 01:16:56,190
这就是我们将要构建的内容。

2046
01:16:56,190 --> 01:16:57,435
我们将在第一阶段推出。

2047
01:16:57,435 --> 01:16:59,100
真正专注于

2048
01:16:59,100 --> 01:17:02,145
那个安全控制覆盖层以及正在开发的

2049
01:17:02,145 --> 01:17:05,640
一个支持MINC的蓝军网络

2050
01:17:05,640 --> 01:17:07,860
态势感知应用程序。

2051
01:17:07,860 --> 01:17:09,810
随着程序的推进，

2052
01:17:09,810 --> 01:17:11,385
我们将继续进行

2053
01:17:11,385 --> 01:17:13,800
我们将继续进行开发算法和完善它们的能力，并增加。

2054
01:17:13,800 --> 01:17:15,840
我们将继续增强功能并且添加

2055
01:17:15,840 --> 01:17:18,255
越来越多支持MINC的应用程序

2056
01:17:18,255 --> 01:17:20,310
随着各个阶段的推进。

2057
01:17:20,310 --> 01:17:22,260
最后但同样重要的是，

2058
01:17:22,260 --> 01:17:24,240
我谈到了我的SHARE幻灯片，

2059
01:17:24,240 --> 01:17:26,010
我们是如何合作的

2060
01:17:26,010 --> 01:17:27,645
第75游骑兵团，

2061
01:17:27,645 --> 01:17:29,550
我们希望继续保持这种势头在

2062
01:17:29,550 --> 01:17:32,220
我们希望继续保持这种势头在MINC项目中，并真正发展MINC，根据操作员所了解的情况进行调整。

2063
01:17:32,220 --> 01:17:33,750
了解到的情况来指导

2064
01:17:33,750 --> 01:17:34,860
正在寻找并且有能力~!@#$%^&*()

2065
01:17:34,860 --> 01:17:38,295
满足战术边缘的需求。

2066
01:17:38,295 --> 01:17:41,200
回到你这边了，钱德勒。

2067
01:17:42,050 --> 01:17:44,355
>> 谢谢你，舒尔戈特博士。

2068
01:17:44,355 --> 01:17:46,890
我没有看到任何问题。

2069
01:17:46,890 --> 01:17:49,530
在聊天中我没有看到任何问题，但我这里有一个很快速的问题。

2070
01:17:49,530 --> 01:17:52,140
在吸取的教训方面

2071
01:17:52,140 --> 01:17:53,790
the SHARE program 和如何~!@#$%^&*()

2072
01:17:53,790 --> 01:17:56,010
可以反馈到他们的社区中，

2073
01:17:56,010 --> 01:17:57,615
可以稍微谈一谈在那里做了些什么吗？

2074
01:17:57,615 --> 01:17:59,625
在那里做了些什么。

2075
01:17:59,625 --> 01:18:03,420
>> 当然。我们已经在其他社区会议上讨论过这个问题，

2076
01:18:03,420 --> 01:18:05,070
已经在其他社区会议上讨论过这个问题，

2077
01:18:05,070 --> 01:18:06,990
但是SHARE表演者，

2078
01:18:06,990 --> 01:18:08,850
实际上是那些正在开发的人员

2079
01:18:08,850 --> 01:18:10,860
实际上是那些正在开发的人员，the capabilities have made some enhancements and changes.

2080
01:18:10,860 --> 01:18:14,085
一些增强和变更

2081
01:18:14,085 --> 01:18:16,230
对底层NDN代码库进行了增强和变更。

2082
01:18:16,230 --> 01:18:17,550
我们已经增加了一些功能。

2083
01:18:17,550 --> 01:18:19,770
像持久订阅，

2084
01:18:19,770 --> 01:18:21,360
它我知道有点违背了

2085
01:18:21,360 --> 01:18:23,670
NDN范式，

2086
01:18:23,670 --> 01:18:26,895
在这个群体中有点有争议。

2087
01:18:26,895 --> 01:18:27,870
但我们已经取得了

2088
01:18:27,870 --> 01:18:29,700
我们已经取得了额外的安全改进和

2089
01:18:29,700 --> 01:18:32,970
实现长期目标是能够获得

2090
01:18:32,970 --> 01:18:34,770
业界领先的解决方案来自

2091
01:18:34,770 --> 01:18:36,960
分享和可能的MINC，以及确实

2092
01:18:36,960 --> 01:18:38,070
为之做出贡献回馈给

2093
01:18:38,070 --> 01:18:39,465
为社区做出贡献并努力工作以实现

2094
01:18:39,465 --> 01:18:43,050
更标准化的DoD(国防部)

2095
01:18:43,050 --> 01:18:45,640
和NDN类型的能力。

2096
01:18:46,760 --> 01:18:50,500
>> 太棒了。谢谢你，舒尔戈特博士。

2097
01:18:52,560 --> 01:18:55,250
我们下一位演讲嘉宾。

2098
01:18:55,250 --> 01:18:58,100
我们下一位演讲嘉宾是穆罕默德·埃尔巴德里。

2099
01:18:58,100 --> 01:19:00,520
它是朝着统一的方向发展

2100
01:19:00,520 --> 01:19:03,890
的名称和地址基于通信。

2101
01:19:04,030 --> 01:19:06,920
让我来读一下穆罕默德的简介。

2102
01:19:06,920 --> 01:19:08,855
他是一名博士研究生，在

2103
01:19:08,855 --> 01:19:10,220
计算机工程系

2104
01:19:10,220 --> 01:19:11,420
斯托尼布鲁克大学。

2105
01:19:11,420 --> 01:19:12,920
他的研究重点是

2106
01:19:12,920 --> 01:19:14,300
无线介质访问控制

2107
01:19:14,300 --> 01:19:16,625
设计。转交给您了，先生。

2108
01:19:16,625 --> 01:19:18,705
>> 非常感谢您。

2109
01:19:18,705 --> 01:19:20,555
让我分享我的屏幕。

2110
01:19:20,555 --> 01:19:22,745
你能看到幻灯片吗？

2111
01:19:22,745 --> 01:19:26,130
>> 我这边可以看到。

2112
01:19:27,120 --> 01:19:30,345
>> 大家好。我将要过去，

2113
01:19:30,345 --> 01:19:31,550
走向名称的统一

2114
01:19:31,550 --> 01:19:33,920
和基于地址的通信。

2115
01:19:33,920 --> 01:19:36,675
工作背后的动机是

2116
01:19:36,675 --> 01:19:38,630
NFD已经推出多年了。

2117
01:19:38,630 --> 01:19:40,100
有一个成熟的代码库

2118
01:19:40,100 --> 01:19:41,300
现在可用的是

2119
01:19:41,300 --> 01:19:42,575
现在可用的是任何人都可以使用的

2120
01:19:42,575 --> 01:19:44,000
很多功能和一个

2121
01:19:44,000 --> 01:19:45,800
很多功能和那是与层相结合的。

2122
01:19:45,800 --> 01:19:47,660
然而，这个行业还没有完全

2123
01:19:47,660 --> 01:19:50,270
采纳了NFD，这是由于几十年来的

2124
01:19:50,270 --> 01:19:52,815
既得利益者对TCP/IP网络的兴趣

2125
01:19:52,815 --> 01:19:54,945
他们已经完成了

2126
01:19:54,945 --> 01:19:56,150
发展与过渡

2127
01:19:56,150 --> 01:19:57,965
成本会很高。

2128
01:19:57,965 --> 01:20:00,200
我们认为NFD需要的是

2129
01:20:00,200 --> 01:20:01,780
我们认为NFD需要的是一个成功故事，其中基于地址的 [inaudible] pretty much knocked it out of the park;

2130
01:20:01,780 --> 01:20:05,390
~!@#$%^&*()

2131
01:20:05,390 --> 01:20:06,950
没有竞争或机会。

2132
01:20:06,950 --> 01:20:09,495
要想基于地址的栈有任何竞争力。

2133
01:20:09,495 --> 01:20:11,135
为了做到这一点，

2134
01:20:11,135 --> 01:20:14,210
我们考察了基于名称的方法在哪些领域可以表现出色。

2135
01:20:14,210 --> 01:20:16,145
我们考察了基于名称的方法在哪些领域可以表现出色。其中一个领域是

2136
01:20:16,145 --> 01:20:18,230
在工业领域开始形成，但是

2137
01:20:18,230 --> 01:20:20,130
尚未完全发展

2138
01:20:20,130 --> 01:20:22,415
基本上是去中心化的野生边缘。

2139
01:20:22,415 --> 01:20:23,720
很多其他的演讲者

2140
01:20:23,720 --> 01:20:26,225
在我之前也有很多其他的演讲者涉及过这个话题。

2141
01:20:26,225 --> 01:20:28,490
这些原因是标准程序。

2142
01:20:28,490 --> 01:20:30,020
仍然处于形成过程中。

2143
01:20:30,020 --> 01:20:31,755
还没有一个众所周知的

2144
01:20:31,755 --> 01:20:33,740
尚未经过测试的操作程序或方法

2145
01:20:33,740 --> 01:20:36,290
不太知名的基于地址的库，可以让人们直接去

2146
01:20:36,290 --> 01:20:37,650
直接去

2147
01:20:37,650 --> 01:20:39,335
并且这解决了他们的问题，

2148
01:20:39,335 --> 01:20:41,030
文章，或者是Salesforce。

2149
01:20:41,030 --> 01:20:42,675
基于边缘命名的

2150
01:20:42,675 --> 01:20:44,265
多播传播也是

2151
01:20:44,265 --> 01:20:45,769
需要一对多通信

2152
01:20:45,769 --> 01:20:47,480
边缘上存在一个问题。

2153
01:20:47,480 --> 01:20:49,670
边缘上存在一个问题。基于地址的通信还没有真正提供一个解决方案。

2154
01:20:49,670 --> 01:20:51,195
真正提供了一个解决方案给

2155
01:20:51,195 --> 01:20:52,490
仅仅由于其本质特性

2156
01:20:52,490 --> 01:20:55,650
地址式通信的局限性。

2157
01:20:55,930 --> 01:20:57,980
本质上，我们有

2158
01:20:57,980 --> 01:20:59,750
基于地址的通信在哪里

2159
01:20:59,750 --> 01:21:01,190
行业是这样的，我们拥有

2160
01:21:01,190 --> 01:21:02,900
基于名称的沟通，

2161
01:21:02,900 --> 01:21:03,950
这本质上是

2162
01:21:03,950 --> 01:21:05,450
我们的目标是过渡到~!@#$%^&*()

2163
01:21:05,450 --> 01:21:08,755
我们需要的本质上是一座桥梁。

2164
01:21:08,755 --> 01:21:11,265
我们如何才能将产业带到那里。

2165
01:21:11,265 --> 01:21:13,570
我早些时候听说那里~!@#$%^&*()

2166
01:21:13,570 --> 01:21:15,500
之前有一场对话、辩论，

2167
01:21:15,500 --> 01:21:18,300
多个图书馆之间的讨论

2168
01:21:18,300 --> 01:21:19,950
或者支持一个大型图书馆在

2169
01:21:19,950 --> 01:21:23,810
支持一个小型的TCP/IP库

2170
01:21:23,810 --> 01:21:25,730
正在调整基于名称的服务。

2171
01:21:25,730 --> 01:21:28,010
这个想法是为了介绍

2172
01:21:28,010 --> 01:21:31,095
业界人士普遍使用的

2173
01:21:31,095 --> 01:21:33,260
TCP/IP协议栈和基于地址的通信

2174
01:21:33,260 --> 01:21:35,675
的优势

2175
01:21:35,675 --> 01:21:37,515
基于名称的通信而无需

2176
01:21:37,515 --> 01:21:39,260
转换一切，以便它

2177
01:21:39,260 --> 01:21:41,225
变得更加出色

2178
01:21:41,225 --> 01:21:43,185
优于

2179
01:21:43,185 --> 01:21:45,690
基于地址的通信很容易。

2180
01:21:45,690 --> 01:21:47,740
一个简单的API将会是

2181
01:21:47,740 --> 01:21:50,030
数据在边缘的多点传播。

2182
01:21:50,030 --> 01:21:51,830
the edge is a critical aspect, especially when it involves wireless communication.

2183
01:21:51,830 --> 01:21:54,195
边缘尤其是在它是无线的时候，

2184
01:21:54,195 --> 01:21:56,315
边缘通信，边缘对边缘，

2185
01:21:56,315 --> 01:21:58,760
没有好的系统侧广播

2186
01:21:58,760 --> 01:22:00,080
它不可靠。

2187
01:22:00,080 --> 01:22:03,195
但如果有一个类似于样本的API，

2188
01:22:03,195 --> 01:22:04,610
它只需要取得文件

2189
01:22:04,610 --> 01:22:05,645
并当然处理好把手，

2190
01:22:05,645 --> 01:22:08,420
所有的组装和分解工作，

2191
01:22:08,420 --> 01:22:10,670
开发者们愿意尝试

2192
01:22:10,670 --> 01:22:12,160
开发者们愿意尝试，至少看一下它的运行情况和

2193
01:22:12,160 --> 01:22:13,850
它的工作原理以及不需要更改所有其他

2194
01:22:13,850 --> 01:22:14,960
更改所有那些其他

2195
01:22:14,960 --> 01:22:16,625
沟通和过渡。

2196
01:22:16,625 --> 01:22:18,110
我想要讲的另一件事是，

2197
01:22:18,110 --> 01:22:20,390
而不是看基于名称的堆栈，

2198
01:22:20,390 --> 01:22:21,740
我想考虑看看

2199
01:22:21,740 --> 01:22:23,030
在一个统一的范式中。

2200
01:22:23,030 --> 01:22:24,854
我所说的统一范式

2201
01:22:24,854 --> 01:22:29,045
是基于地址和基于名称相结合的。

2202
01:22:29,045 --> 01:22:31,280
我们开始探索的原因

2203
01:22:31,280 --> 01:22:32,750
采用统一范式而不是

2204
01:22:32,750 --> 01:22:34,760
基于名称的访问控制是因为

2205
01:22:34,760 --> 01:22:35,420
在边缘是

2206
01:22:35,420 --> 01:22:36,980
发射器基本上是启动者。

2207
01:22:36,980 --> 01:22:38,760
所以你需要和某人交流；

2208
01:22:38,760 --> 01:22:40,365
你发送一个身份证明和

2209
01:22:40,365 --> 01:22:42,445
你向访问控制发送数据。

2210
01:22:42,445 --> 01:22:44,240
有其他使用案例我们非常熟悉，

2211
01:22:44,240 --> 01:22:45,635
我们非常熟悉的，

2212
01:22:45,635 --> 01:22:47,150
我们非常熟悉的，是应用程序正在多播数据驱动。

2213
01:22:47,150 --> 01:22:48,440
正在多播数据驱动。

2214
01:22:48,440 --> 01:22:49,695
接收方发起并且

2215
01:22:49,695 --> 01:22:50,510
那就是基于名称的地方，

2216
01:22:50,510 --> 01:22:53,135
你订阅数据，然后你就会收到数据。

2217
01:22:53,135 --> 01:22:55,670
现在这两个中，一个是发射器

2218
01:22:55,670 --> 01:22:56,720
发起的，另一个是

2219
01:22:56,720 --> 01:22:58,085
是接收方发起的，

2220
01:22:58,085 --> 01:22:59,420
一个是基于地址的，另一个

2221
01:22:59,420 --> 01:23:01,400
是几乎完全基于数据驱动的。

2222
01:23:01,400 --> 01:23:03,770
我们开始研究MAC层，

2223
01:23:03,770 --> 01:23:05,450
这是纯粹的MAC层

2224
01:23:05,450 --> 01:23:06,980
介质访问控制，我们开始

2225
01:23:06,980 --> 01:23:08,740
统一范式介质访问控制层

2226
01:23:08,740 --> 01:23:10,875
并研究了现有的算法

2227
01:23:10,875 --> 01:23:12,195
该MAC层需要

2228
01:23:12,195 --> 01:23:14,060
需要基本上运行和执行。

2229
01:23:14,060 --> 01:23:16,590
速率控制算法和可靠性，

2230
01:23:16,590 --> 01:23:18,170
波束成形，帧聚合，

2231
01:23:18,170 --> 01:23:19,265
还有很多其他的内容。

2232
01:23:19,265 --> 01:23:20,750
但我们开始专注

2233
01:23:20,750 --> 01:23:21,950
在这些基础上，我们开始构建

2234
01:23:21,950 --> 01:23:24,350
一个名为算法适应的小层

2235
01:23:24,350 --> 01:23:25,875
层，并且我们连接了

2236
01:23:25,875 --> 01:23:27,785
我们也连接了所有这些算法。

2237
01:23:27,785 --> 01:23:29,300
我们开始提问，我们能否

2238
01:23:29,300 --> 01:23:30,380
应用相同的算法

2239
01:23:30,380 --> 01:23:32,630
使用较小的自适应层，因此

2240
01:23:32,630 --> 01:23:35,045
我们可以部署相同的算法

2241
01:23:35,045 --> 01:23:37,485
在基于名称和基于地址的情况下？

2242
01:23:37,485 --> 01:23:39,030
我们实际上能够

2243
01:23:39,030 --> 01:23:41,090
我们实际上能够现在就演示一点。

2244
01:23:41,090 --> 01:23:43,040
我们拿出了一个例子，这个例子是

2245
01:23:43,040 --> 01:23:45,320
速率控制算法，我们将会讨论我们如何能够部署

2246
01:23:45,320 --> 01:23:46,490
讨论我们如何能够部署

2247
01:23:46,490 --> 01:23:48,350
该算法与同一算法的

2248
01:23:48,350 --> 01:23:50,325
该算法与同一算法的细微调整从基于地址的通信转变为基于名称的通信。

2249
01:23:50,325 --> 01:23:51,555
将基于地址的通信转变为基于名称的通信，

2250
01:23:51,555 --> 01:23:52,820
为什么这很重要。

2251
01:23:52,820 --> 01:23:56,690
我们讲解什么是速率控制。

2252
01:23:56,690 --> 01:23:58,220
想象你有两台收音机，

2253
01:23:58,220 --> 01:23:59,960
Node A与Node B以及

2254
01:23:59,960 --> 01:24:01,160
Node A正在尝试向

2255
01:24:01,160 --> 01:24:04,885
Node B在Wi-Fi或8211中。

2256
01:24:04,885 --> 01:24:06,590
应该以什么数据速率进行传输？

2257
01:24:06,590 --> 01:24:07,070
有很多

2258
01:24:07,070 --> 01:24:08,445
您可以传输的数据速率

2259
01:24:08,445 --> 01:24:10,670
该选择

2260
01:24:10,670 --> 01:24:12,170
通常是基于一张表格。

2261
01:24:12,170 --> 01:24:13,520
你改变了调制方式，

2262
01:24:13,520 --> 01:24:14,570
你改变了码率，

2263
01:24:14,570 --> 01:24:16,515
空间流，错误编码，

2264
01:24:16,515 --> 01:24:18,815
然后你会得到不同的数据传输速率。

2265
01:24:18,815 --> 01:24:20,510
通常那种改变是

2266
01:24:20,510 --> 01:24:21,950
完成了条件验证。

2267
01:24:21,950 --> 01:24:23,210
所以你有一个数据包，你发送了

2268
01:24:23,210 --> 01:24:24,650
片段及其多个帧，

2269
01:24:24,650 --> 01:24:26,300
然后你根据情况进行相应的改变，

2270
01:24:26,300 --> 01:24:27,110
在中等条件下，

2271
01:24:27,110 --> 01:24:28,130
所以你会动态变化。

2272
01:24:28,130 --> 01:24:29,655
有时候状态非常好，

2273
01:24:29,655 --> 01:24:32,330
你的传输速率是600 Mbps，然后它下降了。

2274
01:24:32,330 --> 01:24:33,800
降到了15 Mbps。

2275
01:24:33,800 --> 01:24:36,170
连接不再那么好了。

2276
01:24:36,170 --> 01:24:38,870
它的工作原理基本上是这样的

2277
01:24:38,870 --> 01:24:41,715
A开始传输到B之前的节点B，

2278
01:24:41,715 --> 01:24:43,830
它基本上会共享支持的速率，

2279
01:24:43,830 --> 01:24:49,230
B会说我可以接收一些数据速率。

2280
01:24:49,230 --> 01:24:51,410
假设在这个表格中我们有1, 6,

2281
01:24:51,410 --> 01:24:53,665
9, 24, 54 Mbps.

2282
01:24:53,665 --> 01:24:55,415
现在，它将开始传输。

2283
01:24:55,415 --> 01:24:57,855
它将要做的是

2284
01:24:57,855 --> 01:24:59,030
它将要搜索尽可能多的

2285
01:24:59,030 --> 01:25:00,530
首帧以某种数据速率。

2286
01:25:00,530 --> 01:25:01,640
如果它得到了确认，

2287
01:25:01,640 --> 01:25:03,620
这意味着它通过接收到了

2288
01:25:03,620 --> 01:25:08,010
更高的数据速率用于较低的数据速率。

2289
01:25:08,010 --> 01:25:09,620
当场景逐步展开时，

2290
01:25:09,620 --> 01:25:11,235
它以每秒9兆比特的速度发送。

2291
01:25:11,235 --> 01:25:12,650
它通过，它前往~!@#$%^&*()

2292
01:25:12,650 --> 01:25:15,240
一个更高的，大约是24 Mbps。

2293
01:25:15,240 --> 01:25:16,605
如果它丢失了数据，

2294
01:25:16,605 --> 01:25:17,960
它会尝试重新传输

2295
01:25:17,960 --> 01:25:20,535
它会以较低的数据速率重新传输相同的帧。

2296
01:25:20,535 --> 01:25:21,680
如果它通过了，

2297
01:25:21,680 --> 01:25:23,475
它继续前进，然后向上走。

2298
01:25:23,475 --> 01:25:25,370
这是一个简单的算法。

2299
01:25:25,370 --> 01:25:26,655
这本质上是上升还是~!@#$%^&*()

2300
01:25:26,655 --> 01:25:28,670
下来，这确实是相当使用的。

2301
01:25:28,670 --> 01:25:31,890
单播和基于地址的通信。

2302
01:25:32,680 --> 01:25:37,025
现在，基于名称的速率控制又是怎样的呢？

2303
01:25:37,025 --> 01:25:38,450
我们没有任何身份证明，所以我们~!@#$%^&*()

2304
01:25:38,450 --> 01:25:39,770
我们不知道谁是A谁是B。

2305
01:25:39,770 --> 01:25:42,050
我们不知道我们在发送给谁。

2306
01:25:42,050 --> 01:25:44,505
我们不知道接收者是谁。

2307
01:25:44,505 --> 01:25:45,845
我们不知道是不是只有一个接收者。

2308
01:25:45,845 --> 01:25:47,930
或者有多个接收者。

2309
01:25:47,930 --> 01:25:51,170
我们技术上可以恢复费率控制。

2310
01:25:51,170 --> 01:25:52,605
每次我们获得新的兴趣，

2311
01:25:52,605 --> 01:25:55,400
我们可以重新启动速率控制并且

2312
01:25:55,400 --> 01:25:56,825
假设它是新号码

2313
01:25:56,825 --> 01:25:58,890
接收者或一组接收者，

2314
01:25:58,890 --> 01:26:00,200
开始尝试去

2315
01:26:00,200 --> 01:26:01,250
寻找最优的数据传输速率。

2316
01:26:01,250 --> 01:26:02,600
问题是数据 ~!@#$%^&*()

2317
01:26:02,600 --> 01:26:04,625
数据包非常小。

2318
01:26:04,625 --> 01:26:07,085
到最终的最佳数据传输速率时，

2319
01:26:07,085 --> 01:26:08,420
我们将不得不再次重新启动。

2320
01:26:08,420 --> 01:26:10,910
因为数据包已经结束了。

2321
01:26:11,080 --> 01:26:13,700
我们最终做的是

2322
01:26:13,700 --> 01:26:15,349
嵌入一个ID信息

2323
01:26:15,349 --> 01:26:16,520
根据兴趣允许阅读

2324
01:26:16,520 --> 01:26:18,765
我们不使用它来进行过滤控制。

2325
01:26:18,765 --> 01:26:20,300
它仍然是基于名称的通信。

2326
01:26:20,300 --> 01:26:21,350
我们仅仅使用ID

2327
01:26:21,350 --> 01:26:23,355
内部地

2328
01:26:23,355 --> 01:26:25,215
实际上要识别我们要派遣的人。

2329
01:26:25,215 --> 01:26:26,360
实际上要识别

2330
01:26:26,360 --> 01:26:28,325
一般中心信息。

2331
01:26:28,325 --> 01:26:30,500
这使我们能够

2332
01:26:30,500 --> 01:26:32,025
现在我们可以识别每个节点

2333
01:26:32,025 --> 01:26:34,100
在内部，我们实际上能够

2334
01:26:34,100 --> 01:26:36,195
使用基于地址的

2335
01:26:36,195 --> 01:26:37,280
读取控制算法

2336
01:26:37,280 --> 01:26:38,330
已经

2337
01:26:38,330 --> 01:26:41,060
设计并以黑盒方式进行测试。

2338
01:26:41,060 --> 01:26:43,280
使用我们获得的ID来进行

2339
01:26:43,280 --> 01:26:45,170
使用我们获得的ID来进行数据包，支持的速率，

2340
01:26:45,170 --> 01:26:48,230
和历史记录并获得一个数据速率来进行控制

2341
01:26:48,230 --> 01:26:52,265
基于名称的通信的数据速率。

2342
01:26:52,265 --> 01:26:55,730
这样我们就可以发送基于名称的帧

2343
01:26:55,730 --> 01:26:58,160
具有已经开发出的速率控制功能，

2344
01:26:58,160 --> 01:27:00,680
开发用于基于地址的通信。

2345
01:27:00,680 --> 01:27:02,845
我们从这些结果中获得了什么

2346
01:27:02,845 --> 01:27:04,735
如果我们仅仅使用广播

2347
01:27:04,735 --> 01:27:05,330
我们使用在哪里

2348
01:27:05,330 --> 01:27:07,205
基于名称的通信而无需实际

2349
01:27:07,205 --> 01:27:08,630
识别我们正在发送的便条

2350
01:27:08,630 --> 01:27:10,280
并使用极大的控制力，

2351
01:27:10,280 --> 01:27:12,210
延迟30秒

2352
01:27:12,210 --> 01:27:13,990
通过统一堆栈传输，

2353
01:27:13,990 --> 01:27:16,110
我们将其减少到了0.9秒。

2354
01:27:16,110 --> 01:27:18,680
损失率为12-20%。

2355
01:27:18,680 --> 01:27:21,290
这只是广播，因为我们能够利用单播传输。

2356
01:27:21,290 --> 01:27:24,015
利用单播传输。

2357
01:27:24,015 --> 01:27:24,920
我们有一个消费者，

2358
01:27:24,920 --> 01:27:26,090
一个生产者传输，

2359
01:27:26,090 --> 01:27:27,780
我们能够降低损失率，

2360
01:27:27,780 --> 01:27:29,175
同时我们也能够让

2361
01:27:29,175 --> 01:27:31,350
我们也能够降低介质的利用率。

2362
01:27:31,350 --> 01:27:32,450
我们也能够降低介质的利用率，主要原因之一是在你进行广播传输时，~!@#$%^&*()

2363
01:27:32,450 --> 01:27:35,235
是当你在进行广播传输时，

2364
01:27:35,235 --> 01:27:36,680
你基本上是以基础速率进行传输

2365
01:27:36,680 --> 01:27:38,675
一兆比特每秒，六兆比特每秒。

2366
01:27:38,675 --> 01:27:40,550
但当你进行速率控制时，

2367
01:27:40,550 --> 01:27:41,990
这意味着以一个更高的速率，

2368
01:27:41,990 --> 01:27:46,280
65 Mbps，最高可达600 Mbps。

2369
01:27:46,840 --> 01:27:49,360
本质上，速率控制算法是

2370
01:27:49,360 --> 01:27:49,910
至关重要的

2371
01:27:49,910 --> 01:27:51,525
良好性能的无线通信，

2372
01:27:51,525 --> 01:27:54,980
我们需要长时间的、几乎无缝的通信

2373
01:27:54,980 --> 01:27:56,900
跨越多个数据帧。

2374
01:27:56,900 --> 01:27:58,580
它找到了最优的速率，但并没有

2375
01:27:58,580 --> 01:28:01,800
重新开始或者开销太大。

2376
01:28:01,800 --> 01:28:03,470
我们开始查看

2377
01:28:03,470 --> 01:28:05,530
现有的访问权限

2378
01:28:05,530 --> 01:28:08,450
在MAC层形成统一的协议栈。

2379
01:28:08,450 --> 01:28:09,680
我们拥有的是过滤功能。

2380
01:28:09,680 --> 01:28:11,490
我们可以进行基于姓名和地址的过滤。

2381
01:28:11,490 --> 01:28:12,650
我们可以进行发现，

2382
01:28:12,650 --> 01:28:13,905
它可以是基于属性的。

2383
01:28:13,905 --> 01:28:16,195
发现基于地址的通讯。

2384
01:28:16,195 --> 01:28:18,625
我们可以对单播进行读取控制，

2385
01:28:18,625 --> 01:28:20,870
我们还可以进行多播的健壮性协议设计。

2386
01:28:20,870 --> 01:28:21,605
robustness protocol design for multicasting.

2387
01:28:21,605 --> 01:28:23,480
单一消费者生产者选择。

2388
01:28:23,480 --> 01:28:24,400
帧聚合。

2389
01:28:24,400 --> 01:28:26,050
这是一个基于地址的通信方式，

2390
01:28:26,050 --> 01:28:27,250
这基本上就是你打包

2391
01:28:27,250 --> 01:28:28,450
将你的多个帧组合在一起以

2392
01:28:28,450 --> 01:28:29,895
将多个帧组合成一个MPDU，

2393
01:28:29,895 --> 01:28:30,440
而那就是在哪里

2394
01:28:30,440 --> 01:28:31,780
高速率数据传输是

2395
01:28:31,780 --> 01:28:33,950
绝对必要的。波束成形。

2396
01:28:33,950 --> 01:28:35,740
这就是当你有多个天线并且

2397
01:28:35,740 --> 01:28:38,030
你想要向一个特定方向发送。

2398
01:28:38,030 --> 01:28:40,030
需要做的事情还有

2399
01:28:40,030 --> 01:28:41,825
缺少的是多播速率控制，

2400
01:28:41,825 --> 01:28:44,695
缺少的是多播速率控制，我们提供了多消费者生产者选择。

2401
01:28:44,695 --> 01:28:48,080
简而言之，我们提供了

2402
01:28:48,080 --> 01:28:50,565
一种可能吸引行业专业人士的方式

2403
01:28:50,565 --> 01:28:52,155
行业专业人士的目标

2404
01:28:52,155 --> 01:28:54,590
边缘市场和特定的API来仅仅

2405
01:28:54,590 --> 01:28:56,810
提供基于名称的服务来代替

2406
01:28:56,810 --> 01:28:58,970
吸引人们使用整个技术栈，

2407
01:28:58,970 --> 01:29:01,080
并最终转向整个技术栈。

2408
01:29:01,080 --> 01:29:02,090
提案书

2409
01:29:02,090 --> 01:29:03,440
一个基于轻量级名称的服务及

2410
01:29:03,440 --> 01:29:04,790
面向低门槛进入的市场营销

2411
01:29:04,790 --> 01:29:06,140
和即时利益，

2412
01:29:06,140 --> 01:29:08,510
和一个统一的MAC，它有益于

2413
01:29:08,510 --> 01:29:11,010
名称和地址的通信方式。

2414
01:29:11,010 --> 01:29:12,740
谢谢。

2415
01:29:17,270 --> 01:29:22,035
谢谢。我有个问题，很快。

2416
01:29:22,035 --> 01:29:25,740
它是的，你评估了这个吗？

2417
01:29:25,740 --> 01:29:27,510
或多或少定性地，或者你

2418
01:29:27,510 --> 01:29:28,425
实际上最终尝试去

2419
01:29:28,425 --> 01:29:30,045
实际上最终尝试去原型化它的任何部分。>> We did actually prototype any piece of it.

2420
01:29:30,045 --> 01:29:32,340
我们确实制作了原型。

2421
01:29:32,340 --> 01:29:35,565
幻灯片丢失了延迟特性。

2422
01:29:35,565 --> 01:29:37,170
和中等利用率

2423
01:29:37,170 --> 01:29:38,010
实施的政策实际上是

2424
01:29:38,010 --> 01:29:39,330
从真实系统中获得。

2425
01:29:39,330 --> 01:29:40,680
我们在一个树莓派上构建了一个系统，它是一个初级丛林，

2426
01:29:40,680 --> 01:29:43,215
我们在一个树莓派上构建了一个系统，它是一个初级丛林，

2427
01:29:43,215 --> 01:29:45,765
并且你修改了固件和内核，

2428
01:29:45,765 --> 01:29:47,970
移除现有的地址空间栈

2429
01:29:47,970 --> 01:29:50,085
然后实际进行了实验。

2430
01:29:50,085 --> 01:29:53,415
那非常酷。好的，

2431
01:29:53,415 --> 01:29:55,485
听起来不错。非常感谢你。

2432
01:29:55,485 --> 01:29:57,220
>> 谢谢你。

2433
01:29:58,760 --> 01:30:02,235
>> 我们的最后一位演讲者。

2434
01:30:02,235 --> 01:30:08,775
这是一个概念验证（POC），接下来我相信会有一个演示。

2435
01:30:08,775 --> 01:30:13,350
这个概念验证是NEAR平台的支持

2436
01:30:13,350 --> 01:30:18,340
增强现实在NDN上的应用，作者：Jinghao Zhao。

2437
01:30:18,350 --> 01:30:23,070
他是加州大学洛杉矶分校的一名四年级博士研究生。

2438
01:30:23,070 --> 01:30:24,720
研究兴趣包括

2439
01:30:24,720 --> 01:30:25,950
移动边缘系统，

2440
01:30:25,950 --> 01:30:28,560
无线网络和移动安全。

2441
01:30:28,560 --> 01:30:31,050
向你看齐，我想你

2442
01:30:31,050 --> 01:30:33,555
进行一次演示；是这样吗？

2443
01:30:33,555 --> 01:30:35,340
>> 是的。

2444
01:30:35,340 --> 01:30:37,090
>> 好的。

2445
01:30:38,510 --> 01:30:40,980
>> 让我分享我的屏幕

2446
01:30:40,980 --> 01:30:48,210
[重叠的对话] 正在进行中。

2447
01:30:48,210 --> 01:30:51,660
>> 我认为你是[听不清]。

2448
01:30:51,660 --> 01:30:53,550
是的。各位，

2449
01:30:53,550 --> 01:30:55,470
很高兴介绍

2450
01:30:55,470 --> 01:30:59,280
我们的最新研究，我是来自加州大学洛杉矶分校的景浩。

2451
01:30:59,280 --> 01:31:01,050
今天我将要介绍

2452
01:31:01,050 --> 01:31:02,985
NEAR平台的NDN无线，

2453
01:31:02,985 --> 01:31:05,830
面向您的AR平台。

2454
01:31:06,020 --> 01:31:08,730
保持对~!@#$%^&*()的要求

2455
01:31:08,730 --> 01:31:12,000
高品质的AR内容和

2456
01:31:12,000 --> 01:31:13,680
移动边缘计算

2457
01:31:13,680 --> 01:31:14,730
实际上为我们提供了

2458
01:31:14,730 --> 01:31:16,080
为其提供了新的机会

2459
01:31:16,080 --> 01:31:18,450
利用简易加速器的，

2460
01:31:18,450 --> 01:31:19,950
存储，以及还有

2461
01:31:19,950 --> 01:31:21,990
更多的管理功能。

2462
01:31:21,990 --> 01:31:24,390
一月份的Edge AR系统，

2463
01:31:24,390 --> 01:31:26,250
您已经首先需要进入~!@#$%^&*()

2464
01:31:26,250 --> 01:31:28,245
支持病毒AR应用程序。

2465
01:31:28,245 --> 01:31:29,790
例如，是一种合并

2466
01:31:29,790 --> 01:31:31,050
喜欢远程培训

2467
01:31:31,050 --> 01:31:33,480
工业穿戴设备以及声音

2468
01:31:33,480 --> 01:31:36,825
边缘服务器辅助的AR增强。

2469
01:31:36,825 --> 01:31:39,000
边缘服务器还需要处理

2470
01:31:39,000 --> 01:31:41,580
这些移动设备产生的高动态性

2471
01:31:41,580 --> 01:31:43,260
像用户的移动性或

2472
01:31:43,260 --> 01:31:44,745
一些工作负载的移动性或

2473
01:31:44,745 --> 01:31:46,020
甚至是网络动态变化

2474
01:31:46,020 --> 01:31:47,730
和应用处理。

2475
01:31:47,730 --> 01:31:49,305
还有那个，

2476
01:31:49,305 --> 01:31:50,910
需要AR的，

2477
01:31:50,910 --> 01:31:51,930
边缘服务器具有

2478
01:31:51,930 --> 01:31:54,510
具有非常低的网络延迟，同时也

2479
01:31:54,510 --> 01:31:56,010
具有高带宽以支持

2480
01:31:56,010 --> 01:31:59,055
具有高带宽以支持当前AR系统所需的高质量AR内容。

2481
01:31:59,055 --> 01:32:02,280
为了适应当前的AR系统，

2482
01:32:02,280 --> 01:32:03,690
它更像是举个例子，

2483
01:32:03,690 --> 01:32:06,060
它涉及到交叉或信息幻灯片。

2484
01:32:06,060 --> 01:32:09,105
应用程序需要成本用于

2485
01:32:09,105 --> 01:32:12,720
处理以及用于网络系统的费用，

2486
01:32:12,720 --> 01:32:14,640
它也涉及交叉或喜欢~!@#$%^&*()

2487
01:32:14,640 --> 01:32:16,770
传输层以及更低层次，

2488
01:32:16,770 --> 01:32:19,020
物理层，甚至最大需求

2489
01:32:19,020 --> 01:32:20,369
~!@#$%^&*()

2490
01:32:20,369 --> 01:32:21,630
为了更好的优化。

2491
01:32:21,630 --> 01:32:23,295
然而，当前系统

2492
01:32:23,295 --> 01:32:25,965
这种多层次的间接性无法，

2493
01:32:25,965 --> 01:32:28,260
更像是分享信息的课程

2494
01:32:28,260 --> 01:32:31,440
这些内容传输到网络上，反之亦然。

2495
01:32:31,440 --> 01:32:35,010
当前的限制是

2496
01:32:35,010 --> 01:32:37,470
病毒应用程序和

2497
01:32:37,470 --> 01:32:39,810
还有开发者使用相同的ash，

2498
01:32:39,810 --> 01:32:41,115
你真的需要开发

2499
01:32:41,115 --> 01:32:42,720
你自己的安全方案

2500
01:32:42,720 --> 01:32:44,505
以及网络堆栈，

2501
01:32:44,505 --> 01:32:45,569
不同的处理方式

2502
01:32:45,569 --> 01:32:47,415
管理，甚至是一种安全保障。

2503
01:32:47,415 --> 01:32:48,840
她的管理方式很难掌控。

2504
01:32:48,840 --> 01:32:50,220
此外，我们还有许多配置可用于这个信息系统。

2505
01:32:50,220 --> 01:32:52,560
此外，我们还有许多配置可用于这个信息系统。

2506
01:32:52,560 --> 01:32:54,900
此外，我们还有许多配置可用于这个信息系统。对于容易出错的部分，最后一个问题是——

2507
01:32:54,900 --> 01:32:56,760
最后一个问题是——

2508
01:32:56,760 --> 01:32:58,290
目前实际上是这样的AR。

2509
01:32:58,290 --> 01:32:59,370
仍在使用这个单元。

2510
01:32:59,370 --> 01:33:01,665
成本基础交付作为底层。

2511
01:33:01,665 --> 01:33:03,420
这甚至是一项单独的成本

2512
01:33:03,420 --> 01:33:05,100
无线介质仍然是

2513
01:33:05,100 --> 01:33:06,750
执行这种单播和

2514
01:33:06,750 --> 01:33:08,880
无法扩展到多个用户。

2515
01:33:08,880 --> 01:33:10,560
尤其是对于这种狭窄的情况，

2516
01:33:10,560 --> 01:33:12,225
谁需要大量的连接？

2517
01:33:12,225 --> 01:33:14,100
例如，主题公园或者

2518
01:33:14,100 --> 01:33:16,770
毕业典礼在校园里举行得很隆重。

2519
01:33:16,770 --> 01:33:19,350
我们想要剥离AR平台。

2520
01:33:19,350 --> 01:33:20,820
支持以下功能。

2521
01:33:20,820 --> 01:33:21,960
我们首先想要

2522
01:33:21,960 --> 01:33:24,150
阐述以数据为中心的传输

2523
01:33:24,150 --> 01:33:26,460
具有内置的多播支持功能

2524
01:33:26,460 --> 01:33:27,990
为了确保可扩展性。

2525
01:33:27,990 --> 01:33:30,720
我们还希望集成优化。

2526
01:33:30,720 --> 01:33:32,280
为了不同的组件和

2527
01:33:32,280 --> 01:33:33,900
为了构建系统。

2528
01:33:33,900 --> 01:33:36,420
我们想要将其集成到你的无线中并且~!@#$%^&*()

2529
01:33:36,420 --> 01:33:39,105
这些应用程序的宽度非常交叉。

2530
01:33:39,105 --> 01:33:41,635
加速和安全性等。

2531
01:33:41,635 --> 01:33:43,100
我们还想提供

2532
01:33:43,100 --> 01:33:45,830
我们还想提供这个平台作为一个开放源代码平台，用于未来的发展以及为了

2533
01:33:45,830 --> 01:33:47,810
未来的发展以及也为了

2534
01:33:47,810 --> 01:33:49,100
性能比较

2535
01:33:49,100 --> 01:33:50,965
为将来的新设计。

2536
01:33:50,965 --> 01:33:54,840
这里我们介绍我们的集成工作努力。

2537
01:33:54,840 --> 01:33:56,850
作为NEAR平台，

2538
01:33:56,850 --> 01:33:59,680
NDN无线最终现实。

2539
01:33:59,680 --> 01:34:01,190
我们的平台包括

2540
01:34:01,190 --> 01:34:02,435
以下几个组成部分。

2541
01:34:02,435 --> 01:34:04,145
我们首先支持

2542
01:34:04,145 --> 01:34:06,020
不同的AR模块用于

2543
01:34:06,020 --> 01:34:07,865
不同的AR模块用于病毒AR应用程序。Also the network side that we apply,

2544
01:34:07,865 --> 01:34:09,740
我们应用的网络方面，

2545
01:34:09,740 --> 01:34:11,180
我们应用的网络方面，NDN无线和高性能链路层组播。

2546
01:34:11,180 --> 01:34:13,324
高性能链路层组播

2547
01:34:13,324 --> 01:34:15,245
作为基本的传输方案。

2548
01:34:15,245 --> 01:34:16,985
我们还集成了GPU/

2549
01:34:16,985 --> 01:34:18,800
基于FPGA的加速器

2550
01:34:18,800 --> 01:34:22,160
集成到我们的系统中，并加入所有的AR内容。

2551
01:34:22,160 --> 01:34:23,870
也是通信内容

2552
01:34:23,870 --> 01:34:26,290
使用基于名称的安全性。

2553
01:34:26,290 --> 01:34:28,410
这是概述

2554
01:34:28,410 --> 01:34:30,435
我们的基本系统结构。

2555
01:34:30,435 --> 01:34:32,220
包含近平台的

2556
01:34:32,220 --> 01:34:33,434
包含以下组件。

2557
01:34:33,434 --> 01:34:35,820
生产者方面首先是，

2558
01:34:35,820 --> 01:34:37,800
我们有制作人来发布

2559
01:34:37,800 --> 01:34:39,450
所有实时摄像头视图

2560
01:34:39,450 --> 01:34:41,355
从其移动摄像头。

2561
01:34:41,355 --> 01:34:43,470
所有信息都是

2562
01:34:43,470 --> 01:34:44,730
相机帧将

2563
01:34:44,730 --> 01:34:45,930
将被检索

2564
01:34:45,930 --> 01:34:48,030
边缘服务器和边缘服务器性能，

2565
01:34:48,030 --> 01:34:49,530
增强现实模块处理

2566
01:34:49,530 --> 01:34:51,150
以及处理不同的任务。

2567
01:34:51,150 --> 01:34:52,620
以及利用

2568
01:34:52,620 --> 01:34:56,430
这些加速是通过GPU/FPGA实现的。

2569
01:34:56,430 --> 01:34:58,260
在AR内容处理之后

2570
01:34:58,260 --> 01:35:00,435
将会被发布给所有的消费者。

2571
01:35:00,435 --> 01:35:02,340
作为消费者，我们正在分享

2572
01:35:02,340 --> 01:35:04,500
相同的内容将会利用

2573
01:35:04,500 --> 01:35:06,420
此链路层多播要么访问

2574
01:35:06,420 --> 01:35:09,839
获取这些信息的要点

2575
01:35:09,839 --> 01:35:12,600
以及所有内容也受到保护

2576
01:35:12,600 --> 01:35:16,425
集成了NDN的安全性。

2577
01:35:16,425 --> 01:35:18,975
首先是这些广告，

2578
01:35:18,975 --> 01:35:20,790
我们介绍了喜欢

2579
01:35:20,790 --> 01:35:22,650
我们介绍了不同的整体模块，and later I will introduce more details

2580
01:35:22,650 --> 01:35:24,270
稍后我会介绍更多细节

2581
01:35:24,270 --> 01:35:26,280
至于我们的NEAR设计。

2582
01:35:26,280 --> 01:35:28,305
首先，就AR模块而言，

2583
01:35:28,305 --> 01:35:30,300
稍后我们将展示一个演示视频来展示

2584
01:35:30,300 --> 01:35:32,790
how it is used in different industries.

2585
01:35:32,790 --> 01:35:34,860
该AR平台利用

2586
01:35:34,860 --> 01:35:37,590
该NDN用于处理和组织。

2587
01:35:37,590 --> 01:35:39,690
通常，我们支持以下模块，

2588
01:35:39,690 --> 01:35:41,460
包括物体阶段

2589
01:35:41,460 --> 01:35:42,870
以及物体检测之后的阶段。

2590
01:35:42,870 --> 01:35:44,280
以及我们支持的是

2591
01:35:44,280 --> 01:35:46,980
3D模型渲染和AR视频叠加到

2592
01:35:46,980 --> 01:35:48,945
这更像是聚会，这样就缩小了

2593
01:35:48,945 --> 01:35:51,090
对于商业产品，

2594
01:35:51,090 --> 01:35:53,430
这些规划也用于广告宣传。

2596
01:35:55,740 --> 01:35:57,705
和多个消费者方案，

2597
01:35:57,705 --> 01:35:59,310
喜欢使用这种透明视图。

2598
01:35:59,310 --> 01:36:00,630
例如，在这里

2599
01:36:00,630 --> 01:36:04,020
这种纯粹的视角功能，

2600
01:36:04,020 --> 01:36:06,780
两位制片人是

2601
01:36:06,780 --> 01:36:08,160
制作这个摄像机视角

2602
01:36:08,160 --> 01:36:09,135
从它自己的一侧，

2603
01:36:09,135 --> 01:36:11,310
但它更像是在一个相似的位置。

2604
01:36:11,310 --> 01:36:14,100
它里面有一些剪切视图。

2605
01:36:14,100 --> 01:36:15,810
边缘服务器将会检索

2606
01:36:15,810 --> 01:36:18,060
将帧从发布流中检索出来并且

2607
01:36:18,060 --> 01:36:19,380
将它们组合在一起并且

2608
01:36:19,380 --> 01:36:20,850
发霉导致溪流变得

2609
01:36:20,850 --> 01:36:22,260
所有消费者更多地

2610
01:36:22,260 --> 01:36:24,750
喜欢提供这种全景视角。

2611
01:36:24,750 --> 01:36:26,940
我们也支持色键视频。

2612
01:36:26,940 --> 01:36:28,980
为了交互式歌剧，以便

2613
01:36:28,980 --> 01:36:31,260
消费者可以更像是在观看

2614
01:36:31,260 --> 01:36:32,280
~!@#$%^&*()

2615
01:36:32,280 --> 01:36:33,840
舞台作为他们的背景，

2616
01:36:33,840 --> 01:36:36,150
我们稍后将展示演示。

2617
01:36:36,150 --> 01:36:39,735
为了所有这些增强现实内容

2618
01:36:39,735 --> 01:36:41,835
为了确保高质量的表演者

2619
01:36:41,835 --> 01:36:43,260
和传统方式

2620
01:36:43,260 --> 01:36:44,790
~!@#$%^&*()

2621
01:36:44,790 --> 01:36:48,180
每个内容的传输速率可高达40 Mbps。

2622
01:36:48,180 --> 01:36:50,775
最近像体积视频这样的内容，

2623
01:36:50,775 --> 01:36:53,025
这些直接在3D模型中进行流式传输。

2624
01:36:53,025 --> 01:36:55,695
从边缘到消费者端。

2625
01:36:55,695 --> 01:36:58,020
满足每个客户的需求，

2626
01:36:58,020 --> 01:36:59,700
满足每个客户的需求，即使需要100 Mbps to ensure as 30 FPS playout.

2627
01:36:59,700 --> 01:37:02,535
Mbps以确保每秒30帧的播放。

2628
01:37:02,535 --> 01:37:04,905
当前接入点的电力需求是为了支持具有双流MIMO技术的智能手机。

2629
01:37:04,905 --> 01:37:07,500
它只能支持具有二乘二MIMO技术的智能手机。

2630
01:37:07,500 --> 01:37:09,930
它只能支持非常

2631
01:37:09,930 --> 01:37:12,435
它只能支持非常有限的客户数量。

2632
01:37:12,435 --> 01:37:13,305
例如，

2633
01:37:13,305 --> 01:37:15,330
对于最高物理层速率

2634
01:37:15,330 --> 01:37:16,470
对于802.11n，

2635
01:37:16,470 --> 01:37:17,700
它只能支持

2636
01:37:17,700 --> 01:37:21,645
它只能支持最多三个用户享受这种Phy速率AR。Even for the latest ax

2637
01:37:21,645 --> 01:37:23,370
即使是最新的ax标准，

2638
01:37:23,370 --> 01:37:25,365
它只能支持12个用户。

2639
01:37:25,365 --> 01:37:27,315
由于协议开销，

2640
01:37:27,315 --> 01:37:28,650
这里我们只是计算

2641
01:37:28,650 --> 01:37:30,330
可以是最大的数字

2642
01:37:30,330 --> 01:37:32,415
得分是使用这些物理速率。

2643
01:37:32,415 --> 01:37:35,190
协议中被监听到的部分加上噪音

2644
01:37:35,190 --> 01:37:38,130
也无法实现

2645
01:37:38,130 --> 01:37:41,295
持续运行时的最高费率

2646
01:37:41,295 --> 01:37:45,285
这个增强现实功能得益于移动性和

2647
01:37:45,285 --> 01:37:48,705
我们需要的数字将会进一步减少。

2648
01:37:48,705 --> 01:37:50,760
我们为什么要问重要的问题是怎样我们

2649
01:37:50,760 --> 01:37:52,785
可以扩展我们的AR支持，

2650
01:37:52,785 --> 01:37:54,165
选择模块和

2651
01:37:54,165 --> 01:37:55,845
即使是庞大的连接，

2652
01:37:55,845 --> 01:37:58,830
承诺所有的消费者。

2653
01:37:58,830 --> 01:38:00,630
诉求这个NEAR，

2654
01:38:00,630 --> 01:38:02,400
杠杆作用是NDN无线。

2655
01:38:02,400 --> 01:38:04,560
我们希望自然地利用NDN的优势

2656
01:38:04,560 --> 01:38:06,720
支持多播功能

2657
01:38:06,720 --> 01:38:09,090
以及结合

2658
01:38:09,090 --> 01:38:11,205
这种低层无线技术。

2659
01:38:11,205 --> 01:38:12,900
当前无线电力，

2660
01:38:12,900 --> 01:38:14,220
链路层仍然执行

2661
01:38:14,220 --> 01:38:16,995
多播单播。

2662
01:38:16,995 --> 01:38:19,800
设备中心的传输更倾向于

2663
01:38:19,800 --> 01:38:22,335
比内容中心更倾向于。

2664
01:38:22,335 --> 01:38:25,110
我们执行整合

2665
01:38:25,110 --> 01:38:26,640
我们执行整合高性能的link-layer multicast into

2666
01:38:26,640 --> 01:38:28,050
我们执行整合高性能的链路层组播到

2667
01:38:28,050 --> 01:38:29,490
数据平面的近端平台。

2668
01:38:29,490 --> 01:38:31,290
详述此状态下的数据计划。

2669
01:38:31,290 --> 01:38:34,050
NDN通过更加自动化的方式进行分组

2670
01:38:34,050 --> 01:38:35,910
具有相同兴趣的用户。

2671
01:38:35,910 --> 01:38:37,665
同样执行了这一高效率的链路层组播。

2672
01:38:37,665 --> 01:38:39,465
实现了高效率的链路层组播。

2673
01:38:39,465 --> 01:38:41,865
物理层可以达到高达

2674
01:38:41,865 --> 01:38:46,365
物理层可以达到高达450 Mbps，而尿液实验表明。

2675
01:38:46,365 --> 01:38:48,120
应用层的峰值速度可以达到

2676
01:38:48,120 --> 01:38:51,970
应用层的峰值速度可以达到大于120 Mbps。此外，比无线，

2677
01:38:52,300 --> 01:38:55,035
我们还集成了加速模块

2678
01:38:55,035 --> 01:38:58,170
我们还集成了加速模块

2679
01:38:58,170 --> 01:38:59,855
集成到我们的NEAR平台中。

2680
01:38:59,855 --> 01:39:02,110
我们可以支持GPU和FPGA作为加速器。

2681
01:39:02,110 --> 01:39:04,635
我们可以支持GPU和FPGA作为加速器。

2682
01:39:04,635 --> 01:39:08,815
所有模块都得到支持，例如，

2683
01:39:08,815 --> 01:39:10,495
当你想要利用

2684
01:39:10,495 --> 01:39:13,350
当你想要利用FPGA作为加速器，所有的帧，

2685
01:39:13,350 --> 01:39:15,420
销售和计算将会是

2686
01:39:15,420 --> 01:39:18,075
通过基于FPGA的加速器上传。

2687
01:39:18,075 --> 01:39:20,110
然后在处理和标注之后，

2688
01:39:20,110 --> 01:39:21,950
所有内容将由发布

2689
01:39:21,950 --> 01:39:24,580
所有内容将由发布者通过Edge传达给所有消费者。

2690
01:39:24,580 --> 01:39:26,990
我们还将安全性集成到了

2691
01:39:26,990 --> 01:39:29,210
我们还将安全性集成到了遵循NDN规范的NEAR之中，包括了消费者认证。

2692
01:39:29,210 --> 01:39:32,230
我们还将安全性集成到了遵循NDN规范的NEAR之中，包括了消费者认证，以及完整性和

2693
01:39:32,230 --> 01:39:33,830
完整性和

2694
01:39:33,830 --> 01:39:35,715
加密了AR内容，

2695
01:39:35,715 --> 01:39:38,180
并且我们还包括了访问权限

2696
01:39:38,180 --> 01:39:41,165
控制与消费者证书相关的权限，

2697
01:39:41,165 --> 01:39:43,390
基本上是在提供好处

2698
01:39:43,390 --> 01:39:44,690
的多播，

2699
01:39:44,690 --> 01:39:47,320
它通过大规模连接实现了扩展。

2700
01:39:47,320 --> 01:39:48,730
但是，直接应用

2701
01:39:48,730 --> 01:39:50,620
通过这个Edge AR的多播

2702
01:39:50,620 --> 01:39:53,690
无法拥有

2703
01:39:53,690 --> 01:39:56,805
我们之前所看到的预期表现。

2704
01:39:56,805 --> 01:39:59,220
我们需要解决以下问题

2705
01:39:59,220 --> 01:40:00,720
在我们的需求期间。

2706
01:40:00,720 --> 01:40:02,120
第一件事是我们如何

2707
01:40:02,120 --> 01:40:03,960
可以处理AR帧丢失。

2708
01:40:03,960 --> 01:40:06,405
第二，我们如何能够充分利用

2709
01:40:06,405 --> 01:40:08,265
多播，因为有时我们无法找到NFET。

2710
01:40:08,265 --> 01:40:09,905
有时我们找不到NFET。

2711
01:40:09,905 --> 01:40:11,200
有时我们找不到NFET，即使是当NFET有

2712
01:40:11,200 --> 01:40:13,010
有时我们找不到NFET，即使是当NFET有，但是它不能被利用于利息压缩的方案中。

2713
01:40:13,010 --> 01:40:14,685
然而，它不能被利用来

2714
01:40:14,685 --> 01:40:16,160
多个消费者

2715
01:40:16,160 --> 01:40:17,855
要求相同的数据。

2716
01:40:17,855 --> 01:40:21,440
最后一个问题是我们如何设计并且确保保护AR内容的安全。

2717
01:40:21,440 --> 01:40:23,700
保护和保障AR内容的安全

2718
01:40:23,700 --> 01:40:26,280
为了本组传输。

2719
01:40:26,280 --> 01:40:28,740
为了第一个问题，

2720
01:40:28,740 --> 01:40:30,980
首先在我们设计之前，

2721
01:40:30,980 --> 01:40:32,120
在我们设计之前，像视频流命名空间这样的传统

2722
01:40:32,120 --> 01:40:33,915
像视频流命名空间，

2723
01:40:33,915 --> 01:40:36,045
分割AR内容

2724
01:40:36,045 --> 01:40:37,795
带有I帧和P帧。

2725
01:40:37,795 --> 01:40:39,820
然而，我们发现在传输过程中，

2726
01:40:39,820 --> 01:40:41,020
the I-frame are already ~!@#$%^&*()

2727
01:40:41,020 --> 01:40:42,615
频繁丢失且无法

2728
01:40:42,615 --> 01:40:44,385
无法被消费者接收

2729
01:40:44,385 --> 01:40:46,880
并且它阻断了AR播放。

2730
01:40:48,030 --> 01:40:51,055
高数据包丢失率仅发生在

2731
01:40:51,055 --> 01:40:54,350
对于I帧和P帧来说一切正常。

2732
01:40:54,350 --> 01:40:56,960
在思考出原因之后，

2733
01:40:56,960 --> 01:40:58,180
在思考出原因之后，根本原因是

2734
01:40:58,180 --> 01:41:00,135
平均I帧大小是

2735
01:41:00,135 --> 01:41:02,115
比P帧的大小大得多，

2736
01:41:02,115 --> 01:41:03,975
而对于平均I帧的大小来说，

2737
01:41:03,975 --> 01:41:05,450
它将具有100步的速度，

2738
01:41:05,450 --> 01:41:06,795
对于P帧大小，

2739
01:41:06,795 --> 01:41:08,920
平均大小仅为10个步长，

2740
01:41:08,920 --> 01:41:11,480
并且考虑到最大帧仅能支持

2741
01:41:11,480 --> 01:41:14,045
每个数据帧，并且在

2742
01:41:14,045 --> 01:41:15,310
每个数据帧，并且在

2743
01:41:15,310 --> 01:41:17,755
有效载荷位点，以及对于每个I帧，

2744
01:41:17,755 --> 01:41:20,670
它需要传输68帧。

2745
01:41:20,670 --> 01:41:21,940
然而，对于P帧来说，

2746
01:41:21,940 --> 01:41:23,795
它只需要七帧。

2747
01:41:23,795 --> 01:41:25,505
多播拥有较低的层。

2748
01:41:25,505 --> 01:41:28,275
不确保这些具有

2749
01:41:28,275 --> 01:41:30,935
任何在低层的重传机制。

2750
01:41:30,935 --> 01:41:33,520
即使你部署了上层协议，

2751
01:41:33,520 --> 01:41:35,695
即使你部署了应用层重传机制，

2752
01:41:35,695 --> 01:41:38,245
我仍然会因此受苦。

2753
01:41:38,245 --> 01:41:40,045
即使只有一帧

2754
01:41:40,045 --> 01:41:42,095
从68帧中丢失，

2755
01:41:42,095 --> 01:41:43,450
从68帧中丢失的总I帧不能够成功重传，

2756
01:41:43,450 --> 01:41:45,255
无法成功重传，

2757
01:41:45,255 --> 01:41:47,085
即使我们进行了两次传输，

2758
01:41:47,085 --> 01:41:48,160
我们仍将遭受这种困扰。

2759
01:41:48,160 --> 01:41:50,135
下层数据包丢失。

2760
01:41:50,135 --> 01:41:52,515
它需要一个NEAR才能进行

2761
01:41:52,515 --> 01:41:54,345
这个新的命名空间设计

2762
01:41:54,345 --> 01:41:56,330
为了组织这些增强现实内容。

2763
01:41:56,330 --> 01:41:57,500
为了解决这些问题，

2764
01:41:57,500 --> 01:42:00,585
我们更多地从IP框架转移过来，就像

2765
01:42:00,585 --> 01:42:02,385
这可能是通过这种统一方式

2766
01:42:02,385 --> 01:42:04,060
最后一块命名。

2767
01:42:04,060 --> 01:42:05,450
我们刚刚分割了~!@#$%^&*()

2768
01:42:05,450 --> 01:42:06,875
我们刚刚分割了~!@#$%^&*(), 随着每一块，我们有这个块的AR内容。

2769
01:42:06,875 --> 01:42:08,265
随着每一块，我们有

2770
01:42:08,265 --> 01:42:10,600
随着每一块内容的统一长度，我们设计了

2771
01:42:10,600 --> 01:42:12,980
以下命名空间适用于生产者

2772
01:42:12,980 --> 01:42:15,700
同时还适用于生产者创建AR内容的边缘计算环境。

2773
01:42:15,700 --> 01:42:16,995
对于生产者来说，

2774
01:42:16,995 --> 01:42:19,735
每个生产者都将拥有一个独特的生产者ID。

2775
01:42:19,735 --> 01:42:22,480
同样适用于生产者。

2776
01:42:22,480 --> 01:42:24,400
位于相同的位置，

2777
01:42:24,400 --> 01:42:26,535
它们将具有相同的组ID。

2778
01:42:26,535 --> 01:42:29,075
它用于以后的AR功能。

2779
01:42:29,075 --> 01:42:30,820
在命名中，我们也包括

2780
01:42:30,820 --> 01:42:32,510
质量、块号，

2781
01:42:32,510 --> 01:42:33,830
和帧类型来

2782
01:42:33,830 --> 01:42:35,440
帮助应用程序执行

2783
01:42:35,440 --> 01:42:37,900
更像是自适应重传

2784
01:42:37,900 --> 01:42:39,285
基于帧类型。

2785
01:42:39,285 --> 01:42:41,450
对于AR内容，我们进一步添加了

2786
01:42:41,450 --> 01:42:44,200
我们将Edge ID和AR任务集成进去，

2787
01:42:44,200 --> 01:42:47,205
以便自动对消费者进行分组

2788
01:42:47,205 --> 01:42:48,950
通过这个增强现实任务

2789
01:42:48,950 --> 01:42:51,025
请求相同的配置，

2790
01:42:51,025 --> 01:42:52,335
以免不需要

2791
01:42:52,335 --> 01:42:55,155
任何额外的信息，比如信号。

2792
01:42:55,155 --> 01:42:57,675
利用命名信息在

2793
01:42:57,675 --> 01:43:00,370
NEAR可以从两个方面受益。

2794
01:43:00,370 --> 01:43:02,805
第一件事是命名空间

2795
01:43:02,805 --> 01:43:04,940
简化了管理的概念。

2796
01:43:04,940 --> 01:43:05,980
例如，我们不需要

2797
01:43:05,980 --> 01:43:07,740
不需要任何额外的信号。

2798
01:43:07,740 --> 01:43:09,200
我们更像是嵌入式

2799
01:43:09,200 --> 01:43:10,660
数据传输中的信号传递所以

2800
01:43:10,660 --> 01:43:14,535
所有的消费者

2801
01:43:14,535 --> 01:43:15,885
承担相同的任务

2802
01:43:15,885 --> 01:43:17,720
承担相同的配置可以

2803
01:43:17,720 --> 01:43:20,090
自动由网络分组并且

2804
01:43:20,090 --> 01:43:21,350
不需要应用程序来处理了。

2805
01:43:21,350 --> 01:43:23,100
不再需要处理它了。

2806
01:43:23,100 --> 01:43:25,180
第二种方式也是如此。

2807
01:43:25,180 --> 01:43:27,055
命名空间的设计可以

2808
01:43:27,055 --> 01:43:28,905
有利于不同的增强现实任务。

2809
01:43:28,905 --> 01:43:30,990
例如，在我们的Shareview功能中，

2810
01:43:30,990 --> 01:43:32,620
在这里我们涉及到两个制片人，

2811
01:43:32,620 --> 01:43:34,035
在演示中所示。

2812
01:43:34,035 --> 01:43:36,240
第一个生产者和第二个生产者将会

2813
01:43:36,240 --> 01:43:38,605
将会按照Edge自身的方式来检索它的视图。

2814
01:43:38,605 --> 01:43:40,730
我们这里有两个不同的视图

2815
01:43:40,730 --> 01:43:42,240
将它们组合在一起，仅需

2816
01:43:42,240 --> 01:43:43,895
将它们组合在一起，仅需

2817
01:43:43,895 --> 01:43:45,940
将同一组中的视图组合起来。

2818
01:43:45,940 --> 01:43:47,925
如果我们没有这些命名，

2819
01:43:47,925 --> 01:43:49,180
我们需要执行

2820
01:43:49,180 --> 01:43:51,380
我们需要执行这种非常昂贵的串行处理，它

2821
01:43:51,380 --> 01:43:54,255
无法支持实时AR体验。

2822
01:43:54,255 --> 01:43:56,560
无法支持实时AR体验。给这个AR分组信息在NEAR内部，

Unable to support real-time AR experience. Assign this AR to a group, information inside the NEAR,

2823
01:43:56,560 --> 01:43:58,245
信息在NEAR内部，

2824
01:43:58,245 --> 01:43:59,620
边缘服务器可以直接

2825
01:43:59,620 --> 01:44:00,975
应用聚合操作

2826
01:44:00,975 --> 01:44:02,270
和基于聚类的

2827
01:44:02,270 --> 01:44:03,770
关于命名信息。

2828
01:44:03,770 --> 01:44:06,295
然后在你对这些组帧进行聚类之后，

2829
01:44:06,295 --> 01:44:09,360
在这之后，你可以应用这个特征点提取，

2830
01:44:09,360 --> 01:44:10,965
和变换结合在一起

2831
01:44:10,965 --> 01:44:12,675
将这两种视角结合起来并发布

2832
01:44:12,675 --> 01:44:14,270
将这整个全景视角

2833
01:44:14,270 --> 01:44:16,940
发布给所有消费者。

2834
01:44:17,140 --> 01:44:19,580
第二个问题我们

2835
01:44:19,580 --> 01:44:21,675
面临的是我们发现

2836
01:44:21,675 --> 01:44:24,400
我们发现的是实际上利息压缩经常在真实实验中被忽略。

2837
01:44:24,400 --> 01:44:27,505
经常在真实实验中被忽略。

2838
01:44:27,505 --> 01:44:30,705
即使NFD在当...时也会压缩利益，

2839
01:44:30,705 --> 01:44:32,385
具有相同利益的需求

2840
01:44:32,385 --> 01:44:33,835
延伸至消费者。

2841
01:44:33,835 --> 01:44:35,530
然而，如果消费者

2842
01:44:35,530 --> 01:44:36,770
现在已经同步了并且

2843
01:44:36,770 --> 01:44:38,150
这个你已经经常

2844
01:44:38,150 --> 01:44:39,505
错过了，例如，

2845
01:44:39,505 --> 01:44:41,780
消费者A可能会请求最新的数据块，

2846
01:44:41,780 --> 01:44:44,950
消费者A可能会请求最新的数据块，将数据块1传输到边缘节点，边缘节点拥有

2847
01:44:44,950 --> 01:44:47,150
可以立即响应数据块1

2848
01:44:47,150 --> 01:44:48,920
响应数据块1。

2849
01:44:48,920 --> 01:44:50,435
然而，也许就在之后

2850
01:44:50,435 --> 01:44:51,850
即使是几毫秒，

2851
01:44:51,850 --> 01:44:53,780
消费者B发送了他的数据块

2852
01:44:53,780 --> 01:44:56,425
消费者B想要利益并请求数据块1，

2853
01:44:56,425 --> 01:44:58,005
即使他们不断请求

2854
01:44:58,005 --> 01:45:00,470
同样的块状物体一轮又一轮地

2855
01:45:00,470 --> 01:45:02,100
同样的块状物体一轮又一轮地, 以及有更多的消费者。

2856
01:45:02,100 --> 01:45:05,690
然而，地址只会更多

2857
01:45:05,690 --> 01:45:07,930
将这个数据块1多次扩展

2858
01:45:07,930 --> 01:45:09,960
而不是多播的那些。

2859
01:45:09,960 --> 01:45:12,600
为了解决这些问题

2860
01:45:12,600 --> 01:45:14,740
这些在附近吹拂的

2861
01:45:14,740 --> 01:45:16,680
这些块预取机制，

2862
01:45:16,680 --> 01:45:18,230
在它检索之前

2863
01:45:18,230 --> 01:45:19,660
实际的增强现实内容，

2864
01:45:19,660 --> 01:45:21,545
它将会

2865
01:45:21,545 --> 01:45:23,770
首先发送这些元数据兴趣到

2866
01:45:23,770 --> 01:45:25,875
从中检索最新的块号

2867
01:45:25,875 --> 01:45:27,430
边缘加上其他

2868
01:45:27,430 --> 01:45:29,380
也许是流信息。

2869
01:45:29,380 --> 01:45:32,425
此外，在获取了最新的数据块之后，

2870
01:45:32,425 --> 01:45:34,725
消费者将会做的是

2871
01:45:34,725 --> 01:45:37,040
它不仅仅发送了这些兴趣

2872
01:45:37,040 --> 01:45:39,160
但是检索以安抚最新的数据块

2873
01:45:39,160 --> 01:45:40,730
未来的数据块以及还有

2874
01:45:40,730 --> 01:45:43,005
保持突出的兴趣窗口。

2875
01:45:43,005 --> 01:45:44,895
例如，在这个演示中，

2876
01:45:44,895 --> 01:45:45,770
例如，在这个演示中，我们展示了它如何维护窗口大小

2877
01:45:45,770 --> 01:45:47,475
在维护窗口大小

2878
01:45:47,475 --> 01:45:50,145
30号之后它得到了这个块编号1，

2879
01:45:50,145 --> 01:45:51,390
最新的机会号码，

2880
01:45:51,390 --> 01:45:53,320
它将发送兴趣以检索

2881
01:45:53,320 --> 01:45:55,590
未来的11-40个数据块

2882
01:45:55,590 --> 01:45:57,700
并直接发送所有的兴趣包。

2883
01:45:57,700 --> 01:45:59,110
发送到边缘服务器。

2884
01:45:59,110 --> 01:46:00,850
未来的某个时刻，那些数据块

2885
01:46:00,850 --> 01:46:03,080
将会被AR处理生成，例如，

2886
01:46:03,080 --> 01:46:05,070
将会被AR处理

2887
01:46:05,070 --> 01:46:06,610
然后，chunky 11可以被

2888
01:46:06,610 --> 01:46:08,895
可以直接多播给所有消费者

2889
01:46:08,895 --> 01:46:11,695
无需多次传输。

2890
01:46:11,695 --> 01:46:14,525
那么在消费者之后，例如，

2891
01:46:14,525 --> 01:46:16,305
A和B接收到这个数据

2892
01:46:16,305 --> 01:46:17,860
并且你可以发送这个数据块

2893
01:46:17,860 --> 01:46:19,760
将这个窗口移动到41位置。

2894
01:46:19,760 --> 01:46:22,545
转发并发送新的兴趣。

2895
01:46:22,545 --> 01:46:24,555
这个更像是，

2896
01:46:24,555 --> 01:46:25,760
我们不需要

2897
01:46:25,760 --> 01:46:27,920
非常严格的同步操作

2898
01:46:27,920 --> 01:46:30,225
所有消费者我们都可以享受

2899
01:46:30,225 --> 01:46:31,685
这种多播的好处

2900
01:46:31,685 --> 01:46:33,315
在大多数情况下。

2901
01:46:33,315 --> 01:46:35,240
我们也部署了这个

2902
01:46:35,240 --> 01:46:37,305
即使是应用程序重传。

2903
01:46:37,305 --> 01:46:39,910
即使是应用程序重传，

2904
01:46:39,910 --> 01:46:42,160
我们都在使用多播，因为

2905
01:46:42,160 --> 01:46:43,430
下层可能会丢失

2906
01:46:43,430 --> 01:46:44,770
下层可能会丢失类似的数据包

2907
01:46:44,770 --> 01:46:45,860
下层并且

2908
01:46:45,860 --> 01:46:47,220
也可以进行重传

2909
01:46:47,220 --> 01:46:50,610
也能够使得多个用户受益，减少数据包丢失。

2910
01:46:50,610 --> 01:46:53,530
上一期我们要解决的问题是如何

2911
01:46:53,530 --> 01:46:56,010
我们确保增强现实内容的安全性。

2912
01:46:56,010 --> 01:46:58,270
将这种安全性整合到NEAR中

2913
01:46:58,270 --> 01:47:00,280
遵循NDN规范并且

2914
01:47:00,280 --> 01:47:02,085
所有双方的数据内容

2915
01:47:02,085 --> 01:47:03,345
像移动设备对服务器

2916
01:47:03,345 --> 01:47:04,360
以及边缘服务器

2917
01:47:04,360 --> 01:47:05,805
移动端的签名是由

2918
01:47:05,805 --> 01:47:08,715
制作人的证书

2919
01:47:08,715 --> 01:47:11,880
使用这个RSA签名。

2920
01:47:11,880 --> 01:47:16,060
这确保了数据包是由

2921
01:47:16,060 --> 01:47:18,100
合法生产者所发送的，

2922
01:47:18,100 --> 01:47:19,995
还有，在接收到数据之后，

2923
01:47:19,995 --> 01:47:22,220
消费者将会检查证书。

2924
01:47:22,220 --> 01:47:24,645
是否相应的密钥是

2925
01:47:24,645 --> 01:47:27,160
在本地密钥缓存中。

2926
01:47:27,160 --> 01:47:28,550
如果它不归零，它会

2927
01:47:28,550 --> 01:47:29,960
去KeyLocator寻找

2928
01:47:29,960 --> 01:47:31,005
去KeyLocator寻找keys以

2929
01:47:31,005 --> 01:47:33,845
验证数据的完整性。

2930
01:47:33,845 --> 01:47:37,310
为了进一步确保安全性，

2931
01:47:37,310 --> 01:47:39,015
我们执行加密操作并且

2932
01:47:39,015 --> 01:47:41,400
我们为AR内容设置访问控制。

2933
01:47:41,400 --> 01:47:42,740
对于所有的流量

2934
01:47:42,740 --> 01:47:44,090
从生产者到边缘节点，

2935
01:47:44,090 --> 01:47:45,190
我们对数据进行加密。

2936
01:47:45,190 --> 01:47:47,160
使用预共享的内容密钥。

2937
01:47:47,160 --> 01:47:49,265
为了将边缘计算带给消费者，

2938
01:47:49,265 --> 01:47:50,750
我们执行这两阶段

2939
01:47:50,750 --> 01:47:52,760
像内容加密一样，

2940
01:47:52,760 --> 01:47:55,280
从NDN-NAC中学习。

2941
01:47:55,860 --> 01:47:59,605
两阶段意味着首先，

2942
01:47:59,605 --> 01:48:02,450
消费者将发送兴趣至

2943
01:48:02,450 --> 01:48:04,060
检索这些内容关键字

2944
01:48:04,060 --> 01:48:05,510
我们还将考虑消费者的利益，

2945
01:48:05,510 --> 01:48:07,710
我们还将包括消费者的身份证号。

2946
01:48:07,710 --> 01:48:09,370
我们还将包括消费者的身份证号。与这些公钥一起。The Edge Servers can check whether

2947
01:48:09,370 --> 01:48:12,140
边缘服务器可以检查是否

2948
01:48:12,140 --> 01:48:14,060
这些ID和公钥

2949
01:48:14,060 --> 01:48:15,795
在这个访问控制列表中。

2950
01:48:15,795 --> 01:48:17,390
在这个访问控制列表中，如果被允许访问，

2951
01:48:17,390 --> 01:48:18,870
这个特定任务，

2952
01:48:18,870 --> 01:48:21,665
将会发送给移动消费者的相应内容关键字。

2953
01:48:21,665 --> 01:48:24,735
将会发送给移动消费者。

2954
01:48:24,735 --> 01:48:26,145
将会发送给移动消费者。

2955
01:48:26,145 --> 01:48:27,375
会像这样选择。

2956
01:48:27,375 --> 01:48:29,230
这个密钥也将被加密。

2957
01:48:29,230 --> 01:48:31,875
这个消费者共享的公钥，

2958
01:48:31,875 --> 01:48:33,600
后来，消费者可以提取

2959
01:48:33,600 --> 01:48:36,280
他的私钥和这个内容密钥一起

2960
01:48:36,280 --> 01:48:38,510
使用这个内容密钥来解码

2961
01:48:38,510 --> 01:48:40,040
所有群组内容类似于

2962
01:48:40,040 --> 01:48:43,515
这个特定AR任务中的AR内容。

2963
01:48:43,515 --> 01:48:45,685
我们还有所有的内容关键。

2964
01:48:45,685 --> 01:48:47,780
更新 IV（初始化向量）以确保

2965
01:48:47,780 --> 01:48:49,710
数据包无法

2966
01:48:49,710 --> 01:48:53,130
遭受密钥重用攻击。

2967
01:48:53,570 --> 01:48:56,340
然后我们将展示一个演示视频。

2968
01:48:56,340 --> 01:48:57,780
关于我们的平台，

2969
01:48:57,780 --> 01:49:01,080
在这个演示原型中，我们使用了

2970
01:49:01,080 --> 01:49:04,050
Ubuntu 18 作为边缘服务器

2971
01:49:04,050 --> 01:49:06,990
配备了英特尔 i7 CPU，

2972
01:49:06,990 --> 01:49:09,570
配备了 RTX 2080S GPU。

2973
01:49:09,570 --> 01:49:11,160
配备了 RTX 2080S GPU。对于接入点，we're using two access points with the N750。

2974
01:49:11,160 --> 01:49:14,235
我们正在使用两个配备了N750的接入点。

2975
01:49:14,235 --> 01:49:17,715
和AC 1750路由器，

2976
01:49:17,715 --> 01:49:19,470
支持无线连接的

2977
01:49:19,470 --> 01:49:21,955
高速率链路层组播。

2978
01:49:21,955 --> 01:49:24,500
同时，我们还涉及了不同的移动客户端。

2979
01:49:24,500 --> 01:49:27,020
作为生产者同时也是消费者，

2980
01:49:27,020 --> 01:49:28,955
包括谷歌Pixel手机和

2981
01:49:28,955 --> 01:49:30,170
也包括小米手机

2982
01:49:30,170 --> 01:49:32,850
包括不同的安卓设备，比如

2983
01:49:32,850 --> 01:49:34,470
智能手机和所有的东西

2984
01:49:34,470 --> 01:49:35,640
在途中并且与

2985
01:49:35,640 --> 01:49:37,275
商业产品和

2986
01:49:37,275 --> 01:49:40,150
这是我们想要展示的演示。

2987
01:49:40,580 --> 01:49:42,900
首先，我们展示了

2988
01:49:42,900 --> 01:49:46,515
NEAR基础平台设置和

2989
01:49:46,515 --> 01:49:48,225
边缘服务器正在运行在

2990
01:49:48,225 --> 01:49:49,980
Ubuntu服务器也在

2991
01:49:49,980 --> 01:49:51,480
接入点已连接

2992
01:49:51,480 --> 01:49:53,970
通过交换机连接到服务器。

2993
01:49:53,970 --> 01:49:55,530
在NEAR平台上，

2994
01:49:55,530 --> 01:49:57,449
生产者密钥发布

2995
01:49:57,449 --> 01:49:59,670
最新的每个摄像机视角的画面。

2996
01:49:59,670 --> 01:50:00,900
例如，我们在这里展示

2997
01:50:00,900 --> 01:50:02,880
制作人指向街景图，

2998
01:50:02,880 --> 01:50:05,220
以及边缘服务器将会

2999
01:50:05,220 --> 01:50:07,875
从制片人那里获取街景视图。

3000
01:50:07,875 --> 01:50:09,540
边缘服务器将会处理

3001
01:50:09,540 --> 01:50:11,280
流使用Yolo模块

3002
01:50:11,280 --> 01:50:12,780
和加速器一起

3003
01:50:12,780 --> 01:50:14,910
为了实现这种实时处理。

3004
01:50:14,910 --> 01:50:18,030
同时，NEAR还支持GPU和

3005
01:50:18,030 --> 01:50:19,440
AI acceleration tasks, including this Yolo and open post [inaudible] tasks.

3006
01:50:19,440 --> 01:50:21,615
这个Yolo和开放式岗位[听不清]任务。

3007
01:50:21,615 --> 01:50:23,265
经过处理后，

3008
01:50:23,265 --> 01:50:25,109
消费者可以检索

3009
01:50:25,109 --> 01:50:26,730
最新的AR直播流

3010
01:50:26,730 --> 01:50:28,575
对应的命名和

3011
01:50:28,575 --> 01:50:31,170
根据之前的命名空间。

3012
01:50:31,170 --> 01:50:32,730
所有内容将会

3013
01:50:32,730 --> 01:50:34,815
通过链路层多播传输。

3014
01:50:34,815 --> 01:50:36,360
可以看出，所有内容

3015
01:50:36,360 --> 01:50:37,620
只需要传输一次

3016
01:50:37,620 --> 01:50:38,850
并且所有的消费者都可以

3017
01:50:38,850 --> 01:50:41,320
接收它。

3018
01:50:41,420 --> 01:50:44,820
然后我们介绍几个AR模块。

3019
01:50:44,820 --> 01:50:46,545
由我们的平台支持。

3020
01:50:46,545 --> 01:50:48,240
由我们首先可以看到，

3021
01:50:48,240 --> 01:50:50,190
表明Edge可以利用在

3022
01:50:50,190 --> 01:50:52,230
将它们的命名用于对消费者兴趣进行分组

3023
01:50:52,230 --> 01:50:54,690
并进行相应的处理。

3024
01:50:54,690 --> 01:50:56,655
通过检索最新的

3025
01:50:56,655 --> 01:50:59,595
发布就像实时摄像机流。

3026
01:50:59,595 --> 01:51:03,120
边缘设备执行这种物体识别并且

3027
01:51:03,120 --> 01:51:05,130
发布实时结果给

3028
01:51:05,130 --> 01:51:08,290
向所有使用链路层组播的消费者发布实时结果。

3029
01:51:10,190 --> 01:51:13,725
我们还支持面部检测任务。

3030
01:51:13,725 --> 01:51:15,135
我们还支持面部检测任务。利用面部遮罩，借助加速器，

3031
01:51:15,135 --> 01:51:16,515
我们还支持面部检测任务。利用面部遮罩，借助加速器，借助加速器，Edge服务器可以支持，

3032
01:51:16,515 --> 01:51:20,085
Edge服务器可以支持，

3033
01:51:20,085 --> 01:51:21,600
处理多个面孔，

3034
01:51:21,600 --> 01:51:23,790
即使是同时处理数百张面孔，

3035
01:51:23,790 --> 01:51:25,515
和实时实验一起进行

3036
01:51:25,515 --> 01:51:27,045
支持边缘增强现实（Edge AR）。

3037
01:51:27,045 --> 01:51:28,410
正如我们在这里的视图中所看到的，

3038
01:51:28,410 --> 01:51:29,880
我们也有类似的内容

3039
01:51:29,880 --> 01:51:31,815
我们这里的消费者以及可以显示视频是

3040
01:51:31,815 --> 01:51:34,740
显示视频是

3041
01:51:34,740 --> 01:51:36,630
从生产者传输到

3042
01:51:36,630 --> 01:51:39,045
消费者提供实时实验数据。

3043
01:51:39,045 --> 01:51:40,950
OpenPose模块提供

3044
01:51:40,950 --> 01:51:43,275
这是对人体的联合检测，

3045
01:51:43,275 --> 01:51:45,450
头部、面部以及完整的关键点

3046
01:51:45,450 --> 01:51:46,590
以及更进一步，

3047
01:51:46,590 --> 01:51:48,870
我们可以包含所有这些信息

3048
01:51:48,870 --> 01:51:50,475
进入命名中，以便

3049
01:51:50,475 --> 01:51:51,660
所有消费者可以

3050
01:51:51,660 --> 01:51:52,680
获取信息

3051
01:51:52,680 --> 01:51:53,910
他们想要根据

3052
01:51:53,910 --> 01:51:55,785
他们想要根据命名信息。

3053
01:51:55,785 --> 01:51:58,170
利用ADSR与NDI技术结合

3054
01:51:58,170 --> 01:52:00,690
手机能够检测到人体骨骼。

3055
01:52:00,690 --> 01:52:02,714
这里我们展示了增强现实叠加层

3056
01:52:02,714 --> 01:52:04,080
与增强现实叠加层视频相结合

3057
01:52:04,080 --> 01:52:07,455
仅检测场景中的标记，

3058
01:52:07,455 --> 01:52:09,810
并在其上叠加视频。

3059
01:52:09,810 --> 01:52:11,460
这个是针对一些

3060
01:52:11,460 --> 01:52:14,010
广告场景，以便例如，

3061
01:52:14,010 --> 01:52:15,330
该动作可以执行

3062
01:52:15,330 --> 01:52:17,310
一些增强现实广告

3063
01:52:17,310 --> 01:52:20,010
在特定的产品上。

3064
01:52:20,010 --> 01:52:22,770
此外，我们还提供了这个3D模型渲染服务，以及在特定的产品上，所有这些3D模型都是渲染过的。

3065
01:52:22,770 --> 01:52:24,690
所有这些3D模型都是渲染过的。

3066
01:52:24,690 --> 01:52:27,135
边缘增加了服务器端。

3067
01:52:27,135 --> 01:52:28,380
例如，在

3068
01:52:28,380 --> 01:52:29,985
识别市场定位，

3069
01:52:29,985 --> 01:52:32,550
它可以渲染3D模型，

3070
01:52:32,550 --> 01:52:34,920
相应的角度和消费者

3071
01:52:34,920 --> 01:52:36,615
可以移动不同的角度。

3072
01:52:36,615 --> 01:52:38,280
根据制作人的观点，

3073
01:52:38,280 --> 01:52:41,130
它可以在不同的角度变换以展示

3074
01:52:41,130 --> 01:52:42,840
这些3D产品为了

3075
01:52:42,840 --> 01:52:44,280
用于广告宣传以及未来产品展示。

3076
01:52:44,280 --> 01:52:46,740
用于未来产品展示。

3077
01:52:46,740 --> 01:52:48,900
为了共享视图功能，

3078
01:52:48,900 --> 01:52:50,610
我们包括了多个生产者。

3079
01:52:50,610 --> 01:52:52,575
和多个消费者。

3080
01:52:52,575 --> 01:52:53,895
例如，这里我们有

3081
01:52:53,895 --> 01:52:55,860
两个生产者位于视图内部，

3082
01:52:55,860 --> 01:52:57,390
以及服务器端，

3083
01:52:57,390 --> 01:52:59,100
我们检索视图

3084
01:52:59,100 --> 01:53:00,210
从帖子左侧，

3085
01:53:00,210 --> 01:53:01,470
左侧的消费者和右边的

3086
01:53:01,470 --> 01:53:04,050
侧的右边生产者。

3087
01:53:04,050 --> 01:53:05,790
之后，分组由

3088
01:53:05,790 --> 01:53:07,020
这种命名方式，你将会

3089
01:53:07,020 --> 01:53:08,730
执行特征点提取

3090
01:53:08,730 --> 01:53:10,695
并将两个视频合并在一起。

3091
01:53:10,695 --> 01:53:12,390
然后将所有的shareview

3092
01:53:12,390 --> 01:53:13,890
将会直接发布通过

3093
01:53:13,890 --> 01:53:15,810
将会直接发布给所有的消费者

3094
01:53:15,810 --> 01:53:17,550
将会有这多个生产者，

3095
01:53:17,550 --> 01:53:18,900
支持多个消费者

3096
01:53:18,900 --> 01:53:20,640
支持实时处理。

3097
01:53:20,640 --> 01:53:23,280
实时抠图的视频需求支持

3098
01:53:23,280 --> 01:53:26,070
来自制作人的这一处理过程，

3099
01:53:26,070 --> 01:53:27,510
我们添加了色键。

3100
01:53:27,510 --> 01:53:28,995
在边缘服务器端，

3101
01:53:28,995 --> 01:53:30,990
然后我们就可以定位它

3102
01:53:30,990 --> 01:53:33,390
作为这些真实物体的消费者端，

3103
01:53:33,390 --> 01:53:35,460
例如，用来支持舞台的

3104
01:53:35,460 --> 01:53:39,700
这些交互式歌剧应用程序。

3105
01:53:39,710 --> 01:53:43,305
我们还比较了性能

3106
01:53:43,305 --> 01:53:46,260
在多个消费者下进行测试

3107
01:53:46,260 --> 01:53:49,080
这个链路层多播的性能

3108
01:53:49,080 --> 01:53:50,625
以及结合

3109
01:53:50,625 --> 01:53:52,575
整个NEAR平台。

3110
01:53:52,575 --> 01:53:54,675
我们可以看到，为了测试这个，

3111
01:53:54,675 --> 01:53:55,770
我们想要比较~!@#$%^&*()

3112
01:53:55,770 --> 01:53:57,270
我们想要比较~!@#$%^&*()的性能与单播流的性能。

3113
01:53:57,270 --> 01:54:00,405
与单播流相比较。

3114
01:54:00,405 --> 01:54:02,280
我们使用相同的视频。

3115
01:54:02,280 --> 01:54:03,795
为了展示差异。

3116
01:54:03,795 --> 01:54:07,185
使用这个视频是为了2K源，同时我们也~!@#$%^&*()

3117
01:54:07,185 --> 01:54:10,470
这涉及到这四个消费者。

3118
01:54:10,470 --> 01:54:13,230
我们有一个60 Mbps的背景流量来

3119
01:54:13,230 --> 01:54:16,155
模拟非常严重的拥堵情况。

3120
01:54:16,155 --> 01:54:18,120
我们可以看到，对于NEAR平台来说

3121
01:54:18,120 --> 01:54:19,455
可以继续发布

3122
01:54:19,455 --> 01:54:22,410
这些非常流畅的2K资源

3123
01:54:22,410 --> 01:54:25,500
和它们在这里非常高[听不清]。

3124
01:54:25,500 --> 01:54:26,550
对于单播，

3125
01:54:26,550 --> 01:54:28,155
受到拥塞的困扰

3126
01:54:28,155 --> 01:54:30,210
有时候资源

3127
01:54:30,210 --> 01:54:32,100
无法按时送达给

3128
01:54:32,100 --> 01:54:33,270
无法按时送达给消费者

3129
01:54:33,270 --> 01:54:34,830
我们被困在那里了。

3130
01:54:34,830 --> 01:54:36,540
即使对于这四位消费者来说

3131
01:54:36,540 --> 01:54:38,385
即使对于这四位消费者来说，他们有着深厚的背景。直到我们将更多消费者纳入其中，

3132
01:54:38,385 --> 01:54:41,445
直到我们将更多消费者纳入其中，

3133
01:54:41,445 --> 01:54:45,420
NEAR将不会增加进一步的[听不清]。

3134
01:54:45,420 --> 01:54:47,730
只有一些额外的开销

3135
01:54:47,730 --> 01:54:49,590
将因重传而产生的成本加上

3136
01:54:49,590 --> 01:54:51,810
像视频传输这样的主要开销

3137
01:54:51,810 --> 01:54:54,375
因为我们只使用多播模式

3138
01:54:54,375 --> 01:54:56,820
因为我们只使用多播模式，不喜欢单播模式，可扩展性非常高。

3139
01:54:56,820 --> 01:54:59,820
高于我们的平台。

3140
01:54:59,820 --> 01:55:02,080
比我们的平台差。

3141
01:55:02,720 --> 01:55:07,620
我们将关闭我们的网站。

3142
01:55:07,620 --> 01:55:09,810
我们很高兴介绍

3143
01:55:09,810 --> 01:55:12,120
我们的平台欢迎来自~!@#$%^&*()

3144
01:55:12,120 --> 01:55:14,700
利用我们的平台[听不清]

3145
01:55:14,700 --> 01:55:17,295
我们还可以设计更多的模块进去。

3146
01:55:17,295 --> 01:55:21,900
谢谢。我很高兴。

3147
01:55:21,900 --> 01:55:24,490
如果你有任何问题，请回答。

3148
01:55:24,680 --> 01:55:27,210
>> 这真的很酷。

3149
01:55:27,210 --> 01:55:29,940
谢谢。我有个简单的问题。

3150
01:55:29,940 --> 01:55:31,769
当你谈论可扩展性时，

3151
01:55:31,769 --> 01:55:34,140
我认为你比较了单播和多播。

3152
01:55:34,140 --> 01:55:35,640
~!@#$%^&*()

3153
01:55:35,640 --> 01:55:37,305
看消费者的数量？

3154
01:55:37,305 --> 01:55:37,920
因为我认为在

3155
01:55:37,920 --> 01:55:39,405
你在幻灯片中提到了四个，

3156
01:55:39,405 --> 01:55:41,040
这是否会受到任何影响，如果我们假设

3157
01:55:41,040 --> 01:55:43,365
消费者的数量增加到20人？

3158
01:55:43,365 --> 01:55:47,190
是的，由于我们设备数量的限制，

3159
01:55:47,190 --> 01:55:48,930
我们设备数量的限制，

3160
01:55:48,930 --> 01:55:52,410
我们只有六部手机。

3161
01:55:52,410 --> 01:55:53,700
最多，以便我们

3162
01:55:53,700 --> 01:55:55,485
将所有手机连接到服务器上，

3163
01:55:55,485 --> 01:55:57,360
我们实际上看到的是，

3164
01:55:57,360 --> 01:55:59,505
吞吐量并没有大幅增加。

3165
01:55:59,505 --> 01:56:01,560
但这并不像单播

3166
01:56:01,560 --> 01:56:03,555
当我们在那里增加六个消费者时，

3167
01:56:03,555 --> 01:56:05,070
吞吐量将会是

3168
01:56:05,070 --> 01:56:07,005
吞吐量将会是原来的六倍。

3169
01:56:07,005 --> 01:56:09,060
但对于我们的NEAR来说，更像是保持着

3170
01:56:09,060 --> 01:56:12,130
始终保持类似的吞吐量。

3171
01:56:15,020 --> 01:56:17,115
>> 非常感谢。

3172
01:56:17,115 --> 01:56:19,140
>> 非常感谢。[同时说话]

3173
01:56:19,140 --> 01:56:20,655
>> 非常感谢。

3174
01:56:20,655 --> 01:56:21,780
~!@#$%^&*()

3175
01:56:21,780 --> 01:56:27,450
>> 非常感谢您，

3176
01:56:27,450 --> 01:56:29,385
塔梅尔和所有的演讲者。

3177
01:56:29,385 --> 01:56:34,060
我们准时开始20分钟的休息时间。

3178
01:56:34,850 --> 01:56:37,185
快到3点半了。

3179
01:56:37,185 --> 01:56:38,880
我们将在20分钟后回来。

3180
01:56:38,880 --> 01:56:42,090
在3点50分，第4场会议。

3181
01:56:42,090 --> 01:56:46,000
我们20分钟后见。谢谢。

