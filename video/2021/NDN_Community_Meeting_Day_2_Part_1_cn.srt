1
00:00:03,710 --> 00:00:06,240
早上好，欢迎来到

2
00:00:06,240 --> 00:00:09,945
2021年NDNComm第二天。

3
00:00:09,945 --> 00:00:12,780
我们今天从第五场会议开始。

4
00:00:12,780 --> 00:00:14,400
应用程序将会是

5
00:00:14,400 --> 00:00:16,500
主持人是Jeff Burke。

6
00:00:16,500 --> 00:00:17,775
~!@#$%^&*()

7
00:00:17,775 --> 00:00:19,740
常驻教授和副教授

8
00:00:19,740 --> 00:00:21,240
技术学院院长

9
00:00:21,240 --> 00:00:23,430
加州大学洛杉矶分校戏剧学院的创新，

10
00:00:23,430 --> 00:00:24,930
电影和电视，

11
00:00:24,930 --> 00:00:28,620
他共同指导REMAP中心。

12
00:00:28,620 --> 00:00:30,260
大多数人都知道，

13
00:00:30,260 --> 00:00:32,420
他一直是共同主要研究员之一，并且

14
00:00:32,420 --> 00:00:33,710
应用负责人

15
00:00:33,710 --> 00:00:36,410
美国国家科学基金会资助的NDN项目。

16
00:00:36,410 --> 00:00:39,130
杰夫，请继续。

17
00:00:39,130 --> 00:00:41,730
嗨。很高兴来到这里。我们有

18
00:00:41,730 --> 00:00:43,815
三场演讲。

19
00:00:43,815 --> 00:00:45,620
我将会介绍

20
00:00:45,620 --> 00:00:47,630
我将会简短地介绍他们，以便给予他们尽可能多的时间来发言。

21
00:00:47,630 --> 00:00:49,500
我会尽可能给他们更多的时间来发言。

22
00:00:49,500 --> 00:00:51,620
我们为每位发言者大约安排了15分钟。

23
00:00:51,620 --> 00:00:54,425
再加上五分钟用于提问。

24
00:00:54,425 --> 00:00:56,000
我会注意查看

25
00:00:56,000 --> 00:00:57,350
Slack和BlueJeans都是

26
00:00:57,350 --> 00:01:00,655
帮助促进问题沟通的聊天工具。

27
00:01:00,655 --> 00:01:02,780
我们的第一次交谈，由Lan Wang主讲。

28
00:01:02,780 --> 00:01:05,045
在孟菲斯大学的是mGuard，

29
00:01:05,045 --> 00:01:06,980
一种安全的实时数据分发系统

30
00:01:06,980 --> 00:01:10,620
具有细粒度访问控制的系统。

31
00:01:17,160 --> 00:01:19,245
>> 你好。你能听到我说话吗？

32
00:01:19,245 --> 00:01:21,220
>> 哦，对不起。我意识到我有

33
00:01:21,220 --> 00:01:23,215
一个简历，我需要阅读。

34
00:01:23,215 --> 00:01:25,360
这是一位教授兼系主任。

35
00:01:25,360 --> 00:01:27,010
计算机科学系

36
00:01:27,010 --> 00:01:28,135
在孟菲斯大学。

37
00:01:28,135 --> 00:01:29,830
她自2010年起一直在研究NDN（命名数据网络）。

38
00:01:29,830 --> 00:01:32,110
自2010年起专注于路由，

39
00:01:32,110 --> 00:01:33,160
转发策略，

40
00:01:33,160 --> 00:01:35,930
同步与应用程序开发。

41
00:01:36,560 --> 00:01:42,220
>> 谢谢。让我看看我能不能分享屏幕。

42
00:01:42,220 --> 00:01:45,080
你能看到我的屏幕吗？

43
00:01:45,780 --> 00:01:47,185
>> 是的。

44
00:01:47,185 --> 00:01:48,610
>> 你好，好的。

45
00:01:48,610 --> 00:01:55,240
~!@#$%^&*()

46
00:01:55,240 --> 00:01:56,720
>> 全屏显示。

47
00:01:56,720 --> 00:01:59,860
>> 是的，你能看到全屏显示吗？

48
00:02:01,520 --> 00:02:03,795
>> 杰夫，你能看到吗？

49
00:02:03,795 --> 00:02:06,390
>> 我们现在还是在看演讲者视图。

50
00:02:06,390 --> 00:02:07,990
>> 是的。

51
00:02:08,840 --> 00:02:11,715
>> 你能看到全屏吗？

52
00:02:11,715 --> 00:02:15,730
不行吗？我再试一次。

53
00:02:18,470 --> 00:02:21,810
>> 首先你需要停止共享屏幕，然后你

54
00:02:21,810 --> 00:02:23,130
选择全屏显示

55
00:02:23,130 --> 00:02:24,840
那个窗口。现在没问题了。

56
00:02:24,840 --> 00:02:26,410
>> 现在我们看到它了。

57
00:02:26,710 --> 00:02:31,085
>> 好的。早上好。

58
00:02:31,085 --> 00:02:34,420
我将要讲述

59
00:02:34,420 --> 00:02:37,375
我们的项目叫做mGuard。

60
00:02:37,375 --> 00:02:38,840
这是一种努力

61
00:02:38,840 --> 00:02:41,510
帮助移动健康研究人员

62
00:02:41,510 --> 00:02:47,110
安全且实时地访问数据。

63
00:02:47,110 --> 00:02:49,220
这是一次合作，

64
00:02:49,220 --> 00:02:52,330
孟菲斯大学和加州大学洛杉矶分校，

65
00:02:52,330 --> 00:02:55,245
并且得到了美国国家科学基金会的支持。

66
00:02:55,245 --> 00:02:58,880
去年，我实际上给出了一个概述

67
00:02:58,880 --> 00:03:02,460
项目在NDNComm期间，

68
00:03:02,460 --> 00:03:05,225
那是在项目开始的时候。

69
00:03:05,225 --> 00:03:08,165
虽然我没有提供太多细节。

70
00:03:08,165 --> 00:03:10,580
这次我们已经

71
00:03:10,580 --> 00:03:12,260
这次我们已经在项目上工作了一年，

72
00:03:12,260 --> 00:03:16,905
所以我可以向你报告一下项目进展情况。

73
00:03:16,905 --> 00:03:19,430
所以我可以向你报告一下项目进展情况。首先，这个项目是由一个用例激励的，即

74
00:03:19,430 --> 00:03:22,550
是由一个用例激励的，即

75
00:03:22,550 --> 00:03:25,970
是收集

76
00:03:25,970 --> 00:03:29,020
和分发移动健康数据。

77
00:03:29,020 --> 00:03:32,840
基本上，我们大学有

78
00:03:32,840 --> 00:03:37,640
国立卫生研究院资助的中心名为MD2K。

79
00:03:37,640 --> 00:03:39,065
他们正在收集大量的

80
00:03:39,065 --> 00:03:41,945
实验室研究的数据。

81
00:03:41,945 --> 00:03:46,040
实地研究，来自数千个

82
00:03:46,040 --> 00:03:51,080
参与者拥有数万亿个数据点。

83
00:03:51,080 --> 00:03:55,085
他们想要分享这些数据给

84
00:03:55,085 --> 00:04:02,145
许多研究人员也是如此，

85
00:04:02,145 --> 00:04:05,420
研究协调员和

86
00:04:05,420 --> 00:04:08,615
研究参与者本身。

87
00:04:08,615 --> 00:04:13,860
问题是，现在

88
00:04:13,860 --> 00:04:20,450
现有的工具或系统它们

89
00:04:20,450 --> 00:04:22,340
无法支持细粒度访问控制

90
00:04:22,340 --> 00:04:24,815
细粒度访问控制

91
00:04:24,815 --> 00:04:28,000
和实时数据分发。

92
00:04:28,000 --> 00:04:31,070
他们不能，例如，

93
00:04:31,070 --> 00:04:34,550
限制研究协调员

94
00:04:34,550 --> 00:04:36,695
只能访问他们自己的研究，

95
00:04:36,695 --> 00:04:38,345
不能访问别人的研究。

96
00:04:38,345 --> 00:04:43,460
他们不能仅限制研究参与者

97
00:04:43,460 --> 00:04:45,455
只能访问他们自己的数据以及

98
00:04:45,455 --> 00:04:49,560
他们只能访问其他参与者的数据等等。

99
00:04:49,560 --> 00:04:53,354
他们想要非常灵活的访问控制权限。

100
00:04:53,354 --> 00:04:56,760
但现有系统不支持这一点。

101
00:04:56,760 --> 00:04:59,990
able to give researchers

102
00:04:59,990 --> 00:05:03,250
能够为研究人员提供

103
00:05:03,250 --> 00:05:06,950
及时访问，以便他们能够

104
00:05:06,950 --> 00:05:10,340
提供实时干预，以便如果

105
00:05:10,340 --> 00:05:12,440
出现病人有任何问题时，

106
00:05:12,440 --> 00:05:16,355
例如，但那是不被支持的。

107
00:05:16,355 --> 00:05:20,030
我们的项目想要做的是应用

108
00:05:20,030 --> 00:05:23,375
NDN基于名称的数据中心方法，

109
00:05:23,375 --> 00:05:26,400
特别是同步和基于名称的访问控制或

110
00:05:26,400 --> 00:05:28,970
解决上述问题。

111
00:05:28,970 --> 00:05:32,635
解决上述问题。

112
00:05:32,635 --> 00:05:36,175
这是与MD2K的合作。

113
00:05:36,175 --> 00:05:40,310
他们提供数据并使用

114
00:05:40,310 --> 00:05:43,610
案例需求，所以我们

115
00:05:43,610 --> 00:05:47,250
可以设计这些机制。

116
00:05:47,510 --> 00:05:52,309
这是系统的概述。

117
00:05:52,309 --> 00:05:54,620
主要组件您可以看到的是数据适配器，

118
00:05:54,620 --> 00:05:57,080
您可以看到的是数据适配器，

119
00:05:57,080 --> 00:06:00,594
发布者，一个存储单元，

120
00:06:00,594 --> 00:06:04,835
一个访问管理器和一个订阅者。

121
00:06:04,835 --> 00:06:11,720
基本上，我们将MD2K中的现有数据

122
00:06:11,720 --> 00:06:15,530
将其转换并存储在NDN仓库中。

123
00:06:15,530 --> 00:06:20,800
转换成NDN数据并存储在NDN仓库中。

124
00:06:20,800 --> 00:06:26,020
然后是数据名称

125
00:06:26,020 --> 00:06:30,305
提供给出版商。

126
00:06:30,305 --> 00:06:32,915
出版商将创建元数据

127
00:06:32,915 --> 00:06:36,385
并将元数据存储在仓库中。

128
00:06:36,385 --> 00:06:38,750
同时，出版商会

129
00:06:38,750 --> 00:06:40,520
将会进行广告宣传

130
00:06:40,520 --> 00:06:42,260
这些信息关于

131
00:06:42,260 --> 00:06:46,740
这些信息关于向订阅者提供新数据。

132
00:06:46,740 --> 00:06:50,540
订阅者可以请求任何数据

133
00:06:50,540 --> 00:06:55,345
他们可以从发布者那里实时获取他们想要的数据。

134
00:06:55,345 --> 00:06:57,815
他们可以订阅

135
00:06:57,815 --> 00:07:01,820
他们只能订阅数据流的一个子集，以便

136
00:07:01,820 --> 00:07:11,680
他们可以

137
00:07:13,390 --> 00:07:15,770
接收只有数据

138
00:07:15,770 --> 00:07:18,090
对他们来说感兴趣的。

139
00:07:19,820 --> 00:07:23,750
访问管理器将创建

140
00:07:23,750 --> 00:07:28,490
用户解密数据的密钥。

141
00:07:28,490 --> 00:07:30,140
同时，

142
00:07:30,140 --> 00:07:32,660
访问管理器将共享

143
00:07:32,660 --> 00:07:37,850
数据适配器的一些参数

144
00:07:37,850 --> 00:07:40,970
加密NDN数据。

145
00:07:40,970 --> 00:07:44,970
这就是整个系统。

146
00:07:47,060 --> 00:07:50,250
在这个项目的第一年，

147
00:07:50,250 --> 00:07:52,720
我们开发了系统设计。

148
00:07:52,720 --> 00:07:56,245
我们还开发了NDN命名方案。

149
00:07:56,245 --> 00:08:02,725
我们还开发了一种策略规范。

150
00:08:02,725 --> 00:08:05,515
我们还为访问控制开发了解析器。

151
00:08:05,515 --> 00:08:10,345
我们扩展了现有的NAC-ABE库

152
00:08:10,345 --> 00:08:12,040
以支持密钥

153
00:08:12,040 --> 00:08:16,040
基于属性的加密策略。

154
00:08:16,040 --> 00:08:20,190
我们设计了一个使用PSync的发布-订阅API。

155
00:08:20,190 --> 00:08:22,720
和NAC-ABE来发布

156
00:08:22,720 --> 00:08:24,865
并订阅数据流。

157
00:08:24,865 --> 00:08:26,725
我将提供更多细节。

158
00:08:26,725 --> 00:08:29,030
的每一项。

159
00:08:29,030 --> 00:08:35,290
首先，MD2K中心收集~!@#$%^&*()

160
00:08:35,290 --> 00:08:37,340
原始数据，同时他们也会

161
00:08:37,340 --> 00:08:42,100
基于原始数据产生派生数据。

162
00:08:42,100 --> 00:08:46,475
我们为每一个起了不同的名字。

163
00:08:46,475 --> 00:08:49,235
对于原始数据流。

164
00:08:49,235 --> 00:08:52,100
这个数据命名方案是基于他们现有的命名，

165
00:08:52,100 --> 00:08:56,040
但是我们重新排序了一些组成部分。

166
00:08:56,040 --> 00:09:00,940
但是我们重新排序了一些组成部分。

167
00:09:00,940 --> 00:09:04,830
它基本上是一个前缀，

168
00:09:04,830 --> 00:09:07,085
然后是研究名称，

169
00:09:07,085 --> 00:09:09,200
参与者姓名，以及

170
00:09:09,200 --> 00:09:12,030
设备用于收集数据，

171
00:09:12,030 --> 00:09:13,320
传感器，

172
00:09:13,320 --> 00:09:14,690
传感器安装在哪里？

173
00:09:14,690 --> 00:09:16,450
传感器已经安装好了。

174
00:09:16,450 --> 00:09:20,315
那么派生出的数据

175
00:09:20,315 --> 00:09:24,470
则被命名为前缀，研究，

176
00:09:24,470 --> 00:09:26,750
则参与者和算法

177
00:09:26,750 --> 00:09:28,280
或者是那个包装

178
00:09:28,280 --> 00:09:32,400
用于生成派生数据。

179
00:09:32,400 --> 00:09:36,619
噪音。具体数据点

180
00:09:36,619 --> 00:09:39,335
数据流的前缀，

181
00:09:39,335 --> 00:09:44,525
然后是关键字数据，接着是时间戳。

182
00:09:44,525 --> 00:09:53,340
这就是现有数据的标注方式。

183
00:09:53,340 --> 00:09:55,810
它们有各自的时间戳。

184
00:09:56,150 --> 00:09:59,260
对于每个数据点，

185
00:09:59,260 --> 00:10:02,060
每个数据点都有一个相应的内容键。

186
00:10:02,060 --> 00:10:06,005
我们还给内容键命名

187
00:10:06,005 --> 00:10:09,185
使用相同的流前缀

188
00:10:09,185 --> 00:10:12,125
和一个关键词，Ckey。

189
00:10:12,125 --> 00:10:14,840
正如我之前提到的，

190
00:10:14,840 --> 00:10:18,025
出版商还会创建

191
00:10:18,025 --> 00:10:21,150
出版商还会创建一个清单或元数据来

192
00:10:21,150 --> 00:10:25,680
记录每个数据流，以便清单具有

193
00:10:25,680 --> 00:10:27,885
跟踪前缀的每个数据流，以便清单具有前缀和清单关键字的序列号。

194
00:10:27,885 --> 00:10:32,135
和清单关键字在序列号中。

195
00:10:32,135 --> 00:10:35,960
定期地，出版商~!@#$%^&*()

196
00:10:35,960 --> 00:10:39,710
将会生成一个新的清单，带有

197
00:10:39,710 --> 00:10:40,985
将生成一个新的序列号

198
00:10:40,985 --> 00:10:42,440
以及订阅者将会

199
00:10:42,440 --> 00:10:47,465
在此清单创建时，订阅者将会被通知。

200
00:10:47,465 --> 00:10:51,330
我们就是这样命名数据的。

201
00:10:51,740 --> 00:10:54,230
对于访问控制，

202
00:10:54,230 --> 00:10:57,140
我们的主要目标是定义并

203
00:10:57,140 --> 00:10:59,000
实施细粒度的权限控制

204
00:10:59,000 --> 00:11:00,095
访问数据。

205
00:11:00,095 --> 00:11:01,780
我们是什么意思？

206
00:11:01,780 --> 00:11:03,140
首先，我们需要

207
00:11:03,140 --> 00:11:06,320
支持不同类型的用户，

208
00:11:06,320 --> 00:11:10,160
数据生产者、研究协调员、

209
00:11:10,160 --> 00:11:14,035
和数据管理员等。

210
00:11:14,035 --> 00:11:16,669
我们想要给每个用户

211
00:11:16,669 --> 00:11:18,740
提供基于最小访问权限的

212
00:11:18,740 --> 00:11:20,765
在使用条款上。

213
00:11:20,765 --> 00:11:22,580
尽可能少的手段，你不会得到

214
00:11:22,580 --> 00:11:26,530
通过尽可能少的手段，你不会得到比你应该获得的权限更多。We want to support novice users who don't

215
00:11:26,530 --> 00:11:35,780
我们希望支持那些不一定拥有非常深入知识的新手用户。

216
00:11:35,780 --> 00:11:41,509
不一定拥有非常深入知识

217
00:11:41,509 --> 00:11:45,830
为了能够定义一项政策，需要具备一定的安全知识。

218
00:11:45,830 --> 00:11:50,850
政策语言应该非常简单。

219
00:11:52,200 --> 00:11:55,869
为了支持上述目标，

220
00:11:55,869 --> 00:12:01,240
我们利用现有的NAC-ABE库

221
00:12:01,240 --> 00:12:04,045
使用内容密钥对数据进行加密，

222
00:12:04,045 --> 00:12:05,470
然后加密

223
00:12:05,470 --> 00:12:09,370
每个内容关键词的属性集合

224
00:12:09,370 --> 00:12:13,570
可以帮助执行

225
00:12:13,570 --> 00:12:16,615
执行访问控制策略，

226
00:12:16,615 --> 00:12:18,609
然后我们生成，

227
00:12:18,609 --> 00:12:20,890
分发内容密钥

228
00:12:20,890 --> 00:12:24,310
对应的用户，

229
00:12:24,310 --> 00:12:27,040
对应的用户，各自拥有

230
00:12:27,040 --> 00:12:33,970
他们访问权限相关联的密钥。

231
00:12:33,970 --> 00:12:38,995
我们所说的访问控制策略是什么意思？

232
00:12:38,995 --> 00:12:41,620
我这里有一个例子。

233
00:12:41,620 --> 00:12:45,790
首先，数据所有者定义

234
00:12:45,790 --> 00:12:47,875
一组属性

235
00:12:47,875 --> 00:12:50,465
根据要支持的政策，

236
00:12:50,465 --> 00:12:55,305
然后指定了一组政策

237
00:12:55,305 --> 00:12:58,635
包含了那些属性

238
00:12:58,635 --> 00:13:00,660
每个用户都关联着。

239
00:13:00,660 --> 00:13:04,560
例如，对于每项政策，

240
00:13:04,560 --> 00:13:08,260
我们有一个用于识别政策的ID，

241
00:13:08,260 --> 00:13:10,750
与此政策相关联的是谁？

242
00:13:10,750 --> 00:13:13,690
与此政策相关联的是，

243
00:13:13,690 --> 00:13:15,340
与此政策相关联的是，这里是一份清单

244
00:13:15,340 --> 00:13:21,145
与这些数据的用户相对应的名字。

245
00:13:21,145 --> 00:13:23,680
这些用户被允许

246
00:13:23,680 --> 00:13:27,175
访问具有这些属性的数据，

247
00:13:27,175 --> 00:13:29,350
他们不被允许这样做

248
00:13:29,350 --> 00:13:31,900
数据所有者需要访问具有这些属性的数据。

249
00:13:31,900 --> 00:13:34,960
access data with these attributes.

250
00:13:34,960 --> 00:13:39,190
指定的是列表

251
00:13:39,190 --> 00:13:41,410
可以访问数据的人员名单，

252
00:13:41,410 --> 00:13:43,840
以及被允许的属性，

253
00:13:43,840 --> 00:13:45,895
和被拒绝的属性。

254
00:13:45,895 --> 00:13:48,130
例如，这里有~!@#$%^&*()

255
00:13:48,130 --> 00:13:51,780
一个示例政策[噪音]。

256
00:13:51,780 --> 00:13:54,780
爱丽丝是UCLA的一名用户，可以

257
00:13:54,780 --> 00:13:57,790
访问MD2K产生的数据

258
00:13:57,790 --> 00:14:00,535
mPerf研究参与者

259
00:14:00,535 --> 00:14:03,700
当参与者

260
00:14:03,700 --> 00:14:05,230
在家里或者在工作的时候，

261
00:14:05,230 --> 00:14:07,195
但是爱丽丝无法获得

262
00:14:07,195 --> 00:14:09,965
参与者的GPS位置。

263
00:14:09,965 --> 00:14:13,290
我们如何支持这项政策？

264
00:14:13,290 --> 00:14:16,030
首先我们指定名称为

265
00:14:16,030 --> 00:14:21,340
数据用户，alice/edu/user/alice，

266
00:14:21,340 --> 00:14:25,120
那么在允许的属性中我们指定

267
00:14:25,120 --> 00:14:31,075
我们指定的允许属性中，那就是数据集对应的/org/md2k/mperf/dd40c，

268
00:14:31,075 --> 00:14:33,310
这就是相应的数据集

269
00:14:33,310 --> 00:14:35,800
向研究参与者。

270
00:14:35,800 --> 00:14:39,805
那么我们就说，只有当这个用户在家的时候，

271
00:14:39,805 --> 00:14:42,100
或者这位参与者在家里或者在工作的时候，

272
00:14:42,100 --> 00:14:44,845
这两个属性用来识别哪里

273
00:14:44,845 --> 00:14:49,285
这项研究参与者的位置，

274
00:14:49,285 --> 00:14:50,995
当数据被生成时，

275
00:14:50,995 --> 00:14:54,850
我们指定一个属性

276
00:14:54,850 --> 00:14:56,635
在被拒绝的字段中，也就是说，

277
00:14:56,635 --> 00:14:59,905
数据名称

278
00:14:59,905 --> 00:15:03,655
这个用户的GPS位置。

279
00:15:03,655 --> 00:15:06,895
这非常简单直观。

280
00:15:06,895 --> 00:15:12,560
对于一个新手用户来说，这是很容易指定的。

281
00:15:13,200 --> 00:15:16,555
这就是控制策略。

282
00:15:16,555 --> 00:15:18,715
我们现在如何支持这项政策？

283
00:15:18,715 --> 00:15:20,080
正如我之前提到的，

284
00:15:20,080 --> 00:15:22,135
我们有一个解析器，它可以转换

285
00:15:22,135 --> 00:15:25,520
我们有一个解析器，它可以转换每个策略为一个表达式。

286
00:15:25,830 --> 00:15:30,100
例如，如果允许的字段

287
00:15:30,100 --> 00:15:33,070
具有三个属性，

288
00:15:33,070 --> 00:15:35,770
我们将使用或运算符，

289
00:15:35,770 --> 00:15:38,755
来连接相同时间的属性。

290
00:15:38,755 --> 00:15:40,600
这些是位置属性，

291
00:15:40,600 --> 00:15:42,430
所以我们用“或”来连接它们。

292
00:15:42,430 --> 00:15:44,215
对于另一个，我应该是

293
00:15:44,215 --> 00:15:47,230
我们用“和”将其连接起来。

294
00:15:47,230 --> 00:15:49,630
这意味着数据是

295
00:15:49,630 --> 00:15:52,060
产生在家里或者工作场所，

296
00:15:52,060 --> 00:15:54,370
产生的数据

297
00:15:54,370 --> 00:15:57,655
2021年9月1日之后。

298
00:15:57,655 --> 00:16:03,025
这个表达式或一组~!@#$%^&*()

299
00:16:03,025 --> 00:16:06,505
属性被编码进入

300
00:16:06,505 --> 00:16:08,950
属性被编码进入数据用户的解密密钥。

301
00:16:08,950 --> 00:16:10,930
数据用户只能

302
00:16:10,930 --> 00:16:14,000
访问具有这些属性的数据。

303
00:16:15,270 --> 00:16:20,530
这个解密密钥是如何生成的？

304
00:16:20,530 --> 00:16:23,635
它是由访问管理器生成的。

305
00:16:23,635 --> 00:16:26,410
它由NAC-ABE库提供，

306
00:16:26,410 --> 00:16:29,275
它提供了自动化的密钥管理功能。

307
00:16:29,275 --> 00:16:33,205
它可以将这个密钥分发给用户，

308
00:16:33,205 --> 00:16:37,510
并且还提供

309
00:16:37,510 --> 00:16:41,050
所需的加密参数

310
00:16:41,050 --> 00:16:44,365
为数据发布者

311
00:16:44,365 --> 00:16:47,270
用来加密数据。

312
00:16:47,370 --> 00:16:50,740
由于原始实现支持

313
00:16:50,740 --> 00:16:53,965
仅支持密文策略属性基加密（CP-ABE），

314
00:16:53,965 --> 00:16:57,625
我们将其扩展以支持基于密钥策略的属性加密（KP-ABE），

315
00:16:57,625 --> 00:17:00,550
这意味着策略被嵌入或者

316
00:17:00,550 --> 00:17:03,700
因为这种方法是更加

317
00:17:03,700 --> 00:17:08,080
适合我们的项目。

318
00:17:08,080 --> 00:17:11,155
适合我们的项目。

319
00:17:11,155 --> 00:17:15,775
我们如何实时分发数据？

320
00:17:15,775 --> 00:17:19,990
我们定义了一个发布-订阅API以允许用户

321
00:17:19,990 --> 00:17:22,480
订阅数据流，按照他们的访问策略所允许的。

322
00:17:22,480 --> 00:17:25,090
允许的，根据他们的访问策略。

323
00:17:25,090 --> 00:17:27,430
和这个发布-订阅 API

324
00:17:27,430 --> 00:17:30,910
保证接收到最新的数据，

325
00:17:30,910 --> 00:17:33,040
并将验证数据

326
00:17:33,040 --> 00:17:35,605
在每个订阅的流中，

327
00:17:35,605 --> 00:17:37,510
我可以使用这个拼接来

328
00:17:37,510 --> 00:17:40,375
发现并订阅数据流，

329
00:17:40,375 --> 00:17:44,875
并使用NAC-ABE来加密和解密数据。

330
00:17:44,875 --> 00:17:46,930
我们遇到的一个问题

331
00:17:46,930 --> 00:17:48,265
我们遇到的一个问题是有很多小数据对象我们需要

332
00:17:48,265 --> 00:17:51,280
我们需要的小数据对象

333
00:17:51,280 --> 00:17:55,390
进行签名和验证，

334
00:17:55,390 --> 00:17:58,840
这可能会导致非常高的开销

335
00:17:58,840 --> 00:18:00,430
如果小数据是

336
00:18:00,430 --> 00:18:02,860
产生的频率非常高。

337
00:18:02,860 --> 00:18:06,235
另一种解决方案是使用Manifest。

338
00:18:06,235 --> 00:18:08,695
基本上出版商会制作

339
00:18:08,695 --> 00:18:11,020
一系列的清单用于

340
00:18:11,020 --> 00:18:13,090
每个数据流与

341
00:18:13,090 --> 00:18:15,050
这个名字，

342
00:18:16,860 --> 00:18:18,865
流前缀/清单/序列号。

343
00:18:18,865 --> 00:18:22,315
这个清单包含了全名，

344
00:18:22,315 --> 00:18:24,400
包括隐式摘要

345
00:18:24,400 --> 00:18:28,255
新生成的数据对象中

346
00:18:28,255 --> 00:18:31,105
这最后一个时期自从

347
00:18:31,105 --> 00:18:35,695
这最后一份清单被制作出来了。

348
00:18:35,695 --> 00:18:38,545
订阅者基本上

349
00:18:38,545 --> 00:18:42,620
接收清单并且

350
00:18:42,990 --> 00:18:48,085
检索各个数据项

351
00:18:48,085 --> 00:18:52,930
或与这些名称对应的对象。

352
00:18:52,930 --> 00:18:55,060
因为这些名称

353
00:18:55,060 --> 00:18:57,205
包含隐式摘要，

354
00:18:57,205 --> 00:19:00,430
用户可以验证检索到的

355
00:19:00,430 --> 00:19:04,930
数据与这些隐式摘要匹配。

356
00:19:04,930 --> 00:19:08,140
每个数据对象都没有签名，

357
00:19:08,140 --> 00:19:10,600
因此我们可以减少

358
00:19:10,600 --> 00:19:13,585
管理和验证的开销，

359
00:19:13,585 --> 00:19:16,240
我们也可以减少 overhead of

360
00:19:16,240 --> 00:19:17,560
因为我们没有进行同步，所以我们也可以减少 overhead of syncing individual objects。

361
00:19:17,560 --> 00:19:19,165
同步单个对象，

362
00:19:19,165 --> 00:19:20,980
我们正在考虑一套

363
00:19:20,980 --> 00:19:24,070
我们正在考虑一套使用清单同时处理多个对象，and piecing makes sure

364
00:19:24,070 --> 00:19:27,550
确保拼接工作

365
00:19:27,550 --> 00:19:32,090
以确保订阅者接收到清单。

366
00:19:32,820 --> 00:19:36,490
现在我将给我们做一个总结。

367
00:19:36,490 --> 00:19:40,150
但我们从中学到了什么教训？

368
00:19:40,150 --> 00:19:41,860
首先，我们花了很多时间尝试去理解

369
00:19:41,860 --> 00:19:43,420
我们花了很多时间尝试去理解

370
00:19:43,420 --> 00:19:48,530
我们花了很多时间尝试去理解MD2K对访问控制的要求。This is a specific use case,

371
00:19:48,750 --> 00:19:52,510
这是一个特定的用例，

372
00:19:52,510 --> 00:19:58,465
但它给了我们一个很好的认识

373
00:19:58,465 --> 00:20:04,255
对安全性的要求

374
00:20:04,255 --> 00:20:07,150
移动健康数据可能具有的。

375
00:20:07,150 --> 00:20:09,370
我们也花了很多时间

376
00:20:09,370 --> 00:20:11,110
我们也花了很多时间尝试理解我们如何能够use NAC-ABE to support

377
00:20:11,110 --> 00:20:13,180
使用NAC-ABE来支持

378
00:20:13,180 --> 00:20:16,780
这些要求[噪音]。

379
00:20:16,780 --> 00:20:19,060
Previous work, I think, for example, ~!@#$%^&*()

380
00:20:19,060 --> 00:20:23,710
NDN燧石用了NAC

381
00:20:23,710 --> 00:20:25,360
但这不是

382
00:20:25,360 --> 00:20:27,985
基于属性的加密版本，

383
00:20:27,985 --> 00:20:32,020
所以我们必须考虑如何使用

384
00:20:32,020 --> 00:20:34,930
属性基加密以支持

385
00:20:34,930 --> 00:20:36,250
这些要求。

386
00:20:36,250 --> 00:20:38,280
~!@#$%^&*()

387
00:20:38,280 --> 00:20:41,760
>> 此外，政策规范

388
00:20:41,760 --> 00:20:44,310
经历了多次迭代。

389
00:20:44,310 --> 00:20:47,490
起初我们使用

390
00:20:47,490 --> 00:20:51,435
接近它们现有的实现的政策规范。

391
00:20:51,435 --> 00:20:54,540
接近它们现有的实现，

392
00:20:54,540 --> 00:20:58,260
基本上为每个表指定

393
00:20:58,260 --> 00:21:01,155
为每个数据库表，

394
00:21:01,155 --> 00:21:04,260
用户可以访问哪些列，

395
00:21:04,260 --> 00:21:05,760
和值是多少

396
00:21:05,760 --> 00:21:08,415
用户可以访问的字段。

397
00:21:08,415 --> 00:21:11,670
后来，我们意识到那不是

398
00:21:11,670 --> 00:21:15,000
最佳或最合适的类型

399
00:21:15,000 --> 00:21:17,010
规格说明

400
00:21:17,010 --> 00:21:20,370
基于属性的访问控制

401
00:21:20,370 --> 00:21:23,610
或主要基于属性的访问控制。

402
00:21:23,610 --> 00:21:25,560
我们意识到我们应该

403
00:21:25,560 --> 00:21:27,405
使用仅限名称和~!@#$%^&*()

404
00:21:27,405 --> 00:21:29,865
在策略规范中的属性

405
00:21:29,865 --> 00:21:31,380
这种方法实际上很简单，

406
00:21:31,380 --> 00:21:33,030
这种方法简化了

407
00:21:33,030 --> 00:21:34,890
这项政策规范

408
00:21:34,890 --> 00:21:38,295
这很多而且也非常直观。

409
00:21:38,295 --> 00:21:40,829
这是两个主要的教训。

410
00:21:40,829 --> 00:21:42,780
我们学到了。现在这

411
00:21:42,780 --> 00:21:46,850
我们快到时间了。

412
00:21:46,850 --> 00:21:47,960
你想结束了吗？

413
00:21:47,960 --> 00:21:50,700
是的。有

414
00:21:50,700 --> 00:21:53,760
几个主要的开放性问题。这是为什么呢？

415
00:21:53,760 --> 00:21:56,910
没有负操作符支持。

416
00:21:56,910 --> 00:21:57,960
在那个知识库环境中，

417
00:21:57,960 --> 00:22:01,545
在那个知识库环境中，实施拒绝属性是很困难的。

418
00:22:01,545 --> 00:22:03,900
实施拒绝属性。

419
00:22:03,900 --> 00:22:05,895
基本上，我们必须

420
00:22:05,895 --> 00:22:08,580
列出所有属性在~!@#$%^&*()

421
00:22:08,580 --> 00:22:10,500
一特定类型并移除

422
00:22:10,500 --> 00:22:12,135
被拒绝的属性

423
00:22:12,135 --> 00:22:14,385
这非常麻烦。

424
00:22:14,385 --> 00:22:17,715
我们希望这个问题能够得到解决。

425
00:22:17,715 --> 00:22:22,170
那么还有可能的可扩展性问题。

426
00:22:22,170 --> 00:22:24,375
对于NAC-ABE方法来说。

427
00:22:24,375 --> 00:22:27,675
当策略非常细粒度时，

428
00:22:27,675 --> 00:22:29,175
可能会有大量

429
00:22:29,175 --> 00:22:30,855
可能会有大量的属性，这些属性很难明确和处理。

430
00:22:30,855 --> 00:22:35,610
很难明确和处理。

431
00:22:35,610 --> 00:22:39,780
我们需要一个非常可靠的仓库实现。

432
00:22:39,780 --> 00:22:42,165
能够支持高速，

433
00:22:42,165 --> 00:22:45,340
能够支持高速，可靠的数据传输和插入。

434
00:22:46,700 --> 00:22:49,710
在第二年我们想要完成

435
00:22:49,710 --> 00:22:50,955
的实施

436
00:22:50,955 --> 00:22:52,515
和系统的测试，

437
00:22:52,515 --> 00:22:54,510
接下来我们想要部署

438
00:22:54,510 --> 00:22:57,690
接下来我们想要部署mGuard在NDN测试床上通过连接

439
00:22:57,690 --> 00:23:01,170
接下来我们想要部署mGuard在NDN测试床上通过连接到MD2K服务器并添加订阅者。这就是我要说的全部。

440
00:23:01,170 --> 00:23:04,945
接下来我们要把它部署到测试床上。我要说的就是这些。

441
00:23:04,945 --> 00:23:06,500
>> 非常好。谢谢你。

442
00:23:06,500 --> 00:23:07,880
感谢您准时到达。

443
00:23:07,880 --> 00:23:09,260
有一些不错的问题

444
00:23:09,260 --> 00:23:10,595
在Slack频道中，

445
00:23:10,595 --> 00:23:12,410
所以如果你有时间去

446
00:23:12,410 --> 00:23:13,310
请回答他们，在那边。

447
00:23:13,310 --> 00:23:14,210
我认为那会很棒。

448
00:23:14,210 --> 00:23:16,115
让我们继续下一个。

449
00:23:16,115 --> 00:23:17,770
>> 谢谢。

450
00:23:17,770 --> 00:23:19,650
>> 这是我的荣幸。

451
00:23:19,650 --> 00:23:23,550
介绍Susmit Shannigrahi。

452
00:23:23,550 --> 00:23:25,125
我希望我猜得很接近。

453
00:23:25,125 --> 00:23:26,250
谁是教授？

454
00:23:26,250 --> 00:23:28,005
在田纳西科技大学，

455
00:23:28,005 --> 00:23:30,240
指向下一代互联网实验室。

456
00:23:30,240 --> 00:23:32,310
该研究聚焦于

457
00:23:32,310 --> 00:23:34,080
构建工具和协议，以

458
00:23:34,080 --> 00:23:35,700
促进大数据管理

459
00:23:35,700 --> 00:23:37,335
和在互联网上的传输与流动。

460
00:23:37,335 --> 00:23:39,240
他研究、设计和构建

461
00:23:39,240 --> 00:23:40,440
智能协议用于

462
00:23:40,440 --> 00:23:41,805
下一代在这里。

463
00:23:41,805 --> 00:23:46,200
今天的评估讨论是关于Hydra安全的，

464
00:23:46,200 --> 00:23:48,180
分布式和联邦存储

465
00:23:48,180 --> 00:23:50,580
对于大型和科学数据

466
00:23:50,580 --> 00:23:55,680
我将直接再次向黑色提问，

467
00:23:55,680 --> 00:23:58,020
我们会尽量留出几分钟。

468
00:23:58,020 --> 00:23:59,310
如果你能在最后暂停一下

469
00:23:59,310 --> 00:24:00,390
对于我们可能有的一些问题，如果你能在最后暂停一下，可以回答它们。非常感谢。

470
00:24:00,390 --> 00:24:03,270
可以回答它们。非常感谢。

471
00:24:03,270 --> 00:24:06,880
>> 谢谢。你能看到我的屏幕吗？

472
00:24:07,040 --> 00:24:09,405
>> 是的，我们能看到你的屏幕。

473
00:24:09,405 --> 00:24:13,275
>> 太好了。大家早上好。

474
00:24:13,275 --> 00:24:16,590
这是一个新的国家科学基金会项目。

475
00:24:16,590 --> 00:24:20,160
这个项目是上个月开始的，所以它是全新的。

476
00:24:20,160 --> 00:24:22,365
但我们一直在进行这项工作

477
00:24:22,365 --> 00:24:25,530
大约在过去的一年里。

478
00:24:25,530 --> 00:24:28,650
我将要介绍一种叫做Hydra的东西。

479
00:24:28,650 --> 00:24:31,110
它是一个联合存储系统，覆盖了

480
00:24:31,110 --> 00:24:34,350
NDN是这个~!@#$%^&*()

481
00:24:34,350 --> 00:24:35,820
一项合作努力

482
00:24:35,820 --> 00:24:38,490
在田纳西州和克莱姆森大学之间的合作努力，FIU和UCLA也参与其中。

483
00:24:38,490 --> 00:24:41,770
佛罗里达国际大学（FIU）和加州大学洛杉矶分校（UCLA）。

484
00:24:41,980 --> 00:24:45,110
~!@#$%^&*()

485
00:24:45,110 --> 00:24:46,700
我不知道为什么那个学生

486
00:24:46,700 --> 00:24:47,840
名字没有显示出来。

487
00:24:47,840 --> 00:24:49,510
但我已经去过那里了。

488
00:24:49,510 --> 00:24:53,190
Hydra的目标是

489
00:24:53,190 --> 00:24:54,719
已经实现了真正的联邦化

490
00:24:54,719 --> 00:24:57,120
存储系统在NDN上。

491
00:24:57,120 --> 00:25:00,330
我们的动机是，我们

492
00:25:00,330 --> 00:25:01,920
我们现在知道的是，

493
00:25:01,920 --> 00:25:04,230
我们现在知道的是，大型科学数据集，

494
00:25:04,230 --> 00:25:06,255
像高能物理学这样的领域，

495
00:25:06,255 --> 00:25:09,014
像你昨天听到的，在基因组学领域，

496
00:25:09,014 --> 00:25:11,850
他们确实可以从命名数据网络中获益。

497
00:25:11,850 --> 00:25:13,440
基于名称和位置

498
00:25:13,440 --> 00:25:15,345
透明网络。

499
00:25:15,345 --> 00:25:18,974
但要实现这一点，

500
00:25:18,974 --> 00:25:21,810
我们首先需要使数据可用。

501
00:25:21,810 --> 00:25:25,185
我们如何通过NDN使数据可用。

502
00:25:25,185 --> 00:25:28,380
我们有几种方法可以做到这一点，

503
00:25:28,380 --> 00:25:31,755
因此我们可以拥有一个独立的存储库。

504
00:25:31,755 --> 00:25:33,675
像NDN存储库一样，

505
00:25:33,675 --> 00:25:35,920
但这并不非常适合扩展。

506
00:25:35,920 --> 00:25:39,290
现在，我们可以有文件系统接口，

507
00:25:39,290 --> 00:25:42,020
正如你昨天从Katelyn Stock那里听到的。

508
00:25:42,020 --> 00:25:44,030
但随后的复制和~!@#$%^&*()

509
00:25:44,030 --> 00:25:48,330
可用性变成了用户的责任。

510
00:25:49,070 --> 00:25:52,305
在这次演讲中，我们将要讨论

511
00:25:52,305 --> 00:25:53,880
联邦仓库

512
00:25:53,880 --> 00:25:58,540
它们还能自我组织。

513
00:25:58,580 --> 00:26:01,530
用户们，他们可以发布

514
00:26:01,530 --> 00:26:03,840
将数据集上传到这些存储库

515
00:26:03,840 --> 00:26:05,790
然后就忘掉了

516
00:26:05,790 --> 00:26:08,805
所有发布数据的后勤工作。

517
00:26:08,805 --> 00:26:11,775
物流包括复制，

518
00:26:11,775 --> 00:26:13,875
访问控制。

519
00:26:13,875 --> 00:26:16,065
如果一个节点出现故障，

520
00:26:16,065 --> 00:26:17,805
故障恢复，

521
00:26:17,805 --> 00:26:22,245
这一切都由Hydra来处理。

522
00:26:22,245 --> 00:26:24,750
这个项目我们使用~!@#$%^&*()

523
00:26:24,750 --> 00:26:27,760
基因组学社区作为驱动力。

524
00:26:28,250 --> 00:26:30,480
基因组学社区的需求是什么？

525
00:26:30,480 --> 00:26:31,860
对基因组学社区来说？

526
00:26:31,860 --> 00:26:34,424
这将会非常通用。

527
00:26:34,424 --> 00:26:36,765
这将会是

528
00:26:36,765 --> 00:26:39,720
对许多科学界来说也是如此，

529
00:26:39,720 --> 00:26:41,490
根据第一个要求是

530
00:26:41,490 --> 00:26:44,070
该存储系统必须支持

531
00:26:44,070 --> 00:26:47,160
非常大的数据集，这些数据集可以位于任何地方

532
00:26:47,160 --> 00:26:48,330
从太字节到

533
00:26:48,330 --> 00:26:51,375
太字节和最终艾字节。

534
00:26:51,375 --> 00:26:54,390
数据发布机制必须要

535
00:26:54,390 --> 00:26:57,120
简单然后提供

536
00:26:57,120 --> 00:27:00,030
持久化存储在文件级别上。

537
00:27:00,030 --> 00:27:03,105
与原始仓库设计不同

538
00:27:03,105 --> 00:27:06,420
我们正在存储NDN数据包的地方，

539
00:27:06,420 --> 00:27:11,200
九头蛇将要存储文件。

540
00:27:12,020 --> 00:27:14,460
下载对象

541
00:27:14,460 --> 00:27:16,750
将处于高水平。

542
00:27:18,410 --> 00:27:20,370
这些社区将处于高水平，地理分布，

543
00:27:20,370 --> 00:27:21,900
地理分布，

544
00:27:21,900 --> 00:27:23,520
所以数据集是

545
00:27:23,520 --> 00:27:25,320
复制用于提高可用性和

546
00:27:25,320 --> 00:27:28,020
那么就有一个优化的选项

547
00:27:28,020 --> 00:27:29,490
数据的放置基于

548
00:27:29,490 --> 00:27:32,200
根据它们所需的地方进行放置。

549
00:27:32,360 --> 00:27:34,470
当然，NDN

550
00:27:34,470 --> 00:27:37,455
提供透明的数据访问。

551
00:27:37,455 --> 00:27:39,510
但我们也需要为

552
00:27:39,510 --> 00:27:41,115
一些基因组学数据集，

553
00:27:41,115 --> 00:27:43,450
我们需要访问控制。

554
00:27:43,940 --> 00:27:48,420
因为你可以想象，

555
00:27:48,420 --> 00:27:52,390
基因组数据可能涉及隐私敏感信息。

556
00:27:57,260 --> 00:28:00,645
继续稍微跟进一下

557
00:28:00,645 --> 00:28:01,920
今天有什么可用的

558
00:28:01,920 --> 00:28:03,735
基因组学界，

559
00:28:03,735 --> 00:28:06,060
他们需要简单和安全的发表与获取

560
00:28:06,060 --> 00:28:07,470
安全的发布和访问

561
00:28:07,470 --> 00:28:09,900
机制，然后拥有

562
00:28:09,900 --> 00:28:12,270
持久化和复制的数据存储。

563
00:28:12,270 --> 00:28:14,130
当前的选项正确

564
00:28:14,130 --> 00:28:18,585
现在它可以被发送到一个中央存储库，

565
00:28:18,585 --> 00:28:22,065
现在它可以被发送到一个中央存储库，比如NCBI或NHS，然后告诉他们，我需要发布这些数据。

566
00:28:22,065 --> 00:28:23,985
我需要发布这些数据

567
00:28:23,985 --> 00:28:25,785
你会帮我做那件事吗？

568
00:28:25,785 --> 00:28:29,640
他们可能会说：“好的，我会发布你的数据，

569
00:28:29,640 --> 00:28:32,280
但这可能需要几个月的时间来完成。

570
00:28:32,280 --> 00:28:34,440
或者他们可能会说，这些数据是

571
00:28:34,440 --> 00:28:37,350
所以我们不会发布那些数据。

572
00:28:37,350 --> 00:28:41,140
所以我们不会采取那些数据。

573
00:28:41,240 --> 00:28:45,210
那么如果第二件事发生了，

574
00:28:45,210 --> 00:28:48,840
那么科学家们就有了结果

575
00:28:48,840 --> 00:28:51,060
添加她的出版物。

576
00:28:51,060 --> 00:28:53,850
它可能是一个HTTP网络服务器，

577
00:28:53,850 --> 00:28:57,000
它可能是一个科学家的个人网页，

578
00:28:57,000 --> 00:29:01,185
FTP服务器，但随后它变得非常特定临时。

579
00:29:01,185 --> 00:29:02,760
然后找到并利用

580
00:29:02,760 --> 00:29:06,195
然后找到并利用这些数据变得非常困难。

581
00:29:06,195 --> 00:29:08,940
现在，当科学家们

582
00:29:08,940 --> 00:29:10,964
they have to specify wonders about the operation of workflows,

583
00:29:10,964 --> 00:29:13,245
他们必须指定

584
00:29:13,245 --> 00:29:15,310
他们必须指定要使用哪些数据集，

585
00:29:15,310 --> 00:29:18,860
和问题有关

586
00:29:18,860 --> 00:29:21,170
临时出版物是这样的

587
00:29:21,170 --> 00:29:22,610
事情变得硬编码

588
00:29:22,610 --> 00:29:23,750
进入那些工作负载中。

589
00:29:23,750 --> 00:29:25,450
如果有什么需要改变，

590
00:29:25,450 --> 00:29:27,750
整个工作流程需要改变。

591
00:29:27,750 --> 00:29:31,450
这可能会非常乏味。

592
00:29:32,150 --> 00:29:35,215
我们还注意到了其他事情。

593
00:29:35,215 --> 00:29:38,245
我们还注意到了其他事情。云存储是昂贵的。我们潜在可以考虑

594
00:29:38,245 --> 00:29:40,105
我们潜在可以考虑将所有数据放入云端并完成此事。

595
00:29:40,105 --> 00:29:43,520
我们可以考虑把所有数据放到云端并完成这件事。

596
00:29:43,520 --> 00:29:46,445
但这并不便宜。

597
00:29:46,445 --> 00:29:50,150
将那么多数据存储在云端。

598
00:29:50,850 --> 00:29:53,200
但存储也是

599
00:29:53,200 --> 00:29:55,045
在各个研究所也不容易获得，

600
00:29:55,045 --> 00:29:56,870
但它们并不容易

601
00:29:56,870 --> 00:29:59,540
可利用的或联合的。

602
00:29:59,660 --> 00:30:03,955
各个研究所都在各自的孤立中运作着，

603
00:30:03,955 --> 00:30:09,140
为当地研究人员提供了访问权限，

604
00:30:09,510 --> 00:30:13,930
显然这样做效率并不高。

605
00:30:13,930 --> 00:30:15,910
并且也限制了容量

606
00:30:15,910 --> 00:30:17,855
它们可以拥有的。

607
00:30:17,855 --> 00:30:21,415
数据安全目前非常具有挑战性。

608
00:30:21,415 --> 00:30:23,225
访问控制与~!@#$%^&*()相关联。

609
00:30:23,225 --> 00:30:25,340
一个特定的发布系统。

610
00:30:25,340 --> 00:30:27,025
如果是HTTP，

611
00:30:27,025 --> 00:30:31,040
它使用了三分之一的访问控制，

612
00:30:31,040 --> 00:30:34,060
如果是S承载或者FTP，

613
00:30:34,060 --> 00:30:36,595
它可能会有所不同。

614
00:30:36,595 --> 00:30:38,650
那么就有一个巨大的

615
00:30:38,650 --> 00:30:41,630
所有这些都有一个手动的组成部分。

616
00:30:41,700 --> 00:30:45,139
用户凭证设置，

617
00:30:45,139 --> 00:30:47,800
角色管理，角色分配，

618
00:30:47,800 --> 00:30:50,960
然后如果一个用户离开，

619
00:30:51,720 --> 00:30:55,870
凭证需要更新。

620
00:30:55,870 --> 00:30:58,585
然后最后，数据传递，

621
00:30:58,585 --> 00:31:00,125
即使数据被加密，

622
00:31:00,125 --> 00:31:01,745
它结束了，个人的

623
00:31:01,745 --> 00:31:04,715
和单独的安全通道。

624
00:31:04,715 --> 00:31:08,375
数据本身并没有内在的安全性。

625
00:31:08,375 --> 00:31:10,330
它全都与...有关联

626
00:31:10,330 --> 00:31:11,585
它全都与...有关联，或者是频道

627
00:31:11,585 --> 00:31:14,150
或者是个人加密。

628
00:31:14,820 --> 00:31:19,090
如果一个实验室有五名学生，我们想要

629
00:31:19,090 --> 00:31:25,510
为每个人提供个性化的安全保护

630
00:31:25,510 --> 00:31:26,750
为他们每个人，

631
00:31:26,750 --> 00:31:28,180
它变得非常困难。

632
00:31:28,180 --> 00:31:32,155
或者你将数据加密五次，

633
00:31:32,155 --> 00:31:34,690
或者你将数据加密一次，

634
00:31:34,690 --> 00:31:36,370
你将密钥保留给PI，

635
00:31:36,370 --> 00:31:37,959
然后PI决定如何操作

636
00:31:37,959 --> 00:31:40,075
如何保护数据，

637
00:31:40,075 --> 00:31:43,610
这又一次效率不高。

638
00:31:44,990 --> 00:31:47,385
在一个非常高的层面上，

639
00:31:47,385 --> 00:31:48,870
这就是Hydra是什么。

640
00:31:48,870 --> 00:31:51,330
它是一个联合存储系统，在

641
00:31:51,330 --> 00:31:53,820
它是通过NDN网络进行的，

642
00:31:53,820 --> 00:31:58,200
很抱歉，这是一组仓库节点。

643
00:31:58,640 --> 00:32:00,850
它利用

644
00:32:00,850 --> 00:32:02,050
它利用每个层级的存储在

645
00:32:02,050 --> 00:32:03,485
不同的组织。

646
00:32:03,485 --> 00:32:06,925
我们的想法不像Cassandra或者

647
00:32:06,925 --> 00:32:08,680
分布式数据库，它们是

648
00:32:08,680 --> 00:32:10,840
在单一管理之下。

649
00:32:10,840 --> 00:32:13,480
这些位于不同的研究所。

650
00:32:13,480 --> 00:32:15,175
这些由不同的人管理。

651
00:32:15,175 --> 00:32:17,405
但一旦你安装了Hydra，

652
00:32:17,405 --> 00:32:20,335
它就变成了一个自组织系统。

653
00:32:20,335 --> 00:32:23,030
那么一旦数据被发布，

654
00:32:23,030 --> 00:32:25,000
它使用了Anycast，

655
00:32:25,000 --> 00:32:27,475
NDN默认的Anycast机制

656
00:32:27,475 --> 00:32:29,755
或数据访问。

657
00:32:29,755 --> 00:32:33,280
复制也会自动进行。

658
00:32:33,280 --> 00:32:35,200
现在，默认的复制程度是三。

659
00:32:35,200 --> 00:32:36,655
的复制程度是三。

660
00:32:36,655 --> 00:32:38,680
但这可以根据社区的需要进行调整。

661
00:32:38,680 --> 00:32:41,890
根据社区的需要。

662
00:32:41,890 --> 00:32:45,065
那么一旦数据被复制之后，

663
00:32:45,065 --> 00:32:48,230
它可以被任何人请求。

664
00:32:48,230 --> 00:32:52,555
九头蛇还能透明处理失败。

665
00:32:52,555 --> 00:32:53,965
如果一个节点出现故障，

666
00:32:53,965 --> 00:32:57,125
数据会自动复制到另一个节点。

667
00:32:57,125 --> 00:33:00,669
然后它会尽可能地维护，

668
00:33:00,669 --> 00:33:04,429
保持所需的复制程度。

669
00:33:04,500 --> 00:33:08,245
为了安全起见，我们正计划

670
00:33:08,245 --> 00:33:11,560
使用NDN的基于名称的信任模式，

671
00:33:11,560 --> 00:33:16,570
和传统的公钥基础设施(PKI)

672
00:33:16,570 --> 00:33:21,040
与基于属性的访问控制相比较。

673
00:33:21,040 --> 00:33:23,335
另一个方面是

674
00:33:23,335 --> 00:33:24,865
数据的可查找性，

675
00:33:24,865 --> 00:33:27,310
所以我们正计划提供

676
00:33:27,310 --> 00:33:31,190
一个统一的基于名称的接口用于所有数据。

677
00:33:31,190 --> 00:33:34,675
科学家们是否发现了

678
00:33:34,675 --> 00:33:36,605
数据来自一个遗留系统

679
00:33:36,605 --> 00:33:38,915
FTP或HTTP存储，

680
00:33:38,915 --> 00:33:41,035
它们都将通过Hydra进行处理。

681
00:33:41,035 --> 00:33:45,055
它为它们提供了一个统一的命名空间。

682
00:33:45,055 --> 00:33:48,400
然后Hydra负责获取数据

683
00:33:48,400 --> 00:33:51,805
为他们解决问题然后再回传给他们。

684
00:33:51,805 --> 00:33:53,860
存在一个中间过程在为他们解决问题然后再回传给他们和translation that happens之间。

685
00:33:53,860 --> 00:33:57,185
发生的翻译过程。

686
00:33:57,185 --> 00:34:00,550
如果这些数据对许多人有用，

687
00:34:00,550 --> 00:34:03,335
那么它有可能上传这些数据，

688
00:34:03,335 --> 00:34:05,950
但那是未来的工作。

689
00:34:08,070 --> 00:34:13,000
这是一个稍微详细一点的视图。

690
00:34:13,000 --> 00:34:14,330
这是 Hydra 如何工作的一个稍微详细一点的视图。在左边你有出版商 A

691
00:34:14,330 --> 00:34:17,535
在左边你有出版商 A

692
00:34:17,535 --> 00:34:20,335
向云端发送一份出版请求

693
00:34:20,335 --> 00:34:21,830
向云端，

694
00:34:21,830 --> 00:34:25,040
它是九头蛇，然后

695
00:34:25,040 --> 00:34:26,195
该请求被发送至

696
00:34:26,195 --> 00:34:28,895
距离发布者最近的一个仓库。

697
00:34:28,895 --> 00:34:32,615
发布者查看信任模式，

698
00:34:32,615 --> 00:34:34,330
进行访问控制，

699
00:34:34,330 --> 00:34:35,410
然后检索

700
00:34:35,410 --> 00:34:37,100
出版商提供的文件。

701
00:34:37,100 --> 00:34:38,690
那么在那个时候，

702
00:34:38,690 --> 00:34:40,645
它会生成一个通知

703
00:34:40,645 --> 00:34:43,490
向系统中的其他节点发送。

704
00:34:43,680 --> 00:34:46,270
通知已经发出。

705
00:34:46,270 --> 00:34:50,075
大家都知道新文件已经送来了。

706
00:34:50,075 --> 00:34:52,000
我们将要讨论

707
00:34:52,000 --> 00:34:53,465
它们是如何复制的。

708
00:34:53,465 --> 00:34:55,330
但这取决于是否

710
00:34:57,220 --> 00:34:59,740
他们从那里获取数据。

711
00:34:59,740 --> 00:35:01,930
他们首先接触的节点并且

712
00:35:01,930 --> 00:35:05,000
然后复制到他们的代码库中。

713
00:35:05,120 --> 00:35:07,805
在顶部，你已经~!@#$%^&*()

714
00:35:07,805 --> 00:35:10,260
在拱门里看到了那道光。

715
00:35:10,260 --> 00:35:12,020
那是与...的接口。

716
00:35:12,020 --> 00:35:13,895
那是与现有数据仓库的接口。

717
00:35:13,895 --> 00:35:16,220
您的请求已收到。

718
00:35:16,220 --> 00:35:19,385
来自用户A或用户B的右侧。

719
00:35:19,385 --> 00:35:22,610
如果数据已经不在Hydra中，

720
00:35:22,610 --> 00:35:24,780
如果数据已经不在Hydra中，Hydra就会出去并且

721
00:35:24,780 --> 00:35:25,890
去获取数据来自

722
00:35:25,890 --> 00:35:27,980
现有的仓库。

723
00:35:30,090 --> 00:35:35,720
在中间，Hydra使用同步状态向量同步(SVS)，

724
00:35:35,720 --> 00:35:38,555
保持状态向量同步

725
00:35:38,555 --> 00:35:41,220
保持全局状态一致

726
00:35:41,220 --> 00:35:45,250
在不同的仓库之间。

727
00:35:46,410 --> 00:35:49,659
谈一谈设计方面的事情，

728
00:35:49,659 --> 00:35:52,570
我们在这里假设了一些事情。

729
00:35:52,570 --> 00:35:55,315
我们假设所有节点是平等的。

730
00:35:55,315 --> 00:35:57,775
没有单一的控制点。

731
00:35:57,775 --> 00:35:59,970
正如我所说，它进行复制

732
00:35:59,970 --> 00:36:02,005
数据以文件粒度存在。

733
00:36:02,005 --> 00:36:04,885
文件就像NDN一样是不可变的。

734
00:36:04,885 --> 00:36:08,105
该代码库只处理插入和删除操作。

735
00:36:08,105 --> 00:36:12,460
该代码库没有更新。然后我

736
00:36:12,460 --> 00:36:14,230
我认为这是最重要的Hydra的一个方面，

737
00:36:14,230 --> 00:36:16,540
的一个重要方面，

738
00:36:16,540 --> 00:36:18,425
是每个节点都做出

739
00:36:18,425 --> 00:36:20,470
本地决策关于哪个文件

740
00:36:20,470 --> 00:36:21,970
他们想要复制。

741
00:36:21,970 --> 00:36:23,945
我们通过这样做来

742
00:36:23,945 --> 00:36:28,395
我们通过这样做来创造一个数值，that we call favor.

743
00:36:28,395 --> 00:36:30,360
我们称之为“好感度”。

744
00:36:30,360 --> 00:36:33,925
每个节点宣告一个“好感度”。

745
00:36:33,925 --> 00:36:36,835
对整个系统宣称这是

746
00:36:36,835 --> 00:36:39,250
多大可能我会

747
00:36:39,250 --> 00:36:43,810
复制一个新进来的文件。

748
00:36:44,030 --> 00:36:46,659
那么九头蛇就不负责任了。

749
00:36:46,659 --> 00:36:48,185
为了文件的保密性。

750
00:36:48,185 --> 00:36:49,845
它进行访问控制。

751
00:36:49,845 --> 00:36:53,995
但如果需要文件保密，

752
00:36:53,995 --> 00:36:55,190
用户需要

753
00:36:55,190 --> 00:36:57,385
加密并上传那段代码。

754
00:36:57,385 --> 00:37:00,430
那么现在在初始阶段，

755
00:37:00,430 --> 00:37:02,825
我们现在假设没有妥协，

756
00:37:02,825 --> 00:37:04,570
但那种假设将会在未来发生改变。

757
00:37:04,570 --> 00:37:07,400
将来会发生改变。

758
00:37:08,220 --> 00:37:12,320
Hydra的基本构建块是文件。

759
00:37:12,320 --> 00:37:15,490
用户，它只是一个二进制大对象（BLOB）。

760
00:37:15,490 --> 00:37:18,805
对于数据来说，它是由一个名称来识别的。

761
00:37:18,805 --> 00:37:22,405
数据发布者可以插入一个文件。

762
00:37:22,405 --> 00:37:26,150
生物学SRA后面跟着SRA编号，

763
00:37:26,150 --> 00:37:28,330
这是一个基因组序列。

764
00:37:28,330 --> 00:37:29,920
消费者可以发送

765
00:37:29,920 --> 00:37:32,645
消费者可以通过系统发送一个NDN兴趣。

766
00:37:32,645 --> 00:37:35,300
它表示“/Hydra/fetch”，

767
00:37:35,300 --> 00:37:38,610
它跟随那个名称并获取数据返回。

768
00:37:38,610 --> 00:37:40,930
我们在这项工作中使用

769
00:37:40,930 --> 00:37:42,935
我们在这项工作中使用的既定命名方案

770
00:37:42,935 --> 00:37:44,135
已经被设定

771
00:37:44,135 --> 00:37:45,905
由社区创建。

772
00:37:45,905 --> 00:37:48,039
我们只是拿来并翻译了它。

773
00:37:48,039 --> 00:37:51,230
将其转换为NDN命名方案。

774
00:37:54,410 --> 00:37:58,714
基本操作是插入删除。

775
00:37:58,714 --> 00:38:01,150
再次，就像获取数据一样，

776
00:38:01,150 --> 00:38:04,280
您向仓库前缀发送了一个命令，

777
00:38:04,280 --> 00:38:07,155
接着是实际的数据。

778
00:38:07,155 --> 00:38:10,469
接着是数据消费者，

779
00:38:10,469 --> 00:38:12,455
他们直接转变为兴趣。

780
00:38:12,455 --> 00:38:14,730
前往九头蛇以获取数据。

781
00:38:16,320 --> 00:38:20,075
这是发表时所发生的事情。

782
00:38:20,075 --> 00:38:21,395
应用程序在右边，

783
00:38:21,395 --> 00:38:23,315
它发布了数据。

784
00:38:23,315 --> 00:38:27,270
它收缩了一个离它最近的节点，

785
00:38:27,270 --> 00:38:28,960
然后在那时，

786
00:38:28,960 --> 00:38:31,555
节点生成一个群发消息，该消息会发送

787
00:38:31,555 --> 00:38:36,020
to everyone else to Vector Sync.

节点生成一个群发消息，该消息会发送给其他所有人以进行向量同步。在那时，每个人都知道有

788
00:38:36,020 --> 00:38:38,460
一个新文件他们可能需要复制。

789
00:38:38,460 --> 00:38:41,410
他们可能需要复制的一个新文件。

790
00:38:41,990 --> 00:38:46,220
九头蛇还维护着一个全球视角。

791
00:38:46,220 --> 00:38:48,225
群组消息是

792
00:38:48,225 --> 00:38:50,675
本质上是在尝试交流

793
00:38:50,675 --> 00:38:53,140
更新全球视角。

794
00:38:53,430 --> 00:38:57,335
在右边你会看到它有一堆~!@#$%^&*()

795
00:38:57,335 --> 00:39:01,175
节点都有各自的偏好设置。

796
00:39:01,175 --> 00:39:04,810
每当有新文件进来时，

797
00:39:04,810 --> 00:39:06,745
这条信息被交换了。

798
00:39:06,745 --> 00:39:11,910
Then everyone knows what are ~!@#$%^&*()

799
00:39:11,910 --> 00:39:14,585
前三名或前五名的节点

800
00:39:14,585 --> 00:39:16,060
有潜力的是可以

801
00:39:16,060 --> 00:39:18,190
复制这些文件。

802
00:39:19,640 --> 00:39:23,785
正如我所说，节点是自组织的。

803
00:39:23,785 --> 00:39:28,985
文件插入将会执行。

804
00:39:28,985 --> 00:39:32,155
它查询全局视图，

805
00:39:32,155 --> 00:39:36,545
并且它选择三到六个节点

806
00:39:36,545 --> 00:39:39,080
根据那个全局视图。

807
00:39:41,700 --> 00:39:45,110
那么一旦通知发出去之后，

808
00:39:45,110 --> 00:39:47,600
每个人都知道他们是下一个。

809
00:39:47,600 --> 00:39:50,695
复制那个文件或者复制该文件。

810
00:39:50,695 --> 00:39:53,020
在左下角，

811
00:39:53,020 --> 00:39:56,845
你会在列表和备份列表上看到。

812
00:39:56,845 --> 00:40:00,095
列表上已经有那个节点了。

813
00:40:00,095 --> 00:40:02,255
然后是备份列表。

814
00:40:02,255 --> 00:40:06,400
接下来应该进行复制的地方。

815
00:40:06,400 --> 00:40:10,540
这就是它在备份列表上的情况，并且它是

816
00:40:10,540 --> 00:40:12,635
这就是它在备份列表上的情况，并且它是备份列表中的第一个，

817
00:40:12,635 --> 00:40:15,045
开始从F复制文件，

818
00:40:15,045 --> 00:40:17,680
然后B接着做。

819
00:40:17,680 --> 00:40:19,600
然后最终，当

820
00:40:19,600 --> 00:40:21,275
三份副本被获得后，

821
00:40:21,275 --> 00:40:28,650
副本复制就会停止。

822
00:40:28,650 --> 00:40:31,420
如果一个节点崩溃了，

823
00:40:31,420 --> 00:40:33,960
其他一些节点可能会

824
00:40:33,960 --> 00:40:36,160
注意到一个节点已经失败，

825
00:40:36,160 --> 00:40:38,090
然后它可能会发送出去

826
00:40:38,090 --> 00:40:41,250
一个通知显示节点D已经失败。

827
00:40:41,250 --> 00:40:42,900
在那时候，

828
00:40:42,900 --> 00:40:44,620
再次，节点们是

829
00:40:44,620 --> 00:40:47,290
将要去控制台查看备份列表。

830
00:40:47,390 --> 00:40:49,570
节点G是

831
00:40:49,570 --> 00:40:51,280
所以是备份列表中的第一个

832
00:40:51,280 --> 00:40:53,849
它需要那五个副本

833
00:40:53,849 --> 00:40:55,270
在它自己的存储中，

834
00:40:55,270 --> 00:40:57,515
然后我们再次拥有，

835
00:40:57,515 --> 00:41:00,130
复制度为三。

836
00:41:01,320 --> 00:41:03,920
删除很简单。

837
00:41:03,920 --> 00:41:08,585
只有发布者可以

838
00:41:08,585 --> 00:41:10,205
从仓库中删除文件。

839
00:41:10,205 --> 00:41:12,620
它发送了一个命令

840
00:41:12,620 --> 00:41:15,395
向仓库发送了一条命令，说要删除这个文件，

841
00:41:15,395 --> 00:41:18,070
然后那条消息就发出去了。

842
00:41:18,070 --> 00:41:22,550
每个拥有那个文件的人都将其删除了。

843
00:41:23,070 --> 00:41:26,305
在NDN中，获取文件变得非常简单。

844
00:41:26,305 --> 00:41:29,050
您只需发送请求即可，如果

845
00:41:29,050 --> 00:41:30,580
该特定节点确实这样做了

846
00:41:30,580 --> 00:41:32,545
没有内容。

847
00:41:32,545 --> 00:41:34,785
当你谈论全球视角时，

848
00:41:34,785 --> 00:41:38,105
我们不是在谈论实际的数据，

849
00:41:38,105 --> 00:41:40,310
我们在谈论的是元数据。

850
00:41:40,310 --> 00:41:43,470
但实际数据，并不是所有节点都会

851
00:41:43,470 --> 00:41:46,145
并不是所有数据集都会相同。

852
00:41:46,145 --> 00:41:48,240
如果请求进入了F

853
00:41:48,240 --> 00:41:50,585
如果F中有数据，

854
00:41:50,585 --> 00:41:52,240
它会返回数据。

855
00:41:52,240 --> 00:41:53,870
但如果它没有的话，

856
00:41:53,870 --> 00:41:56,195
它会发送回一个转发提示

857
00:41:56,195 --> 00:41:58,535
向拥有数据的节点，

858
00:41:58,535 --> 00:42:00,805
然后应用程序根据那个提示进行操作

859
00:42:00,805 --> 00:42:03,580
并从另一个节点获取数据。

860
00:42:03,580 --> 00:42:09,185
在这个例子中，可能是D或者A，或者是B。

861
00:42:09,185 --> 00:42:11,320
>> 个人来说，我只是想给你

862
00:42:11,320 --> 00:42:12,605
还有一分钟的警告。

863
00:42:12,605 --> 00:42:13,925
我们快要结束了。

864
00:42:13,925 --> 00:42:16,460
是的，我快要结束了。谢谢。

865
00:42:17,220 --> 00:42:19,240
其他部分

866
00:42:19,240 --> 00:42:21,365
项目名为NR-archway，

867
00:42:21,365 --> 00:42:23,285
正如我之前提到的那样

868
00:42:23,285 --> 00:42:26,195
当前的文件，

869
00:42:26,195 --> 00:42:28,884
它们具有多样的名称、元数据标准。

870
00:42:28,884 --> 00:42:31,210
问题变成了它

871
00:42:31,210 --> 00:42:32,630
如果你找不到数据集，

872
00:42:32,630 --> 00:42:34,285
那么你就无法使用

873
00:42:34,285 --> 00:42:35,560
那么你就无法使用

874
00:42:35,560 --> 00:42:37,720
那么你就无法在科学工作流中使用它们。The archway acts as a gateway to all data.

875
00:42:37,720 --> 00:42:41,340
拱门充当了通往所有数据的门户。

876
00:42:41,340 --> 00:42:46,825
它根据需要转换为NDN数据。

877
00:42:46,825 --> 00:42:50,025
用户无需了解出版的具体细节。

878
00:42:50,025 --> 00:42:51,415
如果是通过NDN，

879
00:42:51,415 --> 00:42:52,955
如果是通过HTTP，

880
00:42:52,955 --> 00:42:57,610
如果是通过FTP、SFTP或其他方式。

881
00:42:57,990 --> 00:43:01,565
它是通过名称转换目录来实现的。

882
00:43:01,565 --> 00:43:02,700
然后创建

883
00:43:02,700 --> 00:43:03,750
一个界面用于

884
00:43:03,750 --> 00:43:08,425
HTTP或FTP现有的仓库。

885
00:43:08,425 --> 00:43:11,475
我们目前所假设的安全性，

886
00:43:11,475 --> 00:43:14,115
将会有一个中央信任锚点，

887
00:43:14,115 --> 00:43:15,870
网络运营中心

888
00:43:15,870 --> 00:43:16,890
将要发放

889
00:43:16,890 --> 00:43:18,360
即将发放给个人的证书

890
00:43:18,360 --> 00:43:20,245
节点和用户。

891
00:43:20,245 --> 00:43:22,975
那么一旦你有了属性

892
00:43:22,975 --> 00:43:24,320
和证书，

893
00:43:24,320 --> 00:43:26,855
然后你可以创建基于名称的

894
00:43:26,855 --> 00:43:30,280
传统的访问控制

895
00:43:30,280 --> 00:43:32,045
和基于属性的名称控制。

896
00:43:32,045 --> 00:43:34,320
基于属性的加密是我们将用于访问控制的一种方式。

897
00:43:34,320 --> 00:43:36,770
我们将用于访问控制。

898
00:43:36,770 --> 00:43:39,515
然后最后一个部分是测试。

899
00:43:39,515 --> 00:43:41,780
我们正在与Fabric合作，以

900
00:43:41,780 --> 00:43:44,465
部署在Fabric上。

901
00:43:44,465 --> 00:43:46,145
目标是要

902
00:43:46,145 --> 00:43:51,400
我们将在Fabric上使用Hydra，然后我们将

903
00:43:51,400 --> 00:43:56,255
有将要运行的工作流程，它们将会

904
00:43:56,255 --> 00:43:57,845
部署在不同的

905
00:43:57,845 --> 00:43:59,255
云计算平台上。

906
00:43:59,255 --> 00:44:00,450
它可以是AWS，

907
00:44:00,450 --> 00:44:02,675
它可以是PRP，

908
00:44:02,675 --> 00:44:04,360
太平洋研究平台

909
00:44:04,360 --> 00:44:06,300
, 开放科学网格。

910
00:44:06,300 --> 00:44:08,135
我们将要模拟

911
00:44:08,135 --> 00:44:11,360
10到1000个模拟用户从

912
00:44:11,360 --> 00:44:13,175
这些工作流程并获取

913
00:44:13,175 --> 00:44:15,020
这些数据从Hydra中获取。

914
00:44:15,020 --> 00:44:18,460
这样我们将真正感受到

915
00:44:18,460 --> 00:44:20,090
系统的运行情况

916
00:44:20,090 --> 00:44:21,950
如果我们需要进行任何优化，

917
00:44:21,950 --> 00:44:26,220
系统如何扩展等问题。

918
00:44:26,220 --> 00:44:29,755
总结一下，所以目前

919
00:44:29,755 --> 00:44:31,270
散乱的，且可发现性非常差。

920
00:44:31,270 --> 00:44:34,455
散乱的，且可发现性非常差。

921
00:44:34,455 --> 00:44:39,090
九头蛇试图解决这个问题。

922
00:44:39,090 --> 00:44:42,220
各个研究所都有存储设施。

923
00:44:42,220 --> 00:44:43,810
它们不足以满足

924
00:44:43,810 --> 00:44:46,725
they are not enough to satisfy everything that the scientists want to do.

925
00:44:46,725 --> 00:44:49,525
如果我们能将它们联合起来，

926
00:44:49,525 --> 00:44:52,705
它们可以支持大规模基因组学研究。

927
00:44:52,705 --> 00:44:54,505
并且目前的安全性

928
00:44:54,505 --> 00:44:55,780
难以配置。

929
00:44:55,780 --> 00:45:00,215
Hydra通过创建来解决所有这些问题

930
00:45:00,215 --> 00:45:02,145
一个松散耦合的

931
00:45:02,145 --> 00:45:06,370
自组织联邦存储系统。

932
00:45:06,650 --> 00:45:09,770
谢谢，我会接受

933
00:45:09,770 --> 00:45:13,025
如果你有任何问题，可以在Slack上提问。

934
00:45:13,025 --> 00:45:15,485
>> 谢谢，Susmit。为了节省时间，

935
00:45:15,485 --> 00:45:17,025
让我们将问题直接提给

936
00:45:17,025 --> 00:45:19,630
让我们将问题直接提给Slack，然后我们将转向下一位发言者。

937
00:45:19,630 --> 00:45:21,450
已经有一些了

938
00:45:21,450 --> 00:45:22,780
Slack讨论

939
00:45:22,780 --> 00:45:25,390
对于这篇特定的论文。

940
00:45:25,390 --> 00:45:29,469
我们下一位演讲者是来自加州大学洛杉矶分校的余天元。

941
00:45:29,469 --> 00:45:30,695
他是一名博士研究生，在

942
00:45:30,695 --> 00:45:32,710
他是一名博士研究生，在计算机科学系，在教授的指导下。

943
00:45:32,710 --> 00:45:34,600
在李壮教授的指导下。

944
00:45:34,600 --> 00:45:36,750
李壮教授。

945
00:45:36,750 --> 00:45:38,255
他的主要研究兴趣

946
00:45:38,255 --> 00:45:39,665
命名数据网络，

947
00:45:39,665 --> 00:45:41,195
物联网和网络安全。

948
00:45:41,195 --> 00:45:42,510
他也在为此做出贡献。

949
00:45:42,510 --> 00:45:43,995
NDN的发展，

950
00:45:43,995 --> 00:45:46,250
物联网和安全引导。

951
00:45:46,250 --> 00:45:47,470
我认为他要去的是

952
00:45:47,470 --> 00:45:48,420
我认为他要去的是今天要讨论的话题。The title of the talk is,

953
00:45:48,420 --> 00:45:49,510
The title of the talk is, ~!@#$%^&*()

954
00:45:49,510 --> 00:45:51,835
"引导远程NDN实体，

955
00:45:51,835 --> 00:45:53,560
利用现有的

956
00:45:53,560 --> 00:45:56,365
认证。谢谢。

957
00:45:56,365 --> 00:45:58,605
>> 人们能看到我的屏幕吗？

958
00:45:58,605 --> 00:45:59,860
>> 是的，我们能看到。

959
00:45:59,860 --> 00:46:02,990
>> 是的，谢谢你。大家好。

960
00:46:02,990 --> 00:46:05,710
很高兴来到NDN公司。

961
00:46:05,710 --> 00:46:07,260
今天，我的演讲

962
00:46:07,260 --> 00:46:08,845
我们将专注于我们如何能够

963
00:46:08,845 --> 00:46:11,640
引导远程以及相关实体。

964
00:46:11,640 --> 00:46:15,880
我们可以远距离遇见你的NDN邻居。

965
00:46:15,890 --> 00:46:19,985
我们知道NDN声称数据是安全的

966
00:46:19,985 --> 00:46:22,000
在网络中我们有

967
00:46:22,000 --> 00:46:24,615
生产者，我们有消费者。

968
00:46:24,615 --> 00:46:28,545
但是那些生产者和消费者需要

969
00:46:28,545 --> 00:46:29,855
一些自举程序

970
00:46:29,855 --> 00:46:33,150
为了确保通信的安全。

971
00:46:33,150 --> 00:46:35,325
我们知道生产者使用

972
00:46:35,325 --> 00:46:37,210
他们的私钥进行签名

973
00:46:37,210 --> 00:46:38,885
使用生产者的公钥来验证数据，消费者可以

974
00:46:38,885 --> 00:46:42,160
使用生产者的公钥来验证数据。

975
00:46:42,160 --> 00:46:44,750
但问题是，

976
00:46:44,750 --> 00:46:46,315
钥匙在哪里？

977
00:46:46,315 --> 00:46:48,030
有人必须进行配置

978
00:46:48,030 --> 00:46:50,929
因此，每个实体都需要获取这些密钥。

979
00:46:51,030 --> 00:46:54,660
these keys to authenticate their security credentials.

980
00:46:54,660 --> 00:46:56,415
他们的安全凭证

981
00:46:56,415 --> 00:46:59,535
从这个引导过程中。

982
00:46:59,535 --> 00:47:03,725
在我讲述我们如何能够获得

983
00:47:03,725 --> 00:47:06,245
那些安全凭证

984
00:47:06,245 --> 00:47:08,585
进入实体中，

985
00:47:08,585 --> 00:47:11,435
我想稍微回溯一下，谈谈

986
00:47:11,435 --> 00:47:13,060
我们将在这个过程中使用的术语是什么？

987
00:47:13,060 --> 00:47:15,625
我们将在这个过程中使用。

988
00:47:15,625 --> 00:47:19,155
我们仍然有这个NDN网络。

989
00:47:19,155 --> 00:47:23,375
那么我们说权威

990
00:47:23,375 --> 00:47:24,965
的网络系统

991
00:47:24,965 --> 00:47:26,920
并创建一个信任锚点，

992
00:47:26,920 --> 00:47:30,410
我们说T。这

993
00:47:30,410 --> 00:47:34,515
权威可以是现实世界中的权威，

994
00:47:34,515 --> 00:47:37,220
权威可以是

995
00:47:37,220 --> 00:47:40,685
一个组织或者智能家居或者

996
00:47:40,685 --> 00:47:42,905
正在进行的项目我们

997
00:47:42,905 --> 00:47:45,070
来自早先演示的内容

998
00:47:45,070 --> 00:47:47,210
就像mGuard和Hydra一样。

999
00:47:47,210 --> 00:47:50,585
那么所有的实体

1000
00:47:50,585 --> 00:47:52,120
在同一个信任锚下，

1001
00:47:52,120 --> 00:47:53,340
这意味着他们信任

1002
00:47:53,340 --> 00:47:56,135
同一个自签名证书。

1003
00:47:56,135 --> 00:48:00,095
实体中的成员可以创建一个信任区域。

1004
00:48:00,095 --> 00:48:03,515
然后这个信任锚点T的所有者，

1005
00:48:03,515 --> 00:48:04,950
我们将这称为

1006
00:48:04,950 --> 00:48:08,095
我们将这称为信任区域的控制器。Then with this terminology,

1007
00:48:08,095 --> 00:48:10,985
那么有了这个术语，

1008
00:48:10,985 --> 00:48:13,969
我们可以说是自举一个新实体。

1009
00:48:13,969 --> 00:48:16,110
E_new确实是在自举。

1010
00:48:16,110 --> 00:48:19,430
将这些E_new纳入这个信任区域。

1011
00:48:19,430 --> 00:48:21,570
这些E_new必须具备

1012
00:48:21,570 --> 00:48:23,440
一个它本身获得的名字

1013
00:48:23,440 --> 00:48:25,370
拥有或以其他方式被分配

1014
00:48:25,370 --> 00:48:27,510
被该控制器信任。

1015
00:48:27,510 --> 00:48:33,035
那么E_new必须有它的信任锚点，

1016
00:48:33,035 --> 00:48:35,020
那么T，以及

1017
00:48:35,020 --> 00:48:38,025
它自己的证书和信任策略。

1018
00:48:38,025 --> 00:48:40,070
我们将这个过程称为安全引导。

1019
00:48:40,070 --> 00:48:42,620
我们将这个过程称为安全引导。

1020
00:48:42,620 --> 00:48:44,890
在安全引导之后，我们

1021
00:48:44,890 --> 00:48:46,865
可以回答几个问题。

1022
00:48:46,865 --> 00:48:50,350
首先，对于我们的实体来说，你是谁？

1023
00:48:50,350 --> 00:48:52,210
这个实体将会有一个名字，

1024
00:48:52,210 --> 00:48:56,040
说斜杠爱丽丝斜杠灯。

1025
00:48:56,040 --> 00:48:59,680
然后我们可以拥有安全凭证来

1026
00:48:59,680 --> 00:49:03,375
证明这个爱丽丝灯的身份。

1027
00:49:03,375 --> 00:49:06,160
证明这个爱丽丝灯的身份。

1028
00:49:06,160 --> 00:49:07,475
知道该信任谁

1029
00:49:07,475 --> 00:49:09,810
在同一个信任锚下。

1030
00:49:10,490 --> 00:49:13,035
我们可以回答这些问题。

1031
00:49:13,035 --> 00:49:16,290
那么你们的交叉关系是什么？

1032
00:49:17,780 --> 00:49:21,705
但让我们想想我们如何~!@#$%^&*()

1033
00:49:21,705 --> 00:49:25,265
可以实际上实现这样一个过程。

1034
00:49:25,265 --> 00:49:28,100
需要遵循哪些必要步骤？

1035
00:49:28,100 --> 00:49:30,545
首先，我们有控制器。

1036
00:49:30,545 --> 00:49:32,335
以及这个领域中的E_new。

1037
00:49:32,335 --> 00:49:34,650
但实际上作为第一步

1038
00:49:34,650 --> 00:49:36,485
信任区域控制器

1039
00:49:36,485 --> 00:49:38,795
它需要对E_new进行身份验证。

1040
00:49:38,795 --> 00:49:40,310
它想要确保

1041
00:49:40,310 --> 00:49:43,855
远程优先级正在转换。

1042
00:49:43,855 --> 00:49:46,570
则使用E_new进行认证

1043
00:49:46,570 --> 00:49:49,219
信任区域控制器也是如此，

1044
00:49:49,219 --> 00:49:51,290
因为它想要接受

1045
00:49:51,290 --> 00:49:54,940
因为它想要接受那个控制器作为它的权威。After this mutual authentication achieved,

1046
00:49:55,320 --> 00:49:58,790
在实现了这种相互认证之后，

1047
00:49:58,790 --> 00:50:01,200
控制器可以安装

1048
00:50:01,200 --> 00:50:02,945
安全组件包括

1049
00:50:02,945 --> 00:50:04,875
包含证书，

1050
00:50:04,875 --> 00:50:06,485
信任策略和信任

1051
00:50:06,485 --> 00:50:09,340
锚定到这个 E_new 中。

1052
00:50:09,380 --> 00:50:12,890
鉴于这一重要过程，

1053
00:50:12,890 --> 00:50:16,215
在这个领域一定有一些研究工作。

1054
00:50:16,215 --> 00:50:20,225
在我们现有的作品中，我们有NDNCERT。

1055
00:50:20,225 --> 00:50:22,955
但NDNCERT只负责颁发证书，

1056
00:50:22,955 --> 00:50:25,465
离开认证方法，

1057
00:50:25,465 --> 00:50:27,350
离开认证方法，which is the first step as a need to be filled in.

1058
00:50:27,350 --> 00:50:29,775
作为需要填补的一项需求。

1059
00:50:29,775 --> 00:50:32,775
我们有这个以数据为中心的工具包，

1060
00:50:32,775 --> 00:50:34,645
缩写为DCT，

1061
00:50:34,645 --> 00:50:37,490
这个单元实际上是在纸上的，

1062
00:50:37,490 --> 00:50:40,775
它提供了命令行工具。

1063
00:50:40,775 --> 00:50:43,110
生成安全包

1064
00:50:43,110 --> 00:50:45,065
和用户为了

1065
00:50:45,065 --> 00:50:46,690
带外安装

1066
00:50:46,690 --> 00:50:49,080
将这个包装束集成到E_new中。

1067
00:50:49,080 --> 00:50:51,635
双方通过相互认证来完成。

1068
00:50:51,635 --> 00:50:53,885
这是某种类型的

1069
00:50:53,885 --> 00:50:57,750
本地物理连接环境。

1070
00:50:57,750 --> 00:51:00,220
但是，我们需要

1071
00:51:00,220 --> 00:51:02,690
解决一个新问题，

1072
00:51:02,690 --> 00:51:05,114
这就是远程引导。

1073
00:51:05,114 --> 00:51:07,000
我们也可以看到

1074
00:51:07,000 --> 00:51:08,710
从之前的演示来看，

1075
00:51:08,710 --> 00:51:10,290
这种远程引导是

1076
00:51:10,290 --> 00:51:13,170
也是九头蛇所需要的。

1077
00:51:16,910 --> 00:51:21,555
我们可以看到重要的部分

1078
00:51:21,555 --> 00:51:24,090
是相互认证。

1079
00:51:24,090 --> 00:51:26,340
是认证。

1080
00:51:26,340 --> 00:51:29,100
需要一些现有的事实来进行验证。

1081
00:51:29,100 --> 00:51:31,080
我们需要回答那些问题，

1082
00:51:31,080 --> 00:51:34,050
现有的事实是从哪里来的？

1083
00:51:34,050 --> 00:51:36,210
然而，答案取决于

1084
00:51:36,210 --> 00:51:38,789
在特定的使用案例场景中。

1085
00:51:38,789 --> 00:51:40,515
因此我们开发了

1086
00:51:40,515 --> 00:51:44,235
特定的安全引导过程

1087
00:51:44,235 --> 00:51:46,185
在这个远程案例中。

1088
00:51:46,185 --> 00:51:47,640
我们称这个E_new为

1089
00:51:47,640 --> 00:51:50,640
远程和可信控制器只能

1090
00:51:50,640 --> 00:51:52,770
the current unsecure TCP/IP connectivity.

1091
00:51:52,770 --> 00:51:56,595
当前不安全的TCP/IP连接。

1092
00:51:56,595 --> 00:51:57,930
然后我们将会进行

1093
00:51:57,930 --> 00:51:59,925
然后我们将会进行那个相互认证首先，

1094
00:51:59,925 --> 00:52:03,700
然后安装安全组件。

1095
00:52:07,120 --> 00:52:09,920
为了实现这种相互认证

1096
00:52:09,920 --> 00:52:12,500
在控制器和E_new之间，

1097
00:52:12,500 --> 00:52:15,235
首先看一下OPrah弧。

1098
00:52:15,235 --> 00:52:18,480
我们的控制器认证了E_new。

1099
00:52:18,480 --> 00:52:20,430
我正在查看交互作用

1100
00:52:20,430 --> 00:52:23,759
利用现有的身份验证解决方案。

1101
00:52:23,759 --> 00:52:25,350
幸运的是，有很多利用现有的身份验证解决方案来保护它们在当前互联网中的。

1102
00:52:25,350 --> 00:52:27,240
它们在当前互联网中。

1103
00:52:27,240 --> 00:52:29,850
我们有安全机构

1104
00:52:29,850 --> 00:52:31,410
颁发证书的相关问题

1105
00:52:31,410 --> 00:52:32,310
关于DNS名称，

1106
00:52:32,310 --> 00:52:35,380
然后我们还有DNSSEC

1107
00:52:35,990 --> 00:52:38,820
伴随着指法系统

1108
00:52:38,820 --> 00:52:41,865
提供对DNS名称的认证。

1109
00:52:41,865 --> 00:52:45,540
如果你是拥有密码的用户，

1110
00:52:45,540 --> 00:52:47,295
你可以使用一些技术

1111
00:52:47,295 --> 00:52:48,540
像单点登录

1112
00:52:48,540 --> 00:52:50,760
在...中认证自己

1113
00:52:50,760 --> 00:52:52,605
今天的网络系统。

1114
00:52:52,605 --> 00:52:55,050
现在让我们思考这里有

1115
00:52:55,050 --> 00:52:57,660
这样的认证系统在这里，

1116
00:52:57,660 --> 00:53:00,375
在当今的互联网中，这就是

1117
00:53:00,375 --> 00:53:03,780
认证系统进行身份验证

1118
00:53:03,780 --> 00:53:05,730
这是新遥控器。

1119
00:53:05,730 --> 00:53:08,685
那么如果是遥控器

1120
00:53:08,685 --> 00:53:11,609
询问了这个认证系统，

1121
00:53:11,609 --> 00:53:13,815
然后控制器可以推导出

1122
00:53:13,815 --> 00:53:16,650
通过这个远程E_new进行认证。

1123
00:53:16,650 --> 00:53:20,080
我们可以完成第一个OPrah弧段的工作。

1124
00:53:21,080 --> 00:53:24,855
假设E_new是NDN应用。

1125
00:53:24,855 --> 00:53:27,690
运行在远程主机H上，

1126
00:53:27,690 --> 00:53:30,660
然后CA进行认证

1127
00:53:30,660 --> 00:53:35,175
然后通过颁发SSL证书对这个远程主机进行认证。

1128
00:53:35,175 --> 00:53:38,440
接着是信任区域控制器

1129
00:53:40,970 --> 00:53:44,250
可以认证 E_new 的是

1130
00:53:44,250 --> 00:53:45,585
the NDN app is here, ~!@#$%^&*()

1131
00:53:45,585 --> 00:53:48,915
如果远程主机的DNS名称是

1132
00:53:48,915 --> 00:53:50,595
认证设备A

1133
00:53:50,595 --> 00:53:53,070
带有SSL证书。

1134
00:53:53,070 --> 00:53:55,860
然后我们就完成了OPrah弧线的部分，

1135
00:53:55,860 --> 00:53:57,360
但是关于那个

1136
00:53:57,360 --> 00:54:00,105
~!@#$%^&*()

1137
00:54:00,105 --> 00:54:02,770
新认证的控制器。

1138
00:54:03,050 --> 00:54:06,450
新认证的控制器可以放置

1139
00:54:06,450 --> 00:54:10,395
GitHub上的NDN应用实现代码

1140
00:54:10,395 --> 00:54:14,400
带有预嵌入的信任锚点应用程序。

1141
00:54:14,400 --> 00:54:16,815
然后有人说用户，

1142
00:54:16,815 --> 00:54:18,525
可以下载这段代码

1143
00:54:18,525 --> 00:54:22,305
从GitHub这样的来源下载，

1144
00:54:22,305 --> 00:54:26,595
然后对可信控制器进行身份验证

1145
00:54:26,595 --> 00:54:27,855
通过内置

1146
00:54:27,855 --> 00:54:29,354
在这次软件分发期间

1147
00:54:29,354 --> 00:54:32,260
在这次软件分发期间，我们将这个方向应用到Hydra，并嵌入了信任锚点。

1148
00:54:34,850 --> 00:54:41,265
我们将这个方向应用到Hydra。

1149
00:54:41,265 --> 00:54:42,930
您可以从之前看到

1150
00:54:42,930 --> 00:54:44,460
演示，在九头蛇，

1151
00:54:44,460 --> 00:54:46,320
不同组织所做的贡献

1152
00:54:46,320 --> 00:54:48,870
文件服务器并确保数据和

1153
00:54:48,870 --> 00:54:51,600
不同组织的用户需要

1154
00:54:51,600 --> 00:54:52,965
安装Hydra应用程序

1155
00:54:52,965 --> 00:54:55,005
或者他们贡献了一个文件服务器。

1156
00:54:55,005 --> 00:54:58,155
那么九头蛇网络运营中心

1157
00:54:58,155 --> 00:54:59,400
将作为

1158
00:54:59,400 --> 00:55:00,750
信任区域控制器

1159
00:55:00,750 --> 00:55:05,170
对于命名空间/海德拉。

1160
00:55:05,180 --> 00:55:07,605
我们可以在这里看到，

1161
00:55:07,605 --> 00:55:09,975
我们可以在这里看到，Hydra应用程序正在运行在

1162
00:55:09,975 --> 00:55:12,600
这些远程文件服务器需要

1163
00:55:12,600 --> 00:55:14,220
这些远程文件服务器需要认证作为安全引导的要求。

1164
00:55:14,220 --> 00:55:17,260
安全引导的要求。

1165
00:55:20,150 --> 00:55:23,535
我们有这个Hydra应用程序

1166
00:55:23,535 --> 00:55:25,375
运行在远程主机上，

1167
00:55:25,375 --> 00:55:28,520
这个远程主机拥有DNS名称，

1168
00:55:28,520 --> 00:55:33,320
这个远程主机的DNS名称是bruins.cs.ucla.edu，而且

1169
00:55:33,320 --> 00:55:36,620
加州大学洛杉矶分校的CA InCommon将进行身份验证

1170
00:55:36,620 --> 00:55:40,645
CA InCommon at the University of California, Los Angeles will perform identity authentication, 在这种情况下，我们可以通过颁发SSL证书来查看DNS名称。

1171
00:55:40,645 --> 00:55:43,310
在这种情况下，我们可以查看

1172
00:55:43,310 --> 00:55:48,305
这个IP的SSL证书工作正常，

1173
00:55:48,305 --> 00:55:50,630
可以用来启动Hydra应用的现有认证。

1174
00:55:50,630 --> 00:55:54,210
可以用于引导Hydra应用程序的启动。

1175
00:55:55,280 --> 00:55:58,664
我们也知道Incommon CA。

1176
00:55:58,664 --> 00:56:01,575
颁发了SSL证书给文件服务器，

1177
00:56:01,575 --> 00:56:07,050
则另一方面，Hydra NOC，

1178
00:56:07,050 --> 00:56:10,590
将会信任这个InCommon CA，

1179
00:56:10,590 --> 00:56:14,085
通过下载InCommon CA证书

1180
00:56:14,085 --> 00:56:17,860
从一个可信的网址下载。

1181
00:56:17,860 --> 00:56:22,310
然后 Hydra NOC 因此可以对所有进行身份验证

1182
00:56:22,310 --> 00:56:23,750
InCommon 认证

1183
00:56:23,750 --> 00:56:26,560
像Bruins这样的主机标识符。

1184
00:56:26,560 --> 00:56:29,085
因此，它可以进行身份验证

1185
00:56:29,085 --> 00:56:30,600
Hydra 应用实例

1186
00:56:30,600 --> 00:56:33,580
安装在这些远程主机上。

1187
00:56:34,580 --> 00:56:37,110
那么在反应的顺序上，

1188
00:56:37,110 --> 00:56:38,685
正如我们之前提到的，

1189
00:56:38,685 --> 00:56:40,515
Hydra应用程序将进行身份验证

1190
00:56:40,515 --> 00:56:41,910
Hydra网络运营中心位于

1191
00:56:41,910 --> 00:56:44,250
应用程序安装时间。

1192
00:56:44,250 --> 00:56:49,230
Hydra NOC 将信任锚

1193
00:56:49,230 --> 00:56:51,915
进入 Hydra 应用程序实现代码中，

1194
00:56:51,915 --> 00:56:54,795
和 Hydra 应用程序的用户，

1195
00:56:54,795 --> 00:56:58,020
将会下载这段代码与

1196
00:56:58,020 --> 00:57:00,315
预嵌入的信任锚点

1197
00:57:00,315 --> 00:57:02,970
和初始信任策略。

1198
00:57:02,970 --> 00:57:07,860
但是，用户已通过身份验证

1199
00:57:07,860 --> 00:57:09,780
应用程序包含违规内容，

1200
00:57:09,780 --> 00:57:13,770
但是，这个应用程序包

1201
00:57:13,770 --> 00:57:16,785
应该从传输源获取。

1202
00:57:16,785 --> 00:57:18,810
如果Hydra应用程序放置在~!@#$%^&*()

1203
00:57:18,810 --> 00:57:21,150
代码位于GitHub链接中，

1204
00:57:21,150 --> 00:57:24,090
然后用户说Alice必须获得

1205
00:57:24,090 --> 00:57:28,390
这个来自可信渠道的URL，

1206
00:57:29,090 --> 00:57:32,130
确保她是

1207
00:57:32,130 --> 00:57:34,690
获取正确的包裹。

1208
00:57:36,380 --> 00:57:39,540
现在我们有了双向认证，

1209
00:57:39,540 --> 00:57:41,040
完成了两个弧线，

1210
00:57:41,040 --> 00:57:42,720
让我们谈谈我们如何

1211
00:57:42,720 --> 00:57:44,954
可以安装这些设备组件。

1212
00:57:44,954 --> 00:57:46,725
在我们讨论之前

1213
00:57:46,725 --> 00:57:48,900
所有加密材料，例如

1214
00:57:48,900 --> 00:57:52,365
证书和永久性公钥，

1215
00:57:52,365 --> 00:57:55,035
这个NDN实体Hydra应用程序，

1216
00:57:55,035 --> 00:57:57,150
应该首先有一个标签。

1217
00:57:57,150 --> 00:57:59,325
在Hydra用例中，

1218
00:57:59,325 --> 00:58:00,900
这些E_new名称具有

1219
00:58:00,900 --> 00:58:03,794
应用程序前缀和唯一后缀。

1220
00:58:03,794 --> 00:58:05,490
应用程序前缀，

1221
00:58:05,490 --> 00:58:07,710
可以来源于信任锚点，

1222
00:58:07,710 --> 00:58:10,185
因为我们知道信任锚点

1224
00:58:12,645 --> 00:58:14,190
那么我们总是能够获得

1225
00:58:14,190 --> 00:58:16,350
它的应用前缀。

1226
00:58:16,350 --> 00:58:21,130
但这里的唯一后缀需要分配。

1227
00:58:23,060 --> 00:58:26,940
正在运行Hydra应用程序的远程主机，

1228
00:58:26,940 --> 00:58:28,110
已经有一个名称，

1229
00:58:28,110 --> 00:58:29,415
这是DNS名称。

1230
00:58:29,415 --> 00:58:31,215
但在这种情况下，

1231
00:58:31,215 --> 00:58:34,605
我们想要给这款Hydra应用起一个新名字，

1232
00:58:34,605 --> 00:58:38,290
我们想要给这款Hydra应用起一个新名字，它应该与Hydra的背景相符。

1233
00:58:38,360 --> 00:58:42,104
解决方案可能是之后的

1234
00:58:42,104 --> 00:58:45,195
我们应用这个应用程序前缀，

1235
00:58:45,195 --> 00:58:47,340
我们采用一个DNS名称来自

1236
00:58:47,340 --> 00:58:51,120
我们采用一个DNS名称来自远程主机作为后缀分配。

1237
00:58:51,120 --> 00:58:52,530
实体名称将会

1238
00:58:52,530 --> 00:59:00,090
实体名称将会是/hydra/bruins.cs.ucla.edu。

1239
00:59:00,090 --> 00:59:02,175
如果愿意，Alice仍然可以决定

1240
00:59:02,175 --> 00:59:03,960
适应九头蛇情境的新标识符。

1241
00:59:03,960 --> 00:59:06,730
适应九头蛇情境。

1242
00:59:08,360 --> 00:59:12,075
现在，我们拥有了相互认证，

1243
00:59:12,075 --> 00:59:13,650
我们拥有了信任锚

1244
00:59:13,650 --> 00:59:15,810
和已安装的相互信任策略，

1245
00:59:15,810 --> 00:59:19,860
我们通过采用DNS名称来获取名字。

1246
00:59:19,860 --> 00:59:22,800
和在后面追加一个a

1247
00:59:22,800 --> 00:59:24,330
应用程序前缀，它

1248
00:59:24,330 --> 00:59:26,055
来自信任锚点，

1249
00:59:26,055 --> 00:59:31,750
但现在我们仍然需要证书。

1250
00:59:34,000 --> 00:59:36,080
海德拉应用程序，

1251
00:59:36,080 --> 00:59:38,405
将使用NDNCERT协议

1252
00:59:38,405 --> 00:59:40,820
申请证书来自

1253
00:59:40,820 --> 00:59:43,430
海德拉NOC附带SSL证书

1254
00:59:43,430 --> 00:59:46,375
附带现有的认证。

1255
00:59:46,375 --> 00:59:49,229
那么Hydra NOC在接收到之后

1256
00:59:49,229 --> 00:59:53,235
证书请求，

1257
00:59:53,235 --> 00:59:56,055
将验证此SSL证书

1258
00:59:56,055 --> 00:59:59,445
与本地受信任的CA对照，例如InCommon，

1259
00:59:59,445 --> 01:00:01,410
如果海德拉NOC通过了。

1260
01:00:01,410 --> 01:00:06,150
那么如果验证成功，

1261
01:00:06,150 --> 01:00:07,470
它将颁发

1262
01:00:07,470 --> 01:00:09,690
它将颁发新证书给Hydra应用程序，

1263
01:00:09,690 --> 01:00:12,015
通过Hydra应用程序通过审核后，

1264
01:00:12,015 --> 01:00:14,295
新颁发的证书，

1265
01:00:14,295 --> 01:00:17,010
我们将不得不信任

1266
01:00:17,010 --> 01:00:18,390
锚点初始转移

1267
01:00:18,390 --> 01:00:20,685
那么所有的安全政策和证书。

1268
01:00:20,685 --> 01:00:23,805
policies and certificates, components are installed here.

1269
01:00:23,805 --> 01:00:26,890
组件在这里安装。

1270
01:00:28,430 --> 01:00:31,770
总结来说，这项工作采取了

1271
01:00:31,770 --> 01:00:34,035
迈出了第一步

1272
01:00:34,035 --> 01:00:36,825
引导远程NDN实体。

1273
01:00:36,825 --> 01:00:44,114
因为我们发现要将每个新实体NDN化，

1274
01:00:44,114 --> 01:00:46,245
我们应该配置名称，

1275
01:00:46,245 --> 01:00:47,835
信任锚证书，

1276
01:00:47,835 --> 01:00:49,845
和信任策略整合进去。

1277
01:00:49,845 --> 01:00:51,885
我们的设计利用了

1278
01:00:51,885 --> 01:00:54,540
现有的认证系统，它

1279
01:00:54,540 --> 01:00:56,875
现有的认证机构，

1280
01:00:56,875 --> 01:00:59,060
我们正在应用

1281
01:00:59,060 --> 01:01:00,830
解决这一问题的相同方法

1282
01:01:00,830 --> 01:01:03,245
远程实体认证问题

1283
01:01:03,245 --> 01:01:05,840
在使用像mGUARD这样的箭头，

1284
01:01:05,840 --> 01:01:07,520
和NDN AR

1285
01:01:07,520 --> 01:01:10,730
保护如昨天所呈现的。

1286
01:01:10,730 --> 01:01:13,490
谢谢聆听。就这些了。

1287
01:01:13,490 --> 01:01:15,680
我的演讲[噪音]。

1288
01:01:15,680 --> 01:01:17,030
>> 非常好。非常感谢你。

1289
01:01:17,030 --> 01:01:19,190
这实际上会给我们一个机会

1290
01:01:19,190 --> 01:01:20,795
这实际上会给我们一个机会，让我们稍微赶上一些时间。

1291
01:01:20,795 --> 01:01:24,425
我将所有的问题和讨论都指向

1292
01:01:24,425 --> 01:01:26,880
将其放松并翻转过来

1293
01:01:26,880 --> 01:01:29,565
向下一个小组的主持人表示感谢。

1294
01:01:29,565 --> 01:01:30,240
向下一个小组的主持人表示感谢。

1295
01:01:30,240 --> 01:01:32,740
这第一场会议的发言人。

1296
01:01:32,900 --> 01:01:35,670
>> 谢谢你，Jeff。Marie-Jose，你是

1297
01:01:35,670 --> 01:01:36,600
接下来，请继续。

1298
01:01:36,600 --> 01:02:00,655
~!@#$%^&*()

1299
01:02:00,655 --> 01:02:03,040
>> 嘿，欢迎大家。

1300
01:02:03,040 --> 01:02:07,070
这是面板号码2。

1301
01:02:07,290 --> 01:02:09,565
我是玛丽-乔泽·蒙佩蒂。

1302
01:02:09,565 --> 01:02:13,570
我是特聘教授，在

1303
01:02:13,570 --> 01:02:15,775
我是特聘教授，在蒙特利尔的康考迪亚大学，很荣幸主持这个小组讨论。

1304
01:02:15,775 --> 01:02:19,060
很荣幸主持这个小组讨论。

1305
01:02:19,060 --> 01:02:21,250
我们进行了讨论，

1306
01:02:21,250 --> 01:02:22,570
所以史密斯，洛夫蒂，

1307
01:02:22,570 --> 01:02:24,220
我对此略知一二。

1308
01:02:24,220 --> 01:02:28,480
我们将其称为超越NDN的NDN，并且我们认识到

1309
01:02:28,480 --> 01:02:36,115
即将到来的重要性

1310
01:02:36,115 --> 01:02:38,185
数据驱动的应用程序

1311
01:02:38,185 --> 01:02:39,940
和到处的服务。

1312
01:02:39,940 --> 01:02:41,830
我认为上一次会议

1313
01:02:41,830 --> 01:02:43,959
有明确的，

1314
01:02:43,959 --> 01:02:45,835
我会说这是NDN的一种看法。

1315
01:02:45,835 --> 01:02:49,630
但数据变得越来越重要

1316
01:02:49,630 --> 01:02:50,815
数据变得越来越重要，在物联网领域的网络研究尤其如此。

1317
01:02:50,815 --> 01:02:54,700
网络研究尤其是在物联网领域。

1318
01:02:54,700 --> 01:02:57,715
我们想把这当作一次对话来进行。

1319
01:02:57,715 --> 01:02:59,425
你会看到它并非如此

1320
01:02:59,425 --> 01:03:01,090
一个小组讨论的意义上

1321
01:03:01,090 --> 01:03:03,520
人们接着进行了陈述，然后

1322
01:03:03,520 --> 01:03:05,710
等待着问题的提出。

1323
01:03:05,710 --> 01:03:07,150
我们希望这将非常

1324
01:03:07,150 --> 01:03:08,950
互动。

1325
01:03:08,950 --> 01:03:10,360
小组成员之间

1326
01:03:10,360 --> 01:03:13,520
小组成员和观众。

1327
01:03:15,000 --> 01:03:18,760
一点背景。

1328
01:03:18,760 --> 01:03:21,955
我刚刚介绍了自己。

1329
01:03:21,955 --> 01:03:23,860
我认为小组讨论的嘉宾是

1330
01:03:23,860 --> 01:03:26,920
我认为小组讨论的嘉宾是一群参与度很高的优秀人士。

1331
01:03:26,920 --> 01:03:29,125
已经参与并且一直在参与

1332
01:03:29,125 --> 01:03:31,600
在NDN研究中和参与其中的人员

1333
01:03:31,600 --> 01:03:33,820
来自于新的但再次出现的

1334
01:03:33,820 --> 01:03:36,040
越来越多

1335
01:03:36,040 --> 01:03:41,540
数据驱动的网络研究倾向。

1336
01:03:41,580 --> 01:03:44,110
我不知道伊芙是否在线。

1337
01:03:44,110 --> 01:03:47,050
但实际上，伊芙说过

1338
01:03:47,050 --> 01:03:50,680
数据是研究的燃料

1339
01:03:50,680 --> 01:03:52,120
对于21世纪来说，

1340
01:03:52,120 --> 01:03:56,500
我认为她绝对正确。

1341
01:03:56,500 --> 01:03:58,690
大约在去年的这个时候

1342
01:03:58,690 --> 01:04:01,135
结束了整个春天

1343
01:04:01,135 --> 01:04:02,710
哥伦比亚大学，

1344
01:04:02,710 --> 01:04:07,390
我们连续两天跑了三次，

1345
01:04:07,390 --> 01:04:09,700
我们连续两天跑了三次，免费研讨会探讨未来的宽带研究和它

1346
01:04:09,700 --> 01:04:11,110
的宽带研究及其

1347
01:04:11,110 --> 01:04:14,110
涉及宽带研究的整体情况，包括技术、经济学、社会科学。

1348
01:04:14,110 --> 01:04:19,045
技术、经济学、社会科学。

1349
01:04:19,045 --> 01:04:21,520
有效地来说有

1350
01:04:21,520 --> 01:04:23,905
非常不同的结论。

1351
01:04:23,905 --> 01:04:26,500
但有一件事是每个人都~!@#$%^&*()

1352
01:04:26,500 --> 01:04:29,485
分享是获取的需求

1353
01:04:29,485 --> 01:04:32,290
更多数据以学习如何使用

1354
01:04:32,290 --> 01:04:35,740
更好地利用现有数据，

1355
01:04:35,740 --> 01:04:39,910
创造新的数据捕获方式，

1356
01:04:39,910 --> 01:04:42,565
发现它，分享它。

1357
01:04:42,565 --> 01:04:44,770
它确实是这样的，

1358
01:04:44,770 --> 01:04:47,139
数据驱动了技术领域的研究，

1359
01:04:47,139 --> 01:04:49,555
经济学和社会科学。

1360
01:04:49,555 --> 01:04:51,730
这就是这个面板~!@#$%^&*()

1361
01:04:51,730 --> 01:04:53,065
这是关于一点点，

1362
01:04:53,065 --> 01:04:55,150
数据驱动是什么，以及

1363
01:04:55,150 --> 01:04:57,280
我们将如何使用它。

1364
01:04:57,280 --> 01:05:00,025
我创建了一些问题。

1365
01:05:00,025 --> 01:05:01,060
我们将回到

1366
01:05:01,060 --> 01:05:03,700
我们将回到他们在报告之后的情况。

1367
01:05:03,700 --> 01:05:06,670
本质上，对于那些在

1368
01:05:06,670 --> 01:05:08,395
在小组讨论中以及观众当中，想一想。

1369
01:05:08,395 --> 01:05:10,150
在观众当中，想一想。

1370
01:05:10,150 --> 01:05:11,620
数据在你的研究工作中扮演什么角色？

1371
01:05:11,620 --> 01:05:13,705
as a description of your research work?

1372
01:05:13,705 --> 01:05:15,310
你会如何描述你的工作？

1373
01:05:15,310 --> 01:05:17,020
特别是在物联网领域，作为数据驱动？

1374
01:05:17,020 --> 01:05:18,970
特别是在物联网领域，

1375
01:05:18,970 --> 01:05:21,220
我目前工作的领域就是这里，

1376
01:05:21,220 --> 01:05:23,380
尽管是分布式系统，

1377
01:05:23,380 --> 01:05:24,070
有这样一个观点

1378
01:05:24,070 --> 01:05:26,590
的存储、查找、处理。

1379
01:05:26,590 --> 01:05:28,540
所有那些数据需要

1380
01:05:28,540 --> 01:05:30,520
特征和操作可能会有所不同，

1381
01:05:30,520 --> 01:05:32,065
可能会有所不同，

1382
01:05:32,065 --> 01:05:36,220
与各位嘉宾和在场的朋友们相比，可能会有所不同，the audience addressing this with

1383
01:05:36,220 --> 01:05:38,260
观众们正在用这种方式来讨论这个问题。

1384
01:05:38,260 --> 01:05:41,200
非NDN或NDN方法？

1385
01:05:41,200 --> 01:05:43,480
What would be the feature of ~!@#$%^&*()

1386
01:05:43,480 --> 01:05:45,040
更加以数据为中心的方法来

1387
01:05:45,040 --> 01:05:47,125
分布式系统或物联网，

1388
01:05:47,125 --> 01:05:49,060
分布式系统或物联网，NDN如何成为那个解决方案的一部分？我说完了。

1389
01:05:49,060 --> 01:05:51,430
那个解决方案？我说完了。

1390
01:05:51,430 --> 01:05:53,860
我会去问Dirk。

1391
01:05:53,860 --> 01:05:58,330
他必须在截止日期前提交几个

1392
01:05:58,330 --> 01:06:04,630
他的想法，然后我们会继续和Rute一起，

1393
01:06:04,630 --> 01:06:08,155
和接下来是Ike，

1394
01:06:08,155 --> 01:06:12,070
接下来是Srikathyayani，

1395
01:06:12,070 --> 01:06:13,555
从加利福尼亚关闭它。

1396
01:06:13,555 --> 01:06:15,740
我将停止分享。

1397
01:06:15,990 --> 01:06:19,460
Dirk，你可以开始分享了。

1398
01:06:31,320 --> 01:06:32,890
>> 你现在能听见我了吗？

1399
01:06:32,890 --> 01:06:38,120
[听不清楚]。你能听见我吗？

1400
01:06:41,940 --> 01:06:44,185
>> 我们听得很清楚。

1401
01:06:44,185 --> 01:06:46,165
>> 好的，很好，对不起。

1402
01:06:46,165 --> 01:06:49,130
我将在用户界面上使用一个标签。

1403
01:06:49,530 --> 01:06:51,280
谢谢，玛丽-约瑟。

1404
01:06:51,280 --> 01:06:54,285
谢谢你邀请我来这里。

1405
01:06:54,285 --> 01:06:57,870
我刚意识到这是我加入的第五个组织。

1406
01:06:57,870 --> 01:07:00,435
自从开始参与以来，

1407
01:07:00,435 --> 01:07:03,110
多年前的ICN研究。

1408
01:07:03,110 --> 01:07:05,290
它显示了我要么是多么的老，要么

1409
01:07:05,290 --> 01:07:07,105
它显示了我变换组织的速度有多快。

1410
01:07:07,105 --> 01:07:09,055
可能两者都有一点。

1411
01:07:09,055 --> 01:07:11,930
我回头看了一点，

1412
01:07:13,080 --> 01:07:16,330
从标题中你可以看出来，

1413
01:07:16,330 --> 01:07:18,490
给出的答案中

1414
01:07:18,490 --> 01:07:21,340
2009年关于网络的论文被命名为

1415
01:07:21,340 --> 01:07:22,900
内容并尝试理解

1416
01:07:22,900 --> 01:07:24,820
问题的真正内容是

1417
01:07:24,820 --> 01:07:26,410
问题的真正内容是，was and then trying to address some of your questions around data.

1418
01:07:26,410 --> 01:07:28,390
围绕数据的问题。

1419
01:07:28,390 --> 01:07:30,400
但我主要是从什么是的角度来看这个问题。

1420
01:07:30,400 --> 01:07:32,440
数据所占的重要性

1421
01:07:32,440 --> 01:07:34,600
构建和审视一些

1422
01:07:34,600 --> 01:07:38,450
我现在正在考察的方法。

1423
01:07:38,640 --> 01:07:42,835
哎呀，抱歉，

1424
01:07:42,835 --> 01:07:45,260
我想我按错了东西。

1425
01:07:47,700 --> 01:07:50,425
只要它

1426
01:07:50,425 --> 01:07:53,125
当我们开始的时候，并不完全是关于数据的，

1427
01:07:53,125 --> 01:07:56,200
当我们开始的时候，并不完全是关于数据的，was NDN already made with data in mind and if you look at data as facts,

1428
01:07:56,200 --> 01:07:59,170
如果你将数据视为事实，

1429
01:07:59,170 --> 01:08:01,810
用于计算的信息，

1430
01:08:01,810 --> 01:08:03,010
分析并融合某物

1431
01:08:03,010 --> 01:08:04,750
作为韦伯斯特的一个定义。

1432
01:08:04,750 --> 01:08:07,300
他们可能没有错。数据已经

1433
01:08:07,300 --> 01:08:08,530
一直是作为一部分

1434
01:08:08,530 --> 01:08:09,580
专注于最初的起点

1435
01:08:09,580 --> 01:08:10,390
有很多讨论

1436
01:08:10,390 --> 01:08:12,370
有关于什么特定的名字，

1437
01:08:12,370 --> 01:08:14,275
坚持下去，

1438
01:08:14,275 --> 01:08:16,060
正如论文标题所示

1439
01:08:16,060 --> 01:08:17,965
该内容正是被使用的内容。

1440
01:08:17,965 --> 01:08:19,645
数据也被使用了。

1441
01:08:19,645 --> 01:08:20,965
在非常早期，

1442
01:08:20,965 --> 01:08:23,590
我们在某个时候得到了信息，

1443
01:08:23,590 --> 01:08:25,870
我们得到了信息，这表明作为以信息为中心的网络(ICN)反映了

1444
01:08:25,870 --> 01:08:27,700
我们得到了信息，这表明作为以信息为中心的网络反映了，将信息作为某种不良事物来使用。

1445
01:08:27,700 --> 01:08:31,765
将信息作为某种不良事物来使用。

1446
01:08:31,765 --> 01:08:34,480
我开始寻找的事物

1447
01:08:34,480 --> 01:08:38,890
近期以来 probably

1448
01:08:38,890 --> 01:08:42,760
近两到三年来可能

1449
01:08:42,760 --> 01:08:45,010
是计算方面的

1450
01:08:45,010 --> 01:08:47,890
将这些方面稍微结合在一起

1451
01:08:47,890 --> 01:08:52,375
将数据转化并理解其含义。

1452
01:08:52,375 --> 01:08:54,190
也许将其转化为信息，

1453
01:08:54,190 --> 01:08:57,070
将其转化为关于某个主题的事实和细节

1454
01:08:57,070 --> 01:09:00,370
将其与某个主题联系起来。

1455
01:09:00,370 --> 01:09:01,600
也许那是最接近于

1456
01:09:01,600 --> 01:09:02,680
这真正意味着什么内容

1457
01:09:02,680 --> 01:09:05,770
这最初在论文中意味着什么，我不知道。

1458
01:09:05,770 --> 01:09:08,650
但这肯定是某件事情

1459
01:09:08,650 --> 01:09:12,055
在我目前进行的研究中

1460
01:09:12,055 --> 01:09:15,730
在我目前进行的研究中, 永久性地在数据之间移动

1461
01:09:15,730 --> 01:09:18,220
作为来自各种来源的数据

1462
01:09:18,220 --> 01:09:19,810
物联网是来自各种来源的数据之一。

1463
01:09:19,810 --> 01:09:21,280
其中一个例子。

1464
01:09:21,280 --> 01:09:24,400
但我们也在寻找并努力工作，例如

1465
01:09:24,400 --> 01:09:26,890
在分布式身份认证中

1466
01:09:26,890 --> 01:09:28,360
对于电子身份认证方法，

1467
01:09:28,360 --> 01:09:30,700
目前在欧洲这边，相当大。

1468
01:09:30,700 --> 01:09:33,640
~!@#$%^&*()

1469
01:09:33,640 --> 01:09:36,670
在有序的情况下尊重数字技术

1470
01:09:36,670 --> 01:09:38,470
提供一个身份

1471
01:09:38,470 --> 01:09:39,910
提供一个框架，它将会是

1472
01:09:39,910 --> 01:09:41,560
高度分布式

1473
01:09:41,560 --> 01:09:43,660
或许与其是集中式的，不如是分散式的？

1474
01:09:43,660 --> 01:09:45,370
这是另一组

1475
01:09:45,370 --> 01:09:47,890
有很多丰富的数据存在于外面

1476
01:09:47,890 --> 01:09:49,525
需要以某种方式结合起来

1477
01:09:49,525 --> 01:09:52,750
通过计算转化为有用的东西。

1478
01:09:52,750 --> 01:09:56,890
~!@#$%^&*()

1479
01:09:56,890 --> 01:10:01,240
范式的变化在于网络和

1480
01:10:01,240 --> 01:10:03,820
内容论文是假设

1481
01:10:03,820 --> 01:10:05,410
也许他们需要从~!@#$%^&*()

1482
01:10:05,410 --> 01:10:10,195
从哪里到什么地方。

1483
01:10:10,195 --> 01:10:12,400
那么也许这一切归根到底

1484
01:10:12,400 --> 01:10:14,440
那么也许这一切归根到底，对于这个名字的方面，像什么都可以命名。

1485
01:10:14,440 --> 01:10:16,450
像什么都可以命名。

1486
01:10:16,450 --> 01:10:18,865
它是一个光谱吗？

1487
01:10:18,865 --> 01:10:22,270
它是一个光谱吗？我们已经看到了各种各样的方法来处理数据计算信息。

1488
01:10:22,270 --> 01:10:24,430
我们已经看到了各种各样的方法

1489
01:10:24,430 --> 01:10:26,980
在使用NDN时，

1490
01:10:26,980 --> 01:10:29,710
ICN系统用于内容检索，

1491
01:10:29,710 --> 01:10:33,010
静态对象用于命名功能。

1492
01:10:33,010 --> 01:10:35,590
网络将其扩展到了计算领域，

1493
01:10:35,590 --> 01:10:38,620
so naming actually named functions of computation that could be used,

1494
01:10:38,620 --> 01:10:42,250
可以使用的计算，

1495
01:10:42,250 --> 01:10:45,595
或原始数据和物联网。

1496
01:10:45,595 --> 01:10:48,070
它是名字的中心性。

1497
01:10:48,070 --> 01:10:50,215
这最终真的到来了。

1498
01:10:50,215 --> 01:10:52,375
最终归结到我们真正想要做的事情。

1499
01:10:52,375 --> 01:10:54,985
在一个NDN系统或者一个ICN系统中。

1500
01:10:54,985 --> 01:10:58,000
但至少从三个方面来看

1501
01:10:58,000 --> 01:11:00,080
我放在左边了。

1502
01:11:00,920 --> 01:11:04,110
我认为我们一直在问的问题是

1503
01:11:04,110 --> 01:11:05,910
我们在研究过程中一直在问的问题是

1504
01:11:05,910 --> 01:11:08,070
多年的数据和~!@#$%^&*()

1505
01:11:08,070 --> 01:11:09,660
信息检索架构确实如此

1506
01:11:09,660 --> 01:11:10,740
确实是计算方面的佼佼者。

1507
01:11:10,740 --> 01:11:12,400
确实是我已经玩弄了很长时间的东西。

1508
01:11:12,400 --> 01:11:14,710
确实是我已经玩弄了很长时间的东西。

1509
01:11:14,710 --> 01:11:16,960
流动平衡是...

1510
01:11:16,960 --> 01:11:18,610
它是关键方面之一

1511
01:11:18,610 --> 01:11:20,185
在NDN架构中，

1512
01:11:20,185 --> 01:11:22,495
自然界中的某物

1513
01:11:22,495 --> 01:11:25,930
映射到计算交互上。

1514
01:11:25,930 --> 01:11:28,300
可以通过计算来解决

1515
01:11:28,300 --> 01:11:30,385
支持信息的可读性，

1516
01:11:30,385 --> 01:11:31,090
例如，

1517
01:11:31,090 --> 01:11:32,590
这是对一些过去的回忆

1518
01:11:32,590 --> 01:11:34,960
我们多年前进行的讨论围绕着

1519
01:11:34,960 --> 01:11:37,150
通道语义即拥有个体信息检索语义。

1520
01:11:37,150 --> 01:11:39,115
个体信息检索语义

1521
01:11:39,115 --> 01:11:41,470
我们天生就有这种能力。

1522
01:11:41,470 --> 01:11:45,100
计算中的另一个问题是

1523
01:11:45,100 --> 01:11:48,750
一直让我很忙

1524
01:11:48,750 --> 01:11:51,375
如何支持电脑亲和性？

1525
01:11:51,375 --> 01:11:55,020
如果数据接着是

1526
01:11:55,020 --> 01:11:56,520
只需要被

1527
01:11:56,520 --> 01:11:58,910
是否需要从同一实体中检索？

1528
01:11:58,910 --> 01:12:01,059
应用状态和计算

1529
01:12:01,059 --> 01:12:02,455
或者是突然想到的事情

1530
01:12:02,455 --> 01:12:05,740
我可能会在一个数据源结束，

1531
01:12:05,740 --> 01:12:07,600
但对于后续操作

1532
01:12:07,600 --> 01:12:09,280
我可能需要回到数据源。

1533
01:12:09,280 --> 01:12:11,155
我不能转向另一个数据源。

1534
01:12:11,155 --> 01:12:13,600
因为数据本质上是

1535
01:12:13,600 --> 01:12:16,390
相互关联，因此将会

1536
01:12:16,390 --> 01:12:19,450
需要从同一个来源提取。

1537
01:12:19,450 --> 01:12:22,000
The word for that comes from the same source. Up is the affinity part and I know that.

1538
01:12:22,000 --> 01:12:25,120
上面是亲和部分，我知道。

1539
01:12:25,120 --> 01:12:29,530
有朝一日关于我们计算的论文

1540
01:12:29,530 --> 01:12:30,850
我一直在谈论的ICN

1541
01:12:30,850 --> 01:12:32,545
亲和力问题也是如此。

1542
01:12:32,545 --> 01:12:33,850
这些是一些

1543
01:12:33,850 --> 01:12:36,790
转来转去试图

1544
01:12:36,790 --> 01:12:40,180
转来转去试图看看这些概念如何汇聚在一起，以及它们如何

1545
01:12:40,180 --> 01:12:41,470
they be applied within the context of ICN systems in general and the NDN,

1546
01:12:41,470 --> 01:12:43,780
通常情况下的ICN系统以及NDN，

1547
01:12:43,780 --> 01:12:45,710
尤其是支持

1548
01:12:45,710 --> 01:12:49,095
混合了所有这些数据，

1549
01:12:49,095 --> 01:12:50,895
计算和信息，

1550
01:12:50,895 --> 01:12:53,175
和我们如何能够使用这些架构来妥善支持它们所有

1551
01:12:53,175 --> 01:12:55,140
来妥善支持它们所有

1552
01:12:55,140 --> 01:12:57,150
以及我们如何构建不仅仅是数据系统，

1553
01:12:57,150 --> 01:12:58,980
但构建了计算系统

1554
01:12:58,980 --> 01:12:59,700
~!@#$%^&*()

1555
01:12:59,700 --> 01:13:01,715
分布式方式得当吗？

1556
01:13:01,715 --> 01:13:03,310
希望这能帮助我们达到

1557
01:13:03,310 --> 01:13:04,570
希望这能帮助我们达到几次讨论。As Marie-Jose said,

1558
01:13:04,570 --> 01:13:06,025
正如玛丽-乔泽所说，

1559
01:13:06,025 --> 01:13:07,735
我们想要进行一次对话。

1560
01:13:07,735 --> 01:13:09,745
我没有特别好的答案。

1561
01:13:09,745 --> 01:13:10,870
我只是想说出来

1562
01:13:10,870 --> 01:13:12,865
一些问题。谢谢。

1563
01:13:12,865 --> 01:13:17,320
>> 非常感谢。Rute是

1564
01:13:17,320 --> 01:13:19,735
无法立即沟通。

1565
01:13:19,735 --> 01:13:22,190
无法立即沟通。

1566
01:13:23,140 --> 01:13:25,400
>> 是的，终于。

1567
01:13:25,400 --> 01:13:26,600
[笑声]

1568
01:13:26,600 --> 01:13:26,601
~!@#$%^&*()

1569
01:13:26,601 --> 01:13:30,320
>> 对不起，我来晚了一点。

1570
01:13:30,320 --> 01:13:32,145
让我分享幻灯片。

1571
01:13:32,145 --> 01:13:36,665
是的，你是下一个，我现在意识到了，

1572
01:13:36,665 --> 01:13:37,990
我们有四分之三

1573
01:13:37,990 --> 01:13:40,185
来自德国的小组成员。

1574
01:13:40,185 --> 01:13:43,250
这只是，我不

1575
01:13:43,250 --> 01:13:45,290
知道对我来说，但无论如何，

1576
01:13:45,290 --> 01:13:50,850
它在运行。继续吧，Rute。

1577
01:13:52,240 --> 01:13:55,060
>> 你能看到我的幻灯片吗？

1578
01:13:55,060 --> 01:13:57,855
是的，但是你应该全屏显示。

1579
01:13:57,855 --> 01:14:00,810
现在很完美，谢谢你。

1580
01:14:01,410 --> 01:14:05,210
>> 首先，大家好。

1581
01:14:05,350 --> 01:14:09,270
I've been working in the NDN for ~!@#$%^&*()

1582
01:14:09,270 --> 01:14:14,475
也许现在已经有十年左右了我已经

1583
01:14:14,475 --> 01:14:16,215
转通过了附属关系或

1584
01:14:16,215 --> 01:14:17,540
通过了之前的附属关系和

1585
01:14:17,540 --> 01:14:19,250
我主要从事过~!@#$%^&*()

1586
01:14:19,250 --> 01:14:20,900
NDN在此背景下

1587
01:14:20,900 --> 01:14:22,760
机会路由在

1588
01:14:22,760 --> 01:14:26,120
无线环境中并且当前

1589
01:14:26,120 --> 01:14:29,385
在40秒内我们当然是，

1590
01:14:29,385 --> 01:14:31,760
在设备到设备之间更多地使用NDN

1591
01:14:31,760 --> 01:14:32,630
通信等方面

1592
01:14:32,630 --> 01:14:34,455
特别是在去中心化方面。

1593
01:14:34,455 --> 01:14:37,050
故意订阅环境

1594
01:14:37,050 --> 01:14:40,725
在制造领域内。

1595
01:14:40,725 --> 01:14:42,350
在我的幻灯片上我将要

1597
01:14:43,460 --> 01:14:44,720
这给了你一点点

1598
01:14:44,720 --> 01:14:46,665
这给了你更多关于这个的信息，

1599
01:14:46,665 --> 01:14:48,930
所以在这张幻灯片上，

1600
01:14:48,930 --> 01:14:50,510
您看我们所在的位置，

1601
01:14:50,510 --> 01:14:52,355
我们希望应用NDN的地方。

1602
01:14:52,355 --> 01:14:56,075
从端到端的角度来看，

1603
01:14:56,075 --> 01:14:58,070
在制造领域方面，

1604
01:14:58,070 --> 01:15:00,905
我们在左手边有

1605
01:15:00,905 --> 01:15:03,590
不同类型的设备。

1606
01:15:03,590 --> 01:15:07,085
有些设备可以说是支持IP的，

1607
01:15:07,085 --> 01:15:12,035
或者它们已经具备了一些语义能力。

1608
01:15:12,035 --> 01:15:15,020
被自动发现

1609
01:15:15,020 --> 01:15:17,450
或连接到一个端到端的物联网系统，

1610
01:15:17,450 --> 01:15:20,180
但其他的，旧设备通常会这样。

1611
01:15:20,180 --> 01:15:21,425
But as for other things, old equipment usually behaves like this. The old robot they...

1612
01:15:21,425 --> 01:15:24,185
遗留下的老旧机器人他们

1613
01:15:24,185 --> 01:15:27,200
不要，而且据你可能知道的，

1614
01:15:27,200 --> 01:15:30,290
在这些环境中使用的是。

1615
01:15:30,290 --> 01:15:34,210
designed for use in these environments, 或者提供一些广泛的安全性，

1616
01:15:34,210 --> 01:15:38,030
或者提供一些广泛的安全性，

1617
01:15:38,030 --> 01:15:39,420
所以从这个意义上讲，

1618
01:15:39,420 --> 01:15:42,780
他们创造了一个封闭的环境，

1619
01:15:42,780 --> 01:15:44,150
所以那是其中一个方面。

1620
01:15:44,150 --> 01:15:45,740
第二个方面当然是，

1621
01:15:45,740 --> 01:15:48,380
我们拥有关键应用程序，

1622
01:15:48,380 --> 01:15:51,015
我们需要严密的控制循环。

1623
01:15:51,015 --> 01:15:53,090
和这些协议已经

1624
01:15:53,090 --> 01:15:56,120
已经被开发出来以支持这一点，

1625
01:15:56,120 --> 01:15:58,100
但是，然而，其中一个问题是

1626
01:15:58,100 --> 01:16:00,440
正在发生的当然是，

1627
01:16:00,440 --> 01:16:01,460
这些环境正在

1628
01:16:01,460 --> 01:16:03,980
正在改变，而且沟通

1629
01:16:03,980 --> 01:16:05,475
是通常然后在

1630
01:16:05,475 --> 01:16:08,000
一种非常简单的方式，仅仅用来提取一些数据，

1631
01:16:08,000 --> 01:16:09,530
但不是我们在工业环境中拥有的应用程序。

1632
01:16:09,530 --> 01:16:11,990
我们在工业环境中拥有的。

1633
01:16:11,990 --> 01:16:14,450
他们正变得更加依赖数据驱动，

1634
01:16:14,450 --> 01:16:18,735
他们需要一些更聪明的方法

1635
01:16:18,735 --> 01:16:21,345
以去中心化的方式交换数据，

1636
01:16:21,345 --> 01:16:23,445
但也以一种方式

1637
01:16:23,445 --> 01:16:25,545
可以满足要求，以便

1638
01:16:25,545 --> 01:16:26,915
可以满足要求的时间模型，以便联网部分提供，

1639
01:16:26,915 --> 01:16:30,210
联网部分提供，

1640
01:16:30,210 --> 01:16:32,595
关键基础设施的设置。

1641
01:16:32,595 --> 01:16:35,615
我们想要探索的事情之一是在最后因为

1642
01:16:35,615 --> 01:16:38,330
我们想要探索的事情之一是在最后因为

1643
01:16:38,330 --> 01:16:39,680
当然在那里我们没有

1644
01:16:39,680 --> 01:16:41,620
我们因此想要解决Ip的问题，所以我们想要

1645
01:16:41,620 --> 01:16:43,140
探索最终的对抗

1646
01:16:43,140 --> 01:16:45,590
其他一些方法包括

1647
01:16:45,590 --> 01:16:48,200
作为OPC方式或MQTT。

1648
01:16:48,200 --> 01:16:51,320
当然有所不同，

1649
01:16:51,320 --> 01:16:53,210
显而易见的好处，

1650
01:16:53,210 --> 01:16:55,130
但也存在着

1651
01:16:55,130 --> 01:16:57,065
解释了一些挑战。

1652
01:16:57,065 --> 01:16:59,150
第一个，可能是

1653
01:16:59,150 --> 01:17:01,280
当前阶段不是关键的在

1654
01:17:01,280 --> 01:17:03,440
制造领域相关联的

1655
01:17:03,440 --> 01:17:04,790
流动性，尤其是

1656
01:17:04,790 --> 01:17:06,905
生产者的流动性。

1657
01:17:06,905 --> 01:17:08,570
即使这不是关键的，

1658
01:17:08,570 --> 01:17:10,550
事实上，这必须得到解决，而且还有

1659
01:17:10,550 --> 01:17:11,750
必须得到解决，而且还有

1660
01:17:11,750 --> 01:17:13,065
必须得到解决，而且还有环境在哪里当然，我们有移动机器人和

1661
01:17:13,065 --> 01:17:15,260
我们有移动机器人和

1662
01:17:15,260 --> 01:17:19,205
我们还有自动引导车等移动设备。

1663
01:17:19,205 --> 01:17:21,755
有这个会很有帮助

1664
01:17:21,755 --> 01:17:23,015
去中心化的

1665
01:17:23,015 --> 01:17:25,250
通信方式将会

1666
01:17:25,250 --> 01:17:26,860
允许这些设备交换

1667
01:17:26,860 --> 01:17:29,200
数据直接在它们之间交换。

1668
01:17:29,200 --> 01:17:30,440
但当然，再次强调，这并不是

1669
01:17:30,440 --> 01:17:32,990
一个关键方面，还有

1670
01:17:32,990 --> 01:17:34,580
几种已经被发展出来的机制

1671
01:17:34,580 --> 01:17:38,220
基于锚点等已经开发出的机制。

1672
01:17:38,220 --> 01:17:40,100
我们还可以做其他事情。

1673
01:17:40,100 --> 01:17:43,160
整合移动性抑制机制

1674
01:17:43,160 --> 01:17:44,335
整合机器学习以

1675
01:17:44,335 --> 01:17:46,475
改善机动性等。

1676
01:17:46,475 --> 01:17:47,930
我会说这不是

1677
01:17:47,930 --> 01:17:49,295
我会说这不是真的一个关键挑战，but however, it's something

1678
01:17:49,295 --> 01:17:51,680
但无论如何，这还是个问题。

1679
01:17:51,680 --> 01:17:54,720
在未来将不得不处理的问题。

1680
01:17:54,720 --> 01:17:57,435
其他更为重要的叙述。

1681
01:17:57,435 --> 01:17:59,300
相关的语境中

1682
01:17:59,300 --> 01:18:00,320
的这些工业需求

1683
01:18:00,320 --> 01:18:03,255
与命名部分相关，所以NDN

1684
01:18:03,255 --> 01:18:04,970
拥有非常丰富的表现力

1685
01:18:04,970 --> 01:18:06,995
拥有相当灵活的命名空间。

1686
01:18:06,995 --> 01:18:10,040
但我们目前处理它的方式

1687
01:18:10,040 --> 01:18:11,450
意味着在应用时

1688
01:18:11,450 --> 01:18:12,945
将其应用于工业领域，

1689
01:18:12,945 --> 01:18:16,160
我们将再次创造，

1690
01:18:16,160 --> 01:18:18,645
我们所面临的同一个问题在于

1691
01:18:18,645 --> 01:18:20,985
我们所面临的同一个问题在于，语义描述的~!@#$%^&*() machines not just have sensors,

1692
01:18:20,985 --> 01:18:23,149
机器不仅仅是有传感器，

1693
01:18:23,149 --> 01:18:25,240
基本上是将其绑定到

1694
01:18:25,240 --> 01:18:28,955
一个协议或调用架构。

1695
01:18:28,955 --> 01:18:32,270
在那里我们可以做不同的事情。

1696
01:18:32,270 --> 01:18:33,770
我们可以进行翻译工作。

1697
01:18:33,770 --> 01:18:35,790
我会说那将是第一阶段。

1698
01:18:35,790 --> 01:18:41,375
但当然，我们也需要向前看。

1699
01:18:41,375 --> 01:18:43,925
那么对于这些环境来说，当然，

1700
01:18:43,925 --> 01:18:45,050
这些环境还存在一个问题，当然，the pool variance model that NDNs of course,

1701
01:18:45,050 --> 01:18:49,160
这些环境还存在一个问题，当然，NDNs的池变异模型，

1702
01:18:49,160 --> 01:18:51,500
我们也有可能

1703
01:18:51,500 --> 01:18:53,825
的支持是基于推送的沟通方式，

1704
01:18:53,825 --> 01:18:56,110
但它们将不得不进行调整以适应

1705
01:18:56,110 --> 01:18:58,370
服务于物联网的需求再次，

1706
01:18:58,370 --> 01:18:59,870
在这里我们有非常严格和苛刻的要求

1707
01:18:59,870 --> 01:19:01,970
严格和关键的要求

1708
01:19:01,970 --> 01:19:04,710
像延迟时间低于一毫秒的严格限制。

1709
01:19:04,710 --> 01:19:06,365
更有趣的是，

1710
01:19:06,365 --> 01:19:08,180
至少在我们所做的方面来说，是什么能力

1711
01:19:08,180 --> 01:19:09,675
to do centralized synchronization.

1712
01:19:09,675 --> 01:19:13,715
进行集中式同步。

1713
01:19:13,715 --> 01:19:16,740
多方数据同步。

1714
01:19:18,070 --> 01:19:22,100
我们有几种可用的选项，例如

1715
01:19:22,100 --> 01:19:24,095
矢量同步或冠状同步

1716
01:19:24,095 --> 01:19:26,810
这确实很有趣。

1717
01:19:26,810 --> 01:19:28,670
只是稍微解释一下

1718
01:19:28,670 --> 01:19:30,620
我们现在正在尝试做的事情。

1719
01:19:30,620 --> 01:19:33,285
在一个实时的环境中，

1720
01:19:33,285 --> 01:19:37,070
我们目前基本上是重新开始，

1721
01:19:37,070 --> 01:19:39,380
我们目前基本上是重新开始，所以尝试着做准备，and to propose adaptations.

1722
01:19:39,380 --> 01:19:42,345
并提出适应性调整。

1723
01:19:42,345 --> 01:19:44,265
当一切结束时，那又如何？

1724
01:19:44,265 --> 01:19:45,900
你在左手边有的是

1725
01:19:45,900 --> 01:19:49,670
基本上是我们想去的地方的一个例子。

1726
01:19:49,670 --> 01:19:51,110
所以我们有自动引导车(AGV)的地方是

1727
01:19:51,110 --> 01:19:53,265
直接相互通信。

1728
01:19:53,265 --> 01:19:55,520
但也对接货站，

1729
01:19:55,520 --> 01:19:58,370
我们可以说是对任务服务器而言，

1730
01:19:58,370 --> 01:19:59,840
我们正在做的就是位于右手边。

1731
01:19:59,840 --> 01:20:02,105
我们目前正在做的就是测试这个。

1732
01:20:02,105 --> 01:20:05,235
我们想要了解的不是

1733
01:20:05,235 --> 01:20:07,310
我们想要了解的不是just a course to look comparison against MQTT or a broker approach.

1734
01:20:07,310 --> 01:20:10,020
对比MQTT或经纪人方法。

1735
01:20:10,020 --> 01:20:11,950
我们想要做得更进一步。

1736
01:20:11,950 --> 01:20:13,670
我们实际上想要将它与~!@#$%^&*()比较

1737
01:20:13,670 --> 01:20:16,250
我们实际上想要将它与~!@#$%^&*()比较, the **** so the approach of OPC way, which is based on multicast and

1738
01:20:16,250 --> 01:20:18,470
它基于多播和

1739
01:20:18,470 --> 01:20:21,780
也尽力去说服，

1740
01:20:21,780 --> 01:20:24,900
让我们说，工业

1741
01:20:24,900 --> 01:20:27,700
物联网领域中的NDN人员

1742
01:20:27,700 --> 01:20:29,620
绝对是这样，例如供应商们，

1743
01:20:29,620 --> 01:20:33,725
NDN绝对是应该被考虑支持这种去中心化的方法

1744
01:20:33,725 --> 01:20:37,290
应该被考虑支持这种去中心化

1745
01:20:37,290 --> 01:20:39,335
在车间地板上。

1746
01:20:39,335 --> 01:20:42,540
这是我的最后一张幻灯片。谢谢。

1747
01:20:45,990 --> 01:20:47,750
>> 非常感谢。

1748
01:20:47,750 --> 01:20:49,070
非常感谢您的体谅。

1749
01:20:49,070 --> 01:20:51,935
在您旅行的时候，您提出了这个问题。

1750
01:20:51,935 --> 01:20:55,385
我认为你提出了许多

1751
01:20:55,385 --> 01:20:57,530
重要的问题，我们将要

1752
01:20:57,530 --> 01:20:59,620
重要的问题，我们将要回到我认为，在NDN和数据中心研究方面

1753
01:20:59,620 --> 01:21:02,750
NDN和面向数据中心的研究在

1754
01:21:02,750 --> 01:21:07,145
总的来说，这是边缘的崛起，

1755
01:21:07,145 --> 01:21:11,615
边缘网络、边缘计算，

1756
01:21:11,615 --> 01:21:15,645
在本质上是工业物联网(IIoT)以及它所在的领域

1757
01:21:15,645 --> 01:21:17,295
可能有很多

1758
01:21:17,295 --> 01:21:19,665
可能有很多机会，我们已经看到了这一点。

1759
01:21:19,665 --> 01:21:22,200
这实际上是一个完美的过渡，进入下一个话题，

1760
01:21:22,200 --> 01:21:25,110
我知道Ike将要讨论的内容。

1761
01:21:25,110 --> 01:21:28,030
Ike，请开始报告。

1762
01:21:28,030 --> 01:21:28,040
~!@#$%^&*()

1763
01:21:28,040 --> 01:21:33,815
>> 嗨，大家好。

1764
01:21:33,815 --> 01:21:36,990
让我也快速地

1765
01:21:38,590 --> 01:21:44,010
看看现在应该分享哪个屏幕。

1766
01:21:44,940 --> 01:21:49,010
那应该是错的，我猜。

1767
01:21:49,180 --> 01:21:53,130
那我们试试另一个吧。

1768
01:22:00,850 --> 01:22:04,635
现在你应该看到正确的屏幕了。

1769
01:22:04,635 --> 01:22:06,875
大家好。

1770
01:22:06,875 --> 01:22:09,625
非常感谢你的介绍

1771
01:22:09,625 --> 01:22:12,665
和邀请，Marie-Jose。

1772
01:22:12,665 --> 01:22:15,120
我想我是其中一个人

1773
01:22:15,120 --> 01:22:17,360
没有直接参与其中的

1774
01:22:17,360 --> 01:22:19,305
没有直接参与其中的，因为根据我的背景，我是

1775
01:22:19,305 --> 01:22:22,695
没有直接参与其中的，因为根据我的背景，我是rather working on computing and the network only right now.

1776
01:22:22,695 --> 01:22:24,555
并且目前仅专注于计算和网络。

1777
01:22:24,555 --> 01:22:27,380
我是Ike Kunze，我是德国RWTH亚琛工业大学的博士研究生。

1778
01:22:27,380 --> 01:22:31,025
德国亚琛工业大学。

1779
01:22:31,025 --> 01:22:33,915
我今天想做的是

1780
01:22:33,915 --> 01:22:36,645
提供一个关于这些话题的外部视角。

1781
01:22:36,645 --> 01:22:41,765
我对NDN之类的东西相当熟悉。

1782
01:22:41,765 --> 01:22:45,635
但是，我不是

1783
01:22:45,635 --> 01:22:49,280
积极地研究这个话题以及什么

1784
01:22:49,280 --> 01:22:52,530
我想在这里做的基本上是给你

1785
01:22:52,530 --> 01:22:56,705
我目前的工作，我正在做的事情。

1786
01:22:56,705 --> 01:22:59,000
我正在参与一个德国研究项目。

1787
01:22:59,000 --> 01:23:00,320
该项目专注于引进

1788
01:23:00,320 --> 01:23:01,610
互联网技术以

1789
01:23:01,610 --> 01:23:03,710
工业网络，但与此相当类似

1790
01:23:03,710 --> 01:23:07,475
我们在Rute之前的演讲中所见到的内容。

1791
01:23:07,475 --> 01:23:09,980
实际上，我认为有一张幻灯片确实是

1792
01:23:09,980 --> 01:23:12,860
实际上，我认为有一张幻灯片确实是类似于我马上要展示给你们看的。

1793
01:23:12,860 --> 01:23:15,980
我们的项目中有很多

1794
01:23:15,980 --> 01:23:17,655
的不同示范者

1795
01:23:17,655 --> 01:23:18,890
和我们拥有的机器。

1796
01:23:18,890 --> 01:23:21,200
我在幻灯片上放了什么

1797
01:23:21,200 --> 01:23:23,930
基本上是一条精细冲压线，例如。

1798
01:23:23,930 --> 01:23:25,635
基本上是一条高

1799
01:23:25,635 --> 01:23:28,365
精密冲压工艺，我们可以

1800
01:23:28,365 --> 01:23:31,790
冲压金属或是高压

1801
01:23:31,790 --> 01:23:33,845
压铸工艺，我们基本上是在进行

1802
01:23:33,845 --> 01:23:35,540
熔融金属，我们将其推入

1803
01:23:35,540 --> 01:23:37,240
一种形式，然后我们

1804
01:23:37,240 --> 01:23:39,440
用来制作大型罐子，

1805
01:23:39,440 --> 01:23:42,840
例如，用于汽车制造。

1806
01:23:42,970 --> 01:23:45,265
我们研究项目的首要目标之一是

1807
01:23:45,265 --> 01:23:48,050
我们的研究项目是

1808
01:23:48,050 --> 01:23:49,940
基本上是为了将所有这些不同的机器互联。

1809
01:23:49,940 --> 01:23:51,680
这些不同的机器，

1810
01:23:51,680 --> 01:23:54,290
也来自不同的地点，

1811
01:23:54,290 --> 01:23:56,450
也只是为了尝试和

1812
01:23:56,450 --> 01:23:58,550
然后创建和收集

1813
01:23:58,550 --> 01:23:59,810
尽可能收集更多的数据。

1814
01:23:59,810 --> 01:24:03,800
我认为那是被带来的

1815
01:24:03,800 --> 01:24:05,520
相当不错，直截了当。

1816
01:24:05,520 --> 01:24:07,715
鲁特和玛丽-何塞以前。

1817
01:24:07,715 --> 01:24:09,015
我们只是在尽可能地收集

1818
01:24:09,015 --> 01:24:10,595
我们只是在尽可能地收集尽可能多的数据。

1819
01:24:10,595 --> 01:24:12,500
然后在右手边你可以看到

1820
01:24:12,500 --> 01:24:14,560
一些密码。

1821
01:24:14,560 --> 01:24:17,480
基本上，我们接下来想要尝试推导出

1822
01:24:17,480 --> 01:24:19,425
尽可能多地从那些数据中提取信息

1823
01:24:19,425 --> 01:24:21,660
尽可能地然后最终，

1824
01:24:21,660 --> 01:24:24,015
改进这些过程本身。

1825
01:24:24,015 --> 01:24:26,990
然而，在典型的工业环境中，

1826
01:24:26,990 --> 01:24:27,710
我们所看到的是

1827
01:24:27,710 --> 01:24:29,510
我们所看到的是，交流模式are rather static.

1828
01:24:29,510 --> 01:24:30,975
我们所看到的是，交流模式相当固定。

1829
01:24:30,975 --> 01:24:32,810
例如，您只需设置

1830
01:24:32,810 --> 01:24:34,545
连接到云端1秒

1831
01:24:34,545 --> 01:24:39,045
或者如果你有一个固定的供应链，

1832
01:24:39,045 --> 01:24:41,835
例如，你将只会设置

1833
01:24:41,835 --> 01:24:42,980
设置通信渠道

1834
01:24:42,980 --> 01:24:45,110
在这些不同的各方之间。

1835
01:24:45,110 --> 01:24:47,030
我个人正在关注的是

1836
01:24:47,030 --> 01:24:48,830
是如何让一切变得

1837
01:24:48,830 --> 01:24:51,604
一点更灵活地部署

1838
01:24:51,604 --> 01:24:53,400
计算功能以及

1839
01:24:53,400 --> 01:24:55,475
网络中的附加功能。

1840
01:24:55,475 --> 01:24:57,860
例如，如果我们有很多

1841
01:24:57,860 --> 01:25:02,190
分析任务在云端，那么我们应该如何操作，

1842
01:25:02,190 --> 01:25:03,740
例如，移动一些

1843
01:25:03,740 --> 01:25:05,480
将该功能移动到网络中

1844
01:25:05,480 --> 01:25:07,339
以便我们可以提高

1845
01:25:07,339 --> 01:25:09,034
整体表现。

1846
01:25:09,034 --> 01:25:10,440
但另一方面，

1847
01:25:10,440 --> 01:25:12,465
我有兴趣了解我们如何能够

1848
01:25:12,465 --> 01:25:15,245
实际上直接利用这些数据。

1849
01:25:15,245 --> 01:25:18,440
我们查看这些数据并尝试找出这些数据最适合放置的位置。

1850
01:25:18,440 --> 01:25:22,370
我们尝试找出这些数据最适合放置的位置。

1851
01:25:22,370 --> 01:25:24,530
为了进一步阐释这一点

1852
01:25:24,530 --> 01:25:26,925
让我们迅速使这个变得有点

1853
01:25:26,925 --> 01:25:28,860
让我们迅速使这个变得有点更容易，然后也看看这个位于底部的情节。

1854
01:25:28,860 --> 01:25:31,175
看看这个位于底部的情节。

1855
01:25:31,175 --> 01:25:33,110
你在这里看到的基本上是

1856
01:25:33,110 --> 01:25:38,840
一生中的管道连接过程。

1857
01:25:38,840 --> 01:25:40,534
我们有一个非常有特色的

1858
01:25:40,534 --> 01:25:42,380
我们有一个非常有特色的信号，基本上是拳头的力量。

1859
01:25:42,380 --> 01:25:44,385
我们有一个非常有特色的信号，基本上是拳头的力量，通过金属被打出的方式。

1860
01:25:44,385 --> 01:25:47,330
它是金属被打出的信号。

1861
01:25:47,330 --> 01:25:50,750
我们可以看到，最开始的信号是

1862
01:25:50,750 --> 01:25:52,370
变得相对稳定了。

1863
01:25:52,370 --> 01:25:53,834
变得稍微稳定一些。

1864
01:25:53,834 --> 01:25:55,845
然后之后它开始波动得更加剧烈。

1865
01:25:55,845 --> 01:25:58,805
我们可以将这个过程分为不同的阶段。

1866
01:25:58,805 --> 01:26:01,265
我们可以将这个过程分为不同的阶段。

1867
01:26:01,265 --> 01:26:03,090
沿着这些不同的阶段。

1868
01:26:03,090 --> 01:26:04,820
我们现在尝试的是沿着这些不同的阶段，基本上做的就是检测

1869
01:26:04,820 --> 01:26:06,785
我们基本上做的就是检测

1870
01:26:06,785 --> 01:26:08,990
这些不同的阶段或者说是发展的阶段

1871
01:26:08,990 --> 01:26:12,500
这个过程已经在网络设备上运行。

1872
01:26:12,500 --> 01:26:14,510
例如，如果我们在

1873
01:26:14,510 --> 01:26:17,255
在一个产品受控环境中，

1874
01:26:17,255 --> 01:26:19,830
那么我们就不需要所有的信息，

1875
01:26:19,830 --> 01:26:20,960
但我们可能只会对记录这些信息感兴趣，

1876
01:26:20,960 --> 01:26:22,610
我们可能只对记录这些信息感兴趣，并且

1877
01:26:22,610 --> 01:26:24,200
将它们发送到云端

1878
01:26:24,200 --> 01:26:26,385
例如，更深入的检查。

1879
01:26:26,385 --> 01:26:27,980
或者如果我们在

1880
01:26:27,980 --> 01:26:32,030
一张脸上的过程似乎变得狂野，

1881
01:26:32,030 --> 01:26:33,630
我们可以仅仅

1882
01:26:33,630 --> 01:26:36,770
识别出那个然后发送所有数据到

1883
01:26:36,770 --> 01:26:39,470
边缘附近的一个过程

1884
01:26:39,470 --> 01:26:40,790
我们随后所在的云端

1885
01:26:40,790 --> 01:26:42,380
控制的那个条款

1886
01:26:42,380 --> 01:26:45,135
鲁特之前也提到过的那个。

1887
01:26:45,135 --> 01:26:48,560
我们尝试的是这样的，

1888
01:26:48,560 --> 01:26:52,325
我们真的是尽力利用这些数据，

1889
01:26:52,325 --> 01:26:54,890
来还发现

1890
01:26:54,890 --> 01:26:56,690
我们想要发送数据的地方。

1891
01:26:56,690 --> 01:27:00,290
正如我所说，我在从外部向内在NDN上寻找我们想要发送数据的地方。

1892
01:27:00,290 --> 01:27:01,725
在NDN上从外部向内部

1893
01:27:01,725 --> 01:27:03,525
而那正是我会，例如，

1894
01:27:03,525 --> 01:27:05,720
感兴趣的是去发现

1895
01:27:05,720 --> 01:27:07,775
是否这些概念实际上是

1896
01:27:07,775 --> 01:27:09,920
支持NDN还是它们映射到

1897
01:27:09,920 --> 01:27:14,115
支持NDN吗？如果支持，这实际上是如何做到的。

1898
01:27:14,115 --> 01:27:16,760
因为我只是感兴趣

1899
01:27:16,760 --> 01:27:19,865
在这将如何运作。

1900
01:27:19,865 --> 01:27:23,070
是的，有了那个，我就可以进入我的幻灯片环节了。

1901
01:27:23,070 --> 01:27:24,740
非常感谢，我是

1902
01:27:24,740 --> 01:27:27,080
期待这次讨论。

1903
01:27:27,120 --> 01:27:31,910
>> 谢谢。我猜所有的参与者，

1904
01:27:31,910 --> 01:27:34,265
我还没有看到很多问题，

1905
01:27:34,265 --> 01:27:36,710
但你可以看到我们开始有了

1906
01:27:36,710 --> 01:27:41,940
这种计算事物聚合的趋势，

1907
01:27:41,940 --> 01:27:44,135
物事需要被发现。

1908
01:27:44,135 --> 01:27:47,120
我认为这是一些共通之处。

1909
01:27:47,120 --> 01:27:51,560
在数据中心和NDN世界都是如此。

1910
01:27:51,560 --> 01:27:55,220
我们将结束，但这并不是最不重要的，

1911
01:27:55,220 --> 01:27:57,860
它是最后一个人，但还有其他人。

1912
01:27:57,860 --> 01:28:01,530
他从行业中带来了另一种观点。

1913
01:28:03,280 --> 01:28:06,785
我是来自英特尔的Srikathyayani。

1914
01:28:06,785 --> 01:28:10,340
谁实际上是参与者？

1915
01:28:10,340 --> 01:28:13,820
非常感谢您即使出了事故也参与了这个。

1916
01:28:13,820 --> 01:28:16,370
Thank you so much for doing this despite your accident.

1917
01:28:16,370 --> 01:28:19,880
尽管你出了事故。

1918
01:28:19,880 --> 01:28:22,160
我很高兴你能做到。

1919
01:28:22,160 --> 01:28:24,530
我会让你谈论你在MDM中的工作。

1920
01:28:24,530 --> 01:28:25,700
因为你真的

1921
01:28:25,700 --> 01:28:27,825
参与社区活动。

1922
01:28:27,825 --> 01:28:30,775
>> 非常感谢你，Marie-Jose。

1923
01:28:30,775 --> 01:28:31,750
是的，我有过

1924
01:28:31,750 --> 01:28:33,820
几天前的一个不幸事故，我道歉

1925
01:28:33,820 --> 01:28:35,590
几天前我道歉

1926
01:28:35,590 --> 01:28:37,000
因为没有准备幻灯片。

1927
01:28:37,000 --> 01:28:38,590
我的视线仍然模糊不清，

1928
01:28:38,590 --> 01:28:40,430
我需要待在一个暗室里，

1929
01:28:40,430 --> 01:28:42,845
所以感谢你一直忍受我。

1930
01:28:42,845 --> 01:28:45,635
我是Srikathyayani Srikanteswara。

1931
01:28:45,635 --> 01:28:47,540
我是一名主要工程师，在

1932
01:28:47,540 --> 01:28:50,390
Intel实验室，我目前担任领导职务

1933
01:28:50,390 --> 01:28:52,640
研究并使用Endian进行

1934
01:28:52,640 --> 01:28:55,340
在边缘进行动态编排

1935
01:28:55,340 --> 01:28:57,050
以及如何适应和

1936
01:28:57,050 --> 01:29:00,905
将这些技术转移到工业应用中。

1937
01:29:00,905 --> 01:29:04,160
现在，我的话将会非常

1938
01:29:04,160 --> 01:29:07,955
符合前面已经提到的内容。

1939
01:29:07,955 --> 01:29:10,280
数据无处不在，

1940
01:29:10,280 --> 01:29:11,735
它越来越重要，

1941
01:29:11,735 --> 01:29:13,280
但关键是，数据

1942
01:29:13,280 --> 01:29:15,995
需要被分析、解释。

1943
01:29:15,995 --> 01:29:18,980
当那种情况发生时，就会产生更多的数据。

1944
01:29:18,980 --> 01:29:20,735
这意味着，

1945
01:29:20,735 --> 01:29:24,810
数据和计算通常是相辅相成的。

1946
01:29:26,260 --> 01:29:29,645
我想提及的另一个要点是

1947
01:29:29,645 --> 01:29:32,945
数据和计算通常是相辅相成的。

1948
01:29:32,945 --> 01:29:35,885
但是数据无处不在，计算能力也同样无处不在。

1949
01:29:35,885 --> 01:29:39,215
但是今天很多数据并没有被利用起来。

1950
01:29:39,215 --> 01:29:40,640
我在说什么呢？我们都

1951
01:29:40,640 --> 01:29:42,365
在线边缘计算方面我们都有所了解。

1952
01:29:42,365 --> 01:29:44,270
我们正在将服务器带得更靠近边缘，

1953
01:29:44,270 --> 01:29:45,470
我们正在将服务器带得更靠近边缘，

1954
01:29:45,470 --> 01:29:48,140
也许是在5G基站等地方。

1955
01:29:48,140 --> 01:29:50,540
但还有更多的

1956
01:29:50,540 --> 01:29:53,090
但还有更多的计算资源

1957
01:29:53,090 --> 01:29:55,370
可用的但并未参与其中

1958
01:29:55,370 --> 01:29:58,700
在提供数据或边缘计算方面。

1959
01:29:58,700 --> 01:30:00,980
我在谈论处理，在提供数据或边缘计算方面，of CPU in cars,

1960
01:30:00,980 --> 01:30:02,270
的汽车中的CPU，

1961
01:30:02,270 --> 01:30:04,175
或许是星巴克里的一台服务器，

1962
01:30:04,175 --> 01:30:06,095
你家里的个人电脑上，

1963
01:30:06,095 --> 01:30:07,250
你家里的个人电脑上，或者在一台位于

1964
01:30:07,250 --> 01:30:09,470
一间还没有完工的工厂车间

1965
01:30:09,470 --> 01:30:11,270
部分工厂云

1966
01:30:11,270 --> 01:30:13,790
并且不参与边缘计算。

1967
01:30:13,790 --> 01:30:16,250
我想要提及的是，

1968
01:30:16,250 --> 01:30:19,790
Endian实际上具有这种独特的能力

1969
01:30:19,790 --> 01:30:22,865
将所有这些设备带来，

1970
01:30:22,865 --> 01:30:26,180
计算不使用的数据资源

1971
01:30:26,180 --> 01:30:27,980
参与

1972
01:30:27,980 --> 01:30:30,560
这种边缘计算数据传输，

1973
01:30:30,560 --> 01:30:32,975
将所有这些纳入考量。

1974
01:30:32,975 --> 01:30:35,465
我认为那是一个我们可以真正展现出独特特色的地方。

1975
01:30:35,465 --> 01:30:37,910
可以真正展现出独特特色

1976
01:30:37,910 --> 01:30:39,725
或者Endian的好处

1977
01:30:39,725 --> 01:30:41,885
在一个可能会……的行业

1978
01:30:41,885 --> 01:30:43,910
否则不愿意改变

1979
01:30:43,910 --> 01:30:47,045
从IP或者他们处理事情的方式。

1980
01:30:47,045 --> 01:30:49,070
从Endian的独特特征，

1981
01:30:49,070 --> 01:30:50,210
我不需要解释

1982
01:30:50,210 --> 01:30:51,770
Endian的好处。

1983
01:30:51,770 --> 01:30:53,660
Endian的特性将会

1984
01:30:53,660 --> 01:30:56,000
在这种情况下

1985
01:30:56,000 --> 01:30:57,080
我提到的是事实

1986
01:30:57,080 --> 01:30:59,240
Endian可以桥接

1987
01:30:59,240 --> 01:31:00,920
无线网络很多

1988
01:31:00,920 --> 01:31:03,185
比如说IP，更容易。

1989
01:31:03,185 --> 01:31:04,730
因为在网络层，

1990
01:31:04,730 --> 01:31:06,950
你并不真的在乎我是否在发送

1991
01:31:06,950 --> 01:31:07,970
~!@#$%^&*()

1992
01:31:07,970 --> 01:31:10,010
无线网络或蓝牙，

1993
01:31:10,010 --> 01:31:12,260
5G或其他任何东西。

1994
01:31:12,260 --> 01:31:14,090
有那么大的优势

1995
01:31:14,090 --> 01:31:15,170
我认为那需要被

1996
01:31:15,170 --> 01:31:18,575
被开发利用并且进一步提升。

1997
01:31:18,575 --> 01:31:21,770
Endian还拥有这种独特的能力

1998
01:31:21,770 --> 01:31:24,365
打破数据孤岛。

1999
01:31:24,365 --> 01:31:27,515
尤其是像智能城市这样的新闻案例，

2000
01:31:27,515 --> 01:31:29,000
它我猜是有关联的

2001
01:31:29,000 --> 01:31:30,290
它有些部分被称作它

2002
01:31:30,290 --> 01:31:33,170
物联网用例的一部分。

2003
01:31:33,170 --> 01:31:34,730
您有数据在

2004
01:31:34,730 --> 01:31:36,170
粮仓运输系统，

2005
01:31:36,170 --> 01:31:37,505
可能是气候系统，

2006
01:31:37,505 --> 01:31:39,470
汽车里，在

2007
01:31:39,470 --> 01:31:42,770
电力部门等等。

2008
01:31:42,770 --> 01:31:45,275
所有这些都需要结合起来。

2009
01:31:45,275 --> 01:31:47,345
特别是如果你有

2010
01:31:47,345 --> 01:31:49,340
一个通用的命名方案和元数据

2011
01:31:49,340 --> 01:31:50,675
以及对此的可见性

2012
01:31:50,675 --> 01:31:52,955
以及信任机制，

2013
01:31:52,955 --> 01:31:55,130
Endian提供了独特的能力

2014
01:31:55,130 --> 01:31:57,905
对于这些用例来说。

2015
01:31:57,905 --> 01:31:59,810
我想提出的另一个观点是

2016
01:31:59,810 --> 01:32:01,235
出色的是

2017
01:32:01,235 --> 01:32:02,960
在某些用例中

2018
01:32:02,960 --> 01:32:04,940
像物联网或工厂车间，

2019
01:32:04,940 --> 01:32:06,650
在数据产生的地方

2020
01:32:06,650 --> 01:32:09,335
在边缘处产生并在边缘处使用，

2021
01:32:09,335 --> 01:32:12,560
传统的CDN方式将

2022
01:32:12,560 --> 01:32:14,120
不起作用，因为很多时候

2023
01:32:14,120 --> 01:32:16,115
这就是我得到的论点是，

2024
01:32:16,115 --> 01:32:17,660
between different systems, and from what I've gathered,"

2025
01:32:17,660 --> 01:32:18,755
，Endian的表现要好得多。

2026
01:32:18,755 --> 01:32:20,225
我们将会使用一个CDN。

2027
01:32:20,225 --> 01:32:22,310
CDN在数据位于的时候表现非常好。

2028
01:32:22,310 --> 01:32:24,650
核心和流向边缘。

2029
01:32:24,650 --> 01:32:27,335
但在像这样的领域

2030
01:32:27,335 --> 01:32:28,490
物联网，在这样的领域中，数据是在边缘生成和使用的，

2031
01:32:28,490 --> 01:32:30,200
在边缘生成和使用，

2032
01:32:30,200 --> 01:32:33,080
这种架构效果不是很好。

2033
01:32:33,080 --> 01:32:35,210
沿着这些思路，我们实际上在内部开发了一种算法。

2034
01:32:35,210 --> 01:32:38,330
我们在内部开发了一种算法

2035
01:32:38,330 --> 01:32:40,700
端对端的动态编排，我们在这里

2036
01:32:40,700 --> 01:32:43,205
汇总数据，

2037
01:32:43,205 --> 01:32:44,390
计算，有

2038
01:32:44,390 --> 01:32:45,590
硬件资源和~!@#$%^&*()

2039
01:32:45,590 --> 01:32:47,180
软件能够实时协同工作。

2040
01:32:47,180 --> 01:32:47,990
即是说，他们获得

2041
01:32:47,990 --> 01:32:49,430
发现是实时的，他们来到

2042
01:32:49,430 --> 01:32:51,050
一起实时地，我们

2043
01:32:51,050 --> 01:32:53,210
在Globcom上发布这些。

2044
01:32:53,210 --> 01:32:56,060
我们发现的是，除了，

2045
01:32:56,060 --> 01:32:57,950
我们确实可以在这些中发现

2046
01:32:57,950 --> 01:32:58,730
实时并且将

2047
01:32:58,730 --> 01:33:00,335
将它们实时地结合在一起。

2048
01:33:00,335 --> 01:33:02,315
我们能够展示的是，

2049
01:33:02,315 --> 01:33:03,560
即使是这些服务器，

2050
01:33:03,560 --> 01:33:05,285
假设它们开启五秒钟，

2051
01:33:05,285 --> 01:33:06,800
它们消失了，它们不见了。

2052
01:33:06,800 --> 01:33:08,390
我们能够持续地发现新资源并利用它们。

2053
01:33:08,390 --> 01:33:10,625
发现新资源并使用它们。

2054
01:33:10,625 --> 01:33:12,485
它支持动态性，这是Endian非常独特的特点。

2055
01:33:12,485 --> 01:33:15,230
Endian的一个非常独特的特性。

2056
01:33:15,230 --> 01:33:16,730
我们还发现了另一件事情

2057
01:33:16,730 --> 01:33:18,065
我们甚至没有刻意去寻找它

2058
01:33:18,065 --> 01:33:21,215
负载均衡变得相当自动化了。

2059
01:33:21,215 --> 01:33:23,570
如今已经投入了大量的努力。

2060
01:33:23,570 --> 01:33:25,040
今天怎么做

2061
01:33:25,040 --> 01:33:27,110
负载均衡，我指的是什么？

2062
01:33:27,110 --> 01:33:29,390
假设我有两个主服务器，

2063
01:33:29,390 --> 01:33:30,650
突然出现了第三个头服务器

2064
01:33:30,650 --> 01:33:31,925
出现了第四个。

2065
01:33:31,925 --> 01:33:34,985
自动发送兴趣数据包

2066
01:33:34,985 --> 01:33:36,710
开始前往服务器

2067
01:33:36,710 --> 01:33:38,300
他们说，因为那些不太繁忙。

2068
01:33:38,300 --> 01:33:40,340
"嘿，我有空，"他们回应。

2069
01:33:40,340 --> 01:33:43,115
我们看到负载正在被

2070
01:33:43,115 --> 01:33:47,480
负载正在平均分配到不同的服务器上。

2071
01:33:47,480 --> 01:33:50,030
这些结果，正如我所说的，它们是本地的，

2072
01:33:50,030 --> 01:33:51,170
遗憾的是，我无法做到

2073
01:33:51,170 --> 01:33:52,460
向你展示它们。

2074
01:33:52,460 --> 01:33:53,930
但后来我们拿出来

2075
01:33:53,930 --> 01:33:55,760
所有这些结果，然后我们去了

2076
01:33:55,760 --> 01:33:57,290
和一些人交谈了

2077
01:33:57,290 --> 01:33:59,180
正在构建这些端到端系统的人员，

2078
01:33:59,180 --> 01:34:01,085
在这些领域工作。

2079
01:34:01,085 --> 01:34:03,560
一些有趣的见解

2080
01:34:03,560 --> 01:34:05,795
我想和你分享的是，

2081
01:34:05,795 --> 01:34:07,490
很多这些地区，

2082
01:34:07,490 --> 01:34:08,780
由于您已经知道，

2083
01:34:08,780 --> 01:34:10,670
人们习惯了使用IP工作，

2084
01:34:10,670 --> 01:34:12,335
他们拥有的系统。

2085
01:34:12,335 --> 01:34:14,150
那里有着丰富的历史。

2086
01:34:14,150 --> 01:34:14,720
~!@#$%^&*()

2087
01:34:14,720 --> 01:34:16,745
代码已经存在那里。

2088
01:34:16,745 --> 01:34:19,130
当他们看到很多这样的结果时，

2089
01:34:19,130 --> 01:34:21,455
他们明白了，他们很兴奋。

2090
01:34:21,455 --> 01:34:23,585
但我们听到的另一件事是，

2091
01:34:23,585 --> 01:34:24,980
如果你想让我们

2092
01:34:24,980 --> 01:34:27,395
改变我们的做事方式，

2093
01:34:27,395 --> 01:34:29,000
改变我们的做事方式，当有一个解决方案时，我们想要看到2倍的效果，

2094
01:34:29,000 --> 01:34:30,320
我们想要看到2倍的效果，

2095
01:34:30,320 --> 01:34:32,120
我们想要看到3倍甚至10倍的效果增益，然后我们才会考虑改变。

2096
01:34:32,120 --> 01:34:35,030
我们才会考虑改变之前，我们希望看到至少50%的效果提升。

2097
01:34:35,030 --> 01:34:37,430
在我们看到至少50%的效果提升之前，

2098
01:34:37,430 --> 01:34:39,410
努力修改代码，

2099
01:34:39,410 --> 01:34:40,490
不，我不感兴趣。

2100
01:34:40,490 --> 01:34:41,870
对我个人来说

2101
01:34:41,870 --> 01:34:43,370
作为一名研究者，这有点让人惊讶，

2102
01:34:43,370 --> 01:34:45,305
但它不断地来自于

2103
01:34:45,305 --> 01:34:47,885
正在将这些日常实践付诸实施的人们。

2104
01:34:47,885 --> 01:34:49,520
这是有道理的。

2105
01:34:49,520 --> 01:34:53,090
我想要表达的另一个观点是，

2106
01:34:53,090 --> 01:34:54,380
许多这些变化已经在

2107
01:34:54,380 --> 01:34:56,360
行业中已经在发生。

2108
01:34:56,360 --> 01:35:00,230
您朝着命名方向发展时的条款或

2109
01:35:00,230 --> 01:35:01,940
像当您采用服务网格或者

2110
01:35:01,940 --> 01:35:04,595
即使OPC UA也具有发布-订阅功能。

2111
01:35:04,595 --> 01:35:06,020
这些方面中的一些

2112
01:35:06,020 --> 01:35:07,490
已经开始慢慢渗透到行业中去。

2113
01:35:07,490 --> 01:35:10,925
已经开始慢慢渗透到行业中去。

2114
01:35:10,925 --> 01:35:12,230
但我想要强调的是

2115
01:35:12,230 --> 01:35:14,480
Endian社区是，

2116
01:35:14,480 --> 01:35:18,260
它将会非常有帮助，如果我们整合，

2117
01:35:18,260 --> 01:35:19,550
如果我们所有人和这个

2118
01:35:19,550 --> 01:35:21,140
如果我们所有人和这个请求是一个整体。

2119
01:35:21,140 --> 01:35:23,480
如果我们采取一个整体的Endian方法，

2120
01:35:23,480 --> 01:35:26,000
集成到现有的流行应用程序中。

2121
01:35:26,000 --> 01:35:29,105
我听说了几次Kubernetes，

2122
01:35:29,105 --> 01:35:30,380
这些是一些软件

2123
01:35:30,380 --> 01:35:32,465
这些正在被普遍使用。

2124
01:35:32,465 --> 01:35:36,140
如果我们能轻松展示，只需使用这个步骤，

2125
01:35:36,140 --> 01:35:37,175
这段代码，

2126
01:35:37,175 --> 01:35:38,750
这段代码，你可以拥有

2127
01:35:38,750 --> 01:35:40,865
应用程序的一部分在IP中，

2128
01:35:40,865 --> 01:35:42,260
一部分在Endian中，你会得到

2129
01:35:42,260 --> 01:35:43,370
在Endian中，你会得到所有这些好处当你

2130
01:35:43,370 --> 01:35:44,675
使用它们在Endian中，

2131
01:35:44,675 --> 01:35:48,005
我认为那将会大有帮助。

2132
01:35:48,005 --> 01:35:50,540
行业意识到了这些好处

2133
01:35:50,540 --> 01:35:52,475
行业意识到了这些好处，并且实际上开始采用它们。

2134
01:35:52,475 --> 01:35:55,250
那么当然，最后但同样重要的是，

2135
01:35:55,250 --> 01:35:56,555
当你开始查看数据

2136
01:35:56,555 --> 01:35:58,040
伴随着计算，

2137
01:35:58,040 --> 01:36:00,650
伴随着计算，出现了一些新的安全挑战。

2138
01:36:00,650 --> 01:36:02,195
随之出现的是，比如说，

2139
01:36:02,195 --> 01:36:03,980
你怎么知道你是~!@#$%^&*()

2140
01:36:03,980 --> 01:36:07,280
授权访问计算资源，

2141
01:36:07,280 --> 01:36:10,100
访问控制，可信计算，

2142
01:36:10,100 --> 01:36:12,920
可验证计算等。

2143
01:36:12,920 --> 01:36:13,880
我们实际上

2144
01:36:13,880 --> 01:36:15,470
与教授们合作，

2145
01:36:15,470 --> 01:36:18,470
Jamie Shen，Riza [无法听清] 这方面。

2146
01:36:18,470 --> 01:36:20,720
但我认为这些是一些

2147
01:36:20,720 --> 01:36:21,920
我想提及的事情之一

2148
01:36:21,920 --> 01:36:23,970
并且我将以此作为结束。

2149
01:36:25,300 --> 01:36:26,930
>> 非常感谢您。

2150
01:36:26,930 --> 01:36:28,820
这是一个非常好的总结

2151
01:36:28,820 --> 01:36:29,750
在一切事物的方式中

2152
01:36:29,750 --> 01:36:31,475
我们需要谈谈。

2153
01:36:31,475 --> 01:36:34,145
我认为你，Rute ~!@#$%^&*()

2154
01:36:34,145 --> 01:36:36,260
是似乎得到很多问题的那个人来自Slack。

2155
01:36:36,260 --> 01:36:40,970
来自Slack的问题支持。

2156
01:36:40,970 --> 01:36:43,310
来自支持的事情

2157
01:36:43,310 --> 01:36:44,480
为了移动性。

2158
01:36:44,480 --> 01:36:47,180
您愿意和我们分享一些吗？

2159
01:36:47,180 --> 01:36:49,130
您愿意和我们分享一些吗？您在Slack上讨论的主题是什么？

2160
01:36:49,130 --> 01:36:52,080
您在Slack上讨论了什么？

2161
01:36:54,610 --> 01:36:58,170
是的。抱歉，我刚才在解除静音。

2162
01:37:02,410 --> 01:37:05,390
在生产移动性方面，

2163
01:37:05,390 --> 01:37:06,814
有几个问题

2164
01:37:06,814 --> 01:37:09,700
关于解决方案，我们今天有几个问题，当然，

2165
01:37:09,700 --> 01:37:11,680
我们今天有，当然，

2166
01:37:11,680 --> 01:37:13,510
我们有一些解决方案。

2167
01:37:13,510 --> 01:37:14,860
我说，我不认为那

2168
01:37:14,860 --> 01:37:16,885
流动性是一个关键部分，

2169
01:37:16,885 --> 01:37:18,430
至少要说服某人

2170
01:37:18,430 --> 01:37:19,990
制造那可能是Endian的~!@#$%^&*()

2171
01:37:19,990 --> 01:37:24,855
有趣的是，我们还有其他问题。

2172
01:37:24,855 --> 01:37:27,950
但是，然而，这里的想法

2173
01:37:27,950 --> 01:37:28,790
我们所拥有的是

2174
01:37:28,790 --> 01:37:30,560
生产者所在的环境，

2175
01:37:30,560 --> 01:37:33,950
所以我们在以太网之上使用Endian。

2176
01:37:33,950 --> 01:37:35,899
当然，提供商

2177
01:37:35,899 --> 01:37:38,745
最终成为的机器人

2178
01:37:38,745 --> 01:37:47,965
以短时间间隔发送信息。

2179
01:37:47,965 --> 01:37:49,870
当然是小信息。

2180
01:37:49,870 --> 01:37:52,345
通常是关键信息。

2181
01:37:52,345 --> 01:37:54,280
我认为的另一个方面是

2182
01:37:54,280 --> 01:37:56,110
我认为的另一个方面是更有趣的是，let me just see,

2183
01:37:56,110 --> 01:37:57,775
我看看，

2184
01:37:57,775 --> 01:38:02,020
我在尝试浏览相关

2185
01:38:02,020 --> 01:38:07,940
我认为这个评论说的是

2186
01:38:07,940 --> 01:38:13,460
我认为这个评论说的是，当然我们有 the capability to push.

2187
01:38:13,460 --> 01:38:17,740
我们有推进的能力

2188
01:38:17,740 --> 01:38:18,970
语义部分和

2189
01:38:18,970 --> 01:38:21,220
这是否足够。

2190
01:38:21,220 --> 01:38:22,000
我会说这是

2191
01:38:22,000 --> 01:38:25,240
绝对是一个起点，

2192
01:38:25,240 --> 01:38:26,440
这绝对是一个起点，问题是，至少

2193
01:38:26,440 --> 01:38:27,700
这绝对是一个问题，因为至少

2194
01:38:27,700 --> 01:38:31,505
我没有按照操作流程来写。

2195
01:38:31,505 --> 01:38:33,875
我们还需要发送一些参数，

2196
01:38:33,875 --> 01:38:35,420
不仅来自生产者，

2197
01:38:35,420 --> 01:38:38,735
但也包括传感器参数，

2198
01:38:38,735 --> 01:38:39,560
例如，

2199
01:38:39,560 --> 01:38:41,120
时间同步参数，

2200
01:38:41,120 --> 01:38:43,100
等等，这些都很重要。

2201
01:38:43,100 --> 01:38:45,635
这个问题是我们能否做到。

2202
01:38:45,635 --> 01:38:48,620
与这些同步方法相结合。

2203
01:38:48,620 --> 01:38:50,210
这将是同步方法。

2204
01:38:50,210 --> 01:38:54,200
~!@#$%^&*()

2205
01:38:54,200 --> 01:38:55,220
这实际上是这样

2206
01:38:55,220 --> 01:38:57,665
随之而来的当然还有一些问题

2207
01:38:57,665 --> 01:39:00,350
Ike 在如何方面可以帮助他在工厂车间。

2208
01:39:00,350 --> 01:39:03,365
Endian 可以在工厂车间帮助他。

2209
01:39:03,365 --> 01:39:05,615
我认为根据我们所听到的，

2210
01:39:05,615 --> 01:39:09,750
我对塔蒂亚娜感到满意。

2211
01:39:11,220 --> 01:39:13,134
提到

2212
01:39:13,134 --> 01:39:15,550
不同的数据来源

2213
01:39:15,550 --> 01:39:17,890
和所有这些事实

2214
01:39:17,890 --> 01:39:23,110
这些系统是线性的，并且就物联网而言，

2215
01:39:23,110 --> 01:39:25,060
我们需要横向使用它们。

2216
01:39:25,060 --> 01:39:27,490
我一直面临着这个问题。

2217
01:39:27,490 --> 01:39:29,800
我认为这也是[噪音]

2218
01:39:29,800 --> 01:39:33,745
一个有趣的问题又回到了Dirk那里。

2219
01:39:33,745 --> 01:39:36,220
嗯，Dirk，我把球扔给你了。

2220
01:39:36,220 --> 01:39:38,680
现在因为你

2221
01:39:38,680 --> 01:39:43,480
如果数据是答案，那么提出这个想法。

2222
01:39:43,480 --> 01:39:45,070
如果数据是答案，那么我认为，

2223
01:39:45,070 --> 01:39:48,175
首先是反叛的力量。

2224
01:39:48,175 --> 01:39:51,280
所有这些数据系统以及你如何

2225
01:39:51,280 --> 01:39:55,510
管理这些数据系统以及你如何感觉一个NDN和一个ICN在这里可以提供帮助。

2226
01:39:55,510 --> 01:39:57,520
我会告诉你为什么~!@#$%^&*()

2227
01:39:57,520 --> 01:40:00,640
相同的原因，那就是Srikathyayani。

2228
01:40:00,640 --> 01:40:02,125
我叫你Srikathyayani。

2229
01:40:02,125 --> 01:40:03,430
因为我认识某个人

2230
01:40:03,430 --> 01:40:04,225
这就是所谓的那样。

2231
01:40:04,225 --> 01:40:06,310
很抱歉，我不知道您的名字。

2232
01:40:06,310 --> 01:40:07,810
>> 就像我，只是一个E和

2233
01:40:07,810 --> 01:40:09,640
N. 顺便说一下我有~!@#$%^&*()

2234
01:40:09,640 --> 01:40:11,875
关于一项能力的评论

2235
01:40:11,875 --> 01:40:14,470
如果可以分享那个的话。

2236
01:40:14,470 --> 01:40:16,630
在你的演讲之前，我认为

2237
01:40:16,630 --> 01:40:19,705
在你的演讲之前，我认为你是对的在提到需要有

2238
01:40:19,705 --> 01:40:23,755
提到需要具备

2239
01:40:23,755 --> 01:40:25,870
的性能要好得多，以便人们

2240
01:40:25,870 --> 01:40:28,600
会进行他们的过渡。

2241
01:40:28,600 --> 01:40:30,895
请继续，或许你可以回答。

2242
01:40:30,895 --> 01:40:33,700
那个[听不清]能力，然后Dirk，

2243
01:40:33,700 --> 01:40:35,260
我真的很想知道你的想法。

2244
01:40:35,260 --> 01:40:37,540
我们该怎么处理巴别塔呢？

2245
01:40:37,540 --> 01:40:42,190
~!@#$%^&*()

2246
01:40:42,190 --> 01:40:42,191
[重叠]

2247
01:40:42,191 --> 01:40:42,520
对不起。

2248
01:40:42,520 --> 01:40:43,570
你是想让我先走，还是说……

2249
01:40:43,570 --> 01:40:45,445
你是想让迪尔克先走吗？

2250
01:40:45,445 --> 01:40:46,510
>> 不，你先走吧。

2251
01:40:46,510 --> 01:40:46,990
>> ~!@#$%^&*()

2252
01:40:46,990 --> 01:40:49,585
>> 好的，我只是想让你添加到

2253
01:40:49,585 --> 01:40:52,480
鲁特关于流动性的评论，一些好消息。

2254
01:40:52,480 --> 01:40:53,740
你还没有完全进入状态

2255
01:40:53,740 --> 01:40:56,830
TSM工厂车间背景。

2256
01:40:56,830 --> 01:40:58,270
但我们实际上能够

2257
01:40:58,270 --> 01:41:00,175
模拟在ndnSIM中。

2258
01:41:00,175 --> 01:41:01,930
这不是一个实际的实现，

2259
01:41:01,930 --> 01:41:05,070
但在模拟中，我们有一堆

2260
01:41:05,070 --> 01:41:06,990
在道路上行驶的汽车

2261
01:41:06,990 --> 01:41:08,700
然后还有一些接入点。

2262
01:41:08,700 --> 01:41:09,720
但是在这边超过了五个

2263
01:41:09,720 --> 01:41:12,495
因为在ndnSIM中这会容易得多。

2264
01:41:12,495 --> 01:41:15,660
然后，当然，我们有资源数据在

2265
01:41:15,660 --> 01:41:19,480
汽车以及在固定部分和NDN上也是如此。

2266
01:41:19,480 --> 01:41:21,070
能够顺利工作，以及

2267
01:41:21,070 --> 01:41:22,690
那是我所体验到的活力所在。

2268
01:41:22,690 --> 01:41:25,090
刚才你说你有车资源只是为了

2269
01:41:25,090 --> 01:41:26,320
几秒钟之后就

2270
01:41:26,320 --> 01:41:27,730
几秒钟之后就消失了，它起作用了。

2271
01:41:27,730 --> 01:41:31,720
并不完全是工厂车间的情况，

2272
01:41:31,720 --> 01:41:33,340
the TSM, the type controls, ~!@#$%^&*()

2273
01:41:33,340 --> 01:41:36,860
但在其他形式的移动性中它是有效的。

2274
01:41:39,600 --> 01:41:42,970
好的。Dirk，再来一次。

2275
01:41:42,970 --> 01:41:45,460
我想让你拥有这个。

2276
01:41:45,460 --> 01:41:47,665
What are your views on ~!@#$%^&*()

2277
01:41:47,665 --> 01:41:50,275
所有这些所需的数据编排？

2278
01:41:50,275 --> 01:41:51,580
他们使用的所有事实

2279
01:41:51,580 --> 01:41:53,590
不同的语义模型。

2280
01:41:53,590 --> 01:41:55,000
再次，你是那个人

2281
01:41:55,000 --> 01:41:56,530
如果数据是答案的开始，

2282
01:41:56,530 --> 01:41:59,500
那么问题是什么，我认为缺乏

2283
01:41:59,500 --> 01:42:04,465
公共接口实际上是指的，Yana船长，

2284
01:42:04,465 --> 01:42:06,850
你提到编排是

2285
01:42:06,850 --> 01:42:08,560
一个很大的问题，所以我将会

2286
01:42:08,560 --> 01:42:10,525
把问题抛回给你，Dirk。

2287
01:42:10,525 --> 01:42:12,625
我们知道一些问题。

2288
01:42:12,625 --> 01:42:15,530
你认为答案是什么？

2289
01:42:16,620 --> 01:42:18,820
嗯，我没有一个很好的答案。

2290
01:42:18,820 --> 01:42:22,130
我通常只是在问问题。

2291
01:42:23,160 --> 01:42:25,570
>> 这就是为什么我要问你一个问题。

2292
01:42:25,570 --> 01:42:28,630
~!@#$%^&*()

2293
01:42:28,630 --> 01:42:29,995
[无法听清] 在回答问题。

2294
01:42:29,995 --> 01:42:32,560
>> 是的。我认为

2295
01:42:32,560 --> 01:42:34,360
~!@#$%^&*()

2296
01:42:34,360 --> 01:42:36,925
返回首尔仁川国际机场。

2297
01:42:36,925 --> 01:42:41,530
即使我多次离开是因为

2298
01:42:41,530 --> 01:42:42,910
作为一种汇集不同观点的方法

2299
01:42:42,910 --> 01:42:44,080
各种不同的概念包括

2300
01:42:44,080 --> 01:42:45,670
从数据到计算，

2301
01:42:45,670 --> 01:42:47,500
它极其有趣，而且还有

2302
01:42:47,500 --> 01:42:49,420
一种特质在你到来时候展现出来

2303
01:42:49,420 --> 01:42:51,730
变化多端的

2304
01:42:51,730 --> 01:42:54,820
数据源本质上必须具备的~!@#$%^&*()

2305
01:42:54,820 --> 01:42:56,020
处理中心化

2306
01:42:56,020 --> 01:42:57,430
并且回到了评论内容上

2307
01:42:57,430 --> 01:42:58,570
做出了关于

2308
01:42:58,570 --> 01:43:00,535
计算的去中心化。

2309
01:43:00,535 --> 01:43:02,320
也许性能是其中之一

2310
01:43:02,320 --> 01:43:04,570
也许性能是其中之一，方面和我同意如果你会得到

2311
01:43:04,570 --> 01:43:05,350
同意如果你会得到

2312
01:43:05,350 --> 01:43:06,430
提高了30%的性能，

2313
01:43:06,430 --> 01:43:09,385
没有人会特别兴奋。

2314
01:43:09,385 --> 01:43:11,050
但是我发现的非常~!@#$%^&*()

2315
01:43:11,050 --> 01:43:12,670
我发现的非常分散化

2316
01:43:12,670 --> 01:43:14,680
有趣的是当去中心化变得

2317
01:43:14,680 --> 01:43:16,990
更多的是一种定性的，

2318
01:43:16,990 --> 01:43:19,180
或许更多的是一种由治理驱动的方面，

2319
01:43:19,180 --> 01:43:20,470
一个纯粹的性能方面，

2320
01:43:20,470 --> 01:43:24,390
将各种不同的系统整合在一起，

2321
01:43:24,390 --> 01:43:26,775
将各种不同的系统整合在一起，每个系统都具有数据治理方面的特征，其元数据随之附加。

2322
01:43:26,775 --> 01:43:29,650
它们的元数据随之附加。

2323
01:43:29,650 --> 01:43:32,620
您将需要

2324
01:43:32,620 --> 01:43:34,570
从一个系统转换到另一个系统。

2325
01:43:34,570 --> 01:43:37,480
你需要适应和处理功能。

2326
01:43:37,480 --> 01:43:40,660
你增加了一个去中心化的方面至

2327
01:43:40,660 --> 01:43:43,620
你的系统确实是

2328
01:43:43,620 --> 01:43:44,730
显著不同

2329
01:43:44,730 --> 01:43:46,110
比我们今天所知道的系统。

2330
01:43:46,110 --> 01:43:47,610
这是一个非常好的评论。

2331
01:43:47,610 --> 01:43:50,640
NDNs在推送数据方面非常出色，

2332
01:43:50,640 --> 01:43:52,775
但它们在这方面并不是很好，

2333
01:43:52,775 --> 01:43:56,200
但它们在这方面并不是很好，真正以分散的方式来管理和处理数据。

2334
01:43:56,200 --> 01:43:58,795
管理和处理数据。

2335
01:43:58,795 --> 01:44:00,520
这就是让我感兴趣的部分关于

2336
01:44:00,520 --> 01:44:02,770
像这样的以数据为中心的架构

2337
01:44:02,770 --> 01:44:05,485
ICN作为一个[听不清的]，特别是NDN。

2338
01:44:05,485 --> 01:44:07,660
但是你有能力去

2339
01:44:07,660 --> 01:44:09,055
天生适应

2340
01:44:09,055 --> 01:44:10,660
分散化方面。

2341
01:44:10,660 --> 01:44:12,370
你有能力整合

2342
01:44:12,370 --> 01:44:14,050
将计算部分整合进

2343
01:44:14,050 --> 01:44:16,530
将计算部分整合进它，这确实非常有趣。

2344
01:44:16,530 --> 01:44:17,910
确实非常有趣。

2345
01:44:17,910 --> 01:44:18,600
这就是我的问题。

2346
01:44:18,600 --> 01:44:19,950
我把它放在Slack上了，但我意识到你可能看不到Slack上的问题。

2347
01:44:19,950 --> 01:44:21,330
你可能看不到Slack上的问题。

2348
01:44:21,330 --> 01:44:22,920
~!@#$%^&*()

2349
01:44:22,920 --> 01:44:24,165
我在重复它。

2350
01:44:24,165 --> 01:44:26,860
那是当时的那部分。

2351
01:44:26,860 --> 01:44:28,060
我们考察了去中心化的情况

2352
01:44:28,060 --> 01:44:29,500
计算并不是一个真正的……

2353
01:44:29,500 --> 01:44:31,585
必然是由性能方面推动的，

2354
01:44:31,585 --> 01:44:33,130
性能方面的驱动，

2355
01:44:33,130 --> 01:44:35,260
可能需要我的本地化

2356
01:44:35,260 --> 01:44:38,650
实际上选择一个计算资源

2357
01:44:38,650 --> 01:44:39,805
离我更近的是。

2358
01:44:39,805 --> 01:44:42,985
他的幻灯片中我剪辑了非常相似的要求。

2359
01:44:42,985 --> 01:44:45,340
关于计算的可能需要

2360
01:44:45,340 --> 01:44:47,035
可能需要对你有很强的局部性。

2361
01:44:47,035 --> 01:44:49,360
它提供了定性的方面

2362
01:44:49,360 --> 01:44:52,570
一个可能是驱动力的系统

2363
01:44:52,570 --> 01:44:54,160
为了改变而不是

2364
01:44:54,160 --> 01:44:56,560
提高了20%或30%的性能

2365
01:44:56,560 --> 01:44:58,885
与集中式方法相比

2366
01:44:58,885 --> 01:45:00,700
与集中式方法相比，那是我们越来越想要了解的东西。

2367
01:45:00,700 --> 01:45:03,790
我们越来越想要了解

2368
01:45:03,790 --> 01:45:04,840
在一些使用案例中

2369
01:45:04,840 --> 01:45:06,130
我们正在查看的是三个

2370
01:45:06,130 --> 01:45:08,560
关于身份空间，

2371
01:45:08,560 --> 01:45:09,970
例如，以及随之而来的属性

2372
01:45:09,970 --> 01:45:11,200
随之而来的属性，然后你会意识到在

2373
01:45:11,200 --> 01:45:12,340
将会意识到在

2374
01:45:12,340 --> 01:45:14,440
分布式身份空间中

2375
01:45:14,440 --> 01:45:15,880
如何处理具有~!@#$%^&*()

2376
01:45:15,880 --> 01:45:18,130
不同的来源，具有不同的属性。

2377
01:45:18,130 --> 01:45:19,060
每个人都有自己的

2378
01:45:19,060 --> 01:45:21,040
语义上的并且它需要

2379
01:45:21,040 --> 01:45:23,110
一种能够处理

2380
01:45:23,110 --> 01:45:26,335
那种高度的去中心化，

2381
01:45:26,335 --> 01:45:28,435
我认为不会

2382
01:45:28,435 --> 01:45:29,560
特别是

2383
01:45:29,560 --> 01:45:31,030
当前看到的互联网是

2384
01:45:31,030 --> 01:45:32,649
一个非常显著的集中化

2385
01:45:32,649 --> 01:45:34,660
在当前时刻进入

2386
01:45:34,660 --> 01:45:37,135
进入你的本地化CDN，但

2387
01:45:37,135 --> 01:45:39,475
它真正设计的目的。

2388
01:45:39,475 --> 01:45:41,770
这是我觉得有趣的方面。

2389
01:45:41,770 --> 01:45:43,270
这又是我不知道是否有答案的地方。

2390
01:45:43,270 --> 01:45:45,475
我们正在努力寻找一些答案。

2391
01:45:45,475 --> 01:45:47,559
但是联合协调工作

2392
01:45:47,559 --> 01:45:48,400
这也被提到了

2393
01:45:48,400 --> 01:45:54,730
在计算或计算数据之间

2394
01:45:54,730 --> 01:45:56,530
显然是一个方面。

2395
01:45:56,530 --> 01:45:59,680
但这通常很重要，因为再一次，

2396
01:45:59,680 --> 01:46:01,119
选择计算方式

2397
01:46:01,119 --> 01:46:02,320
将严重依赖于来源地

2398
01:46:02,320 --> 01:46:04,300
数据来自于

2399
01:46:04,300 --> 01:46:06,595
以及它在哪里被测试，

2400
01:46:06,595 --> 01:46:08,650
以及它是一个非常艰巨的任务，

2401
01:46:08,650 --> 01:46:09,760
它是一个非常充满活力的任务。

2402
01:46:09,760 --> 01:46:11,695
它的动态性也被提及了，

2403
01:46:11,695 --> 01:46:14,780
这也是一个关键的方面。

2404
01:46:15,450 --> 01:46:18,565
>> 谢谢你。Ike，

2405
01:46:18,565 --> 01:46:20,770
既然你是新来的，

2406
01:46:20,770 --> 01:46:23,080
我们说过一个方式

2407
01:46:23,080 --> 01:46:26,380
来创建社区，

2408
01:46:26,380 --> 01:46:28,390
这是一次社区会议，

2409
01:46:28,390 --> 01:46:30,115
实际上是为了让人们参与进来

2410
01:46:30,115 --> 01:46:31,720
来自社区外部

2411
01:46:31,720 --> 01:46:33,580
社区内部，你是

2412
01:46:33,580 --> 01:46:36,010
询问NDN如何能够提供帮助。

2413
01:46:36,010 --> 01:46:38,424
让我们把问题反过来说

2414
01:46:38,424 --> 01:46:44,035
他们刚才说

2415
01:46:44,035 --> 01:46:45,970
~!@#$%^&*()

2416
01:46:45,970 --> 01:46:47,680
可能想要，因为那

2417
01:46:47,680 --> 01:46:49,285
这是我的一个问题。

2418
01:46:49,285 --> 01:46:51,610
这不是NDN也能提供的。

2419
01:46:51,610 --> 01:46:53,920
但是什么会是

2420
01:46:53,920 --> 01:46:56,260
需要在NDN中为你~!@#$%^&*()

2421
01:46:56,260 --> 01:46:59,275
可能意味着对它更感兴趣。

2422
01:46:59,275 --> 01:47:01,120
我知道，例如，

2423
01:47:01,120 --> 01:47:02,545
在我所做的一些工作中，

2424
01:47:02,545 --> 01:47:05,770
实际上是这个想法，拥有

2425
01:47:05,770 --> 01:47:07,090
更多的协调和

2426
01:47:07,090 --> 01:47:09,775
去中心化胜过性能，

2427
01:47:09,775 --> 01:47:15,655
特别是在分布非常广泛的地区。

2428
01:47:15,655 --> 01:47:18,130
~!@#$%^&*()

2429
01:47:18,130 --> 01:47:20,110
痛点和

2430
01:47:20,110 --> 01:47:22,180
你正在做的那可能是

2431
01:47:22,180 --> 01:47:25,510
一种本地数据中心的方法

2432
01:47:25,510 --> 01:47:27,235
可以解决的替代方法

2433
01:47:27,235 --> 01:47:29,140
可以添加的东西。

2434
01:47:29,140 --> 01:47:32,260
我明白客户端-服务器问题

2435
01:47:32,260 --> 01:47:35,360
不起作用，但还有其他办法吗？

2436
01:47:36,180 --> 01:47:40,990
是的。或许首先应该更好地描述它，

2437
01:47:40,990 --> 01:47:42,670
我实际上是处于

2438
01:47:42,670 --> 01:47:46,055
这整个工业网络空间。

2439
01:47:46,055 --> 01:47:48,180
我来自那里。

2440
01:47:48,180 --> 01:47:49,830
从计算机科学的角度来看，

2441
01:47:49,830 --> 01:47:51,510
在我们的研究项目中，

2442
01:47:51,510 --> 01:47:52,980
我们正在与很多

2443
01:47:52,980 --> 01:47:56,250
我们正在与很多化学工程师在那里~!@#$%^&*()

2444
01:47:56,250 --> 01:47:59,040
我们通常已经看到，即使是我们

2445
01:47:59,040 --> 01:48:02,730
现在说已经不够了。

2446
01:48:02,730 --> 01:48:05,774
IP和所有的互联网技术，

2447
01:48:05,774 --> 01:48:07,170
甚至将其带入

2448
01:48:07,170 --> 01:48:09,285
机械工程领域

2449
01:48:09,285 --> 01:48:12,280
挑战本身已经是如此。

2450
01:48:15,630 --> 01:48:19,270
我认为现在应该采取细小的步伐。

2451
01:48:19,270 --> 01:48:22,090
我认为现在应该采取细小的步伐，前往那里的路途，我认为那里最大的问题是~!@#$%^&*()

2452
01:48:22,090 --> 01:48:24,520
我认为那里最大的问题是

2453
01:48:24,520 --> 01:48:27,760
我认为那里最大的问题是化学工程师们，至少那些我知道他们习惯于

2454
01:48:27,760 --> 01:48:31,120
至少那些我知道他们习惯于

2455
01:48:31,120 --> 01:48:33,330
拥有固定功能的设备，所以

2456
01:48:33,330 --> 01:48:35,880
他们只是买了一个盒子，把它放在某个地方，

2457
01:48:35,880 --> 01:48:38,070
然后一切都解决了

2458
01:48:38,070 --> 01:48:40,080
然后一切都运作起来，他们不必

2459
01:48:40,080 --> 01:48:42,255
改变任何事情，如果我们想要拥有

2460
01:48:42,255 --> 01:48:45,580
真的，这些更具动态性的解决方案，

2461
01:48:45,600 --> 01:48:47,950
他们首先必须说服

2462
01:48:47,950 --> 01:48:49,450
他们首先必须说服，那样的事情实际上是可以在...管理的。

2463
01:48:49,450 --> 01:48:51,910
实际上是可以在...管理的。

2464
01:48:51,910 --> 01:48:55,360
所需投入的努力

2465
01:48:55,360 --> 01:48:57,670
以便它们不会

2466
01:48:57,670 --> 01:49:00,490
投入大量的

2467
01:49:00,490 --> 01:49:02,290
投入大量的时间去使它工作，

2468
01:49:02,290 --> 01:49:04,240
但他们基本上可以只是放置一个盒子

2469
01:49:04,240 --> 01:49:07,000
他们基本上可以只是放置一个盒子在那里并让它运行。

2470
01:49:07,000 --> 01:49:09,565
那显然也是什么

2471
01:49:09,565 --> 01:49:12,400
德克谈到了关于管弦乐编排的事情。

2472
01:49:12,400 --> 01:49:15,310
以及如何将计算和~!@#$%^&*()

2473
01:49:15,310 --> 01:49:18,550
将数据路径连接起来。

2474
01:49:18,550 --> 01:49:20,110
这也是一件事情，我

2475
01:49:20,110 --> 01:49:21,760
认为那可能是一个痛点

2476
01:49:21,760 --> 01:49:24,500
因为现在他们

2477
01:49:24,500 --> 01:49:27,400
有非常好的控制力

2478
01:49:27,400 --> 01:49:28,630
或者他们是如何放置下来的

2479
01:49:28,630 --> 01:49:32,410
功能性，仅仅通过放置这些盒子

2480
01:49:32,410 --> 01:49:34,750
可以适当地安排它们的设置位置

2481
01:49:34,750 --> 01:49:36,370
如果我们想要那样做，

2482
01:49:36,370 --> 01:49:37,690
用一种更热力学的方式，

2483
01:49:37,690 --> 01:49:39,760
我认为这真的非常关键，

2484
01:49:39,760 --> 01:49:42,070
that it's simple to define.

2485
01:49:42,070 --> 01:49:47,440
它很容易定义。

2486
01:49:47,440 --> 01:49:50,290
这些不同方面如何

2487
01:49:50,290 --> 01:49:53,125
互动就像我在幻灯片上展示的那样，如果我们，

2488
01:49:53,125 --> 01:49:54,760
例如，这取决于是哪种类型

2489
01:49:54,760 --> 01:49:55,960
正在出现的数据类型是什么，取决于它是什么形式。

2490
01:49:55,960 --> 01:49:57,220
它是什么形式

2491
01:49:57,220 --> 01:49:59,020
它出现在我们想要发送它的地方。

2492
01:49:59,020 --> 01:50:01,480
这确实可以被定义在

2493
01:50:01,480 --> 01:50:03,070
一种易于理解的方式来

2494
01:50:03,070 --> 01:50:05,755
它们不需要那么多的开销。

2495
01:50:05,755 --> 01:50:06,880
至少那是什么

2496
01:50:06,880 --> 01:50:09,805
我会这样说关于这个话题。

2497
01:50:09,805 --> 01:50:12,025
我认为现在，

2498
01:50:12,025 --> 01:50:13,315
在中间

2499
01:50:13,315 --> 01:50:15,400
部署这些东西的人在

2500
01:50:15,400 --> 01:50:19,930
商店的损失以及NDN社区正在尝试如何部署这些东西的人在…找出它如何可以被部署

2501
01:50:19,930 --> 01:50:22,900
找出它如何可以被部署

2502
01:50:22,900 --> 01:50:26,515
他们对两者都有外部的看法，

2503
01:50:26,515 --> 01:50:31,420
或者我想，我会在这两个领域都救助你。

2504
01:50:31,420 --> 01:50:34,105
>> 你的好名声，大使。

2505
01:50:34,105 --> 01:50:36,100
~!@#$%^&*()

2506
01:50:36,100 --> 01:50:39,040
[笑声].

2507
01:50:39,040 --> 01:50:39,970
我没有看到很多

2508
01:50:39,970 --> 01:50:41,380
在Slack上，人们仍在讨论许多问题。

2509
01:50:41,380 --> 01:50:43,570
在Slack上，人们仍在讨论许多问题。

2510
01:50:43,570 --> 01:50:46,390
上一次最后的休息。

2511
01:50:46,390 --> 01:50:48,710
>> 玛利亚，我能快速分享一个评论吗？

2512
01:50:48,710 --> 01:50:50,570
>> 好的，请说。我本来想说的是

2513
01:50:50,570 --> 01:50:51,770
有谁还来自~!@#$%^&*()

2514
01:50:51,770 --> 01:50:54,065
观众？请继续，Rute。

2515
01:50:54,065 --> 01:50:56,945
>> 我同意Ike的观点，很快地说一下。

2516
01:50:56,945 --> 01:51:00,830
但我只想评论一些事情。

2517
01:51:00,830 --> 01:51:03,590
我一直在传达的内容

2518
01:51:03,590 --> 01:51:05,615
与表现无关。

2519
01:51:05,615 --> 01:51:08,150
这与谁最好无关。

2520
01:51:08,150 --> 01:51:09,950
事实上，这不仅仅是

2521
01:51:09,950 --> 01:51:11,600
说服机械工程师，

2523
01:51:13,670 --> 01:51:15,200
在过去的，

2524
01:51:15,200 --> 01:51:16,610
我不是五、六年。

2525
01:51:16,610 --> 01:51:19,940
我已经与大型供应商进行了谈话，试图

2526
01:51:19,940 --> 01:51:21,980
说服他们进行一些研究

2527
01:51:21,980 --> 01:51:24,140
to convince them to conduct some research on NDN to understand, as Dirk saying, the capability, for instance,

2528
01:51:24,140 --> 01:51:26,360
正如德克所说的，例如，能力，

2529
01:51:26,360 --> 01:51:27,080
提供

2530
01:51:27,080 --> 01:51:28,760
分布式数据同步，

2531
01:51:28,760 --> 01:51:29,030
分布式数据同步是一个他们实际上遇到的关键问题。

2532
01:51:29,030 --> 01:51:31,235
他们实际上遇到的一个关键问题。

2533
01:51:31,235 --> 01:51:33,020
理解它是否可能

2534
01:51:33,020 --> 01:51:36,815
支持本能时序模型等。

2535
01:51:36,815 --> 01:51:39,110
我们有同样的问题。答案是不。

2536
01:51:39,110 --> 01:51:40,490
他们不想做这个。

2537
01:51:40,490 --> 01:51:42,290
因为他们认为这没有任何价值。

2538
01:51:42,290 --> 01:51:43,655
如果我说好的，

2539
01:51:43,655 --> 01:51:46,220
但是最后的结局确实已经到来了

2540
01:51:46,220 --> 01:51:49,670
一些分布式同步方法

2541
01:51:49,670 --> 01:51:50,810
它们是非常，

2542
01:51:50,810 --> 01:51:53,975
它们非常有趣，因为正如Dirk所说，

2543
01:51:53,975 --> 01:51:56,510
它让我们能够拥有

2544
01:51:56,510 --> 01:51:57,800
计算机和网络

2545
01:51:57,800 --> 01:51:59,615
还有作者部分。

2546
01:51:59,615 --> 01:52:01,670
答案总是我们可以做到

2547
01:52:01,670 --> 01:52:03,815
它与其他方法相比。

2548
01:52:03,815 --> 01:52:05,480
在我的幻灯片中，我不知道你~!@#$%^&*()

2549
01:52:05,480 --> 01:52:07,490
看到我们正在比较NDN。

2550
01:52:07,490 --> 01:52:09,080
再一次，这不是性能问题，而是

2551
01:52:09,080 --> 01:52:10,835
Once again, this is not a performance issue, but rather the discovery aspects and trying to understand also.

2552
01:52:10,835 --> 01:52:12,380
发现方面以及

2553
01:52:12,380 --> 01:52:15,080
前缀的同步。

2554
01:52:15,080 --> 01:52:17,300
如果我们能说的话，理解起来是没问题的。

2555
01:52:17,300 --> 01:52:19,595
“嘿，这是一个具体的优势。”

2556
01:52:19,595 --> 01:52:22,565
我们正在将其与COTI进行比较，后者是

2557
01:52:22,565 --> 01:52:26,390
一个开源的去中心化方法

2558
01:52:26,390 --> 01:52:28,775
被一个大供应商僵持住了。

2559
01:52:28,775 --> 01:52:30,845
非常有趣的是

2560
01:52:30,845 --> 01:52:33,425
物联网中的协作通信。

2561
01:52:33,425 --> 01:52:36,560
这是一个常规应用程序。

2562
01:52:36,560 --> 01:52:38,540
它是面向通信的。

2563
01:52:38,540 --> 01:52:40,550
它采用的方法进行发现和

2564
01:52:40,550 --> 01:52:43,940
数据同步。

2565
01:52:43,940 --> 01:52:47,100
基本上，他们认为这已经足够了。

2566
01:52:47,560 --> 01:52:50,270
从计算的角度来看或

2567
01:52:50,270 --> 01:52:52,040
从计算的角度来看或

2568
01:52:52,040 --> 01:52:53,854
从理论的角度来看

2569
01:52:53,854 --> 01:52:55,850
确实具有有趣的特性。

2570
01:52:55,850 --> 01:52:58,040
我们实际上必须证明那个，或者至少要

2571
01:52:58,040 --> 01:52:59,360
证明它在运行一个

2572
01:52:59,360 --> 01:53:00,965
有点像Ike所说的。

2573
01:53:00,965 --> 01:53:02,720
我们需要知道他们为什么要安装NDN，

2574
01:53:02,720 --> 01:53:04,025
以便我们可以展示，嘿，

2575
01:53:04,025 --> 01:53:05,690
这是它如何运行的。

2576
01:53:05,690 --> 01:53:08,520
我们还做了一些额外的工作。

2577
01:53:10,000 --> 01:53:12,290
>> 我可以补充一点吗？

2578
01:53:12,290 --> 01:53:13,610
>> 好的，请说。

2579
01:53:13,610 --> 01:53:16,070
>> 我完全同意Rute的看法，实际上，

2580
01:53:16,070 --> 01:53:19,340
这也是我们的观察结果。

2581
01:53:19,340 --> 01:53:20,870
如果有什么事情

2582
01:53:20,870 --> 01:53:22,850
已经可以通过IP工作了或者

2583
01:53:22,850 --> 01:53:24,110
可以被使得工作

2584
01:53:24,110 --> 01:53:26,210
通过添加一点代码，

2585
01:53:26,210 --> 01:53:27,560
或即使它不优雅，

2586
01:53:27,560 --> 01:53:29,585
即使它笨重且混杂不堪，

2587
01:53:29,585 --> 01:53:31,505
他们会说，我宁愿做那个，

2588
01:53:31,505 --> 01:53:33,650
宁愿去NDN。

2589
01:53:33,650 --> 01:53:35,240
那部分是我在哪里

2590
01:53:35,240 --> 01:53:37,340
他们也提出了一个表演的想法。

2591
01:53:37,340 --> 01:53:38,780
他们想看到一些东西

2592
01:53:38,780 --> 01:53:41,240
他们想看到一些东西，如果他们面临的问题是其他的大问题，不管那是什么。

2593
01:53:41,240 --> 01:53:43,790
他们如果面临一个他们无法解决的问题，

2594
01:53:43,790 --> 01:53:46,160
他们绝对无法解决，

2595
01:53:46,160 --> 01:53:47,870
然后我们给他们提供解决方案，

2596
01:53:47,870 --> 01:53:49,310
是的，会有更多人愿意接受它。

2597
01:53:49,310 --> 01:53:51,320
但让我们诚实一点，你总是可以

2598
01:53:51,320 --> 01:53:52,910
不管它是否是

2599
01:53:52,910 --> 01:53:54,470
不管它是否是杂乱无章或不雅观。

2600
01:53:54,470 --> 01:53:55,820
你可以想办法去做

2601
01:53:55,820 --> 01:53:57,650
~!@#$%^&*()

2602
01:53:57,650 --> 01:53:59,210
也许它不会那么容易扩展

2603
01:53:59,210 --> 01:54:00,890
也许它不是那么横向发展的，

2604
01:54:00,890 --> 01:54:03,140
但你可以设法找到一个方法去做到这一点

2605
01:54:03,140 --> 01:54:04,490
而且他们更愿意

2606
01:54:04,490 --> 01:54:06,215
沿着那些思路去做。

2607
01:54:06,215 --> 01:54:07,940
那是公平的。

2608
01:54:07,940 --> 01:54:09,530
其他的观点是，

2609
01:54:09,530 --> 01:54:12,260
如果Endian社区能够使其变得简单，

2610
01:54:12,260 --> 01:54:13,400
年龄当然会显示出来。

2611
01:54:13,400 --> 01:54:14,870
福利可以使事情变得简单，

2612
01:54:14,870 --> 01:54:16,940
有代码、标签或插件说，

2613
01:54:16,940 --> 01:54:18,590
嘿，就把那个放在这里

2614
01:54:18,590 --> 01:54:20,690
你可以保持你的代码原样，

2615
01:54:20,690 --> 01:54:22,640
但是你可以加入所有这些额外的功能。

2616
01:54:22,640 --> 01:54:24,020
但是你可以加入~!@#$%^&*()

2617
01:54:24,020 --> 01:54:26,810
为现有的事物添加特性，

2618
01:54:26,810 --> 01:54:29,780
我相信该行业

2619
01:54:29,780 --> 01:54:32,010
将会更加欢迎。

2620
01:54:32,170 --> 01:54:34,880
>> 我本来要说这实际上是

2621
01:54:34,880 --> 01:54:37,520
一个完美的过渡到下一个讨论小组，

2622
01:54:37,520 --> 01:54:38,840
将会稍微看起来有一点

2623
01:54:38,840 --> 01:54:40,370
will look a little bit about these aspects and I think what you are

2624
01:54:40,370 --> 01:54:42,860
认为你是什么

2625
01:54:42,860 --> 01:54:45,470
认为每个人都是，我认为，

2626
01:54:45,470 --> 01:54:48,290
一个值得深思的家庭寓言教训

2627
01:54:48,290 --> 01:54:49,850
社区在这个意义上

2628
01:54:49,850 --> 01:54:52,280
在这方面有很多能力，

2629
01:54:52,280 --> 01:54:53,945
而且更糟的是，

2630
01:54:53,945 --> 01:54:56,120
我认为有很多需求。

2631
01:54:56,120 --> 01:54:58,670
我认为有很多需求。

2632
01:54:58,670 --> 01:55:01,160
NDN有很多解决方案，而我

2633
01:55:01,160 --> 01:55:03,530
我认为也许社区应该做得更好工作，

2634
01:55:03,530 --> 01:55:07,235
做得更好的工作，

2635
01:55:07,235 --> 01:55:08,975
为了更恰当地表达(如果没有更合适的词汇的话)，

2636
01:55:08,975 --> 01:55:12,960
在展示这些能力存在方面。

2637
01:55:13,000 --> 01:55:15,050
对于你们这些人来说

2638
01:55:15,050 --> 01:55:17,330
在工业领域，另一个问题

2639
01:55:17,330 --> 01:55:22,500
总是被提出的另一个问题是成本问题。

2640
01:55:22,780 --> 01:55:25,910
您提到的仅仅是

2641
01:55:25,910 --> 01:55:27,335
增加了几行代码，

2642
01:55:27,335 --> 01:55:30,200
它不是很好，

2643
01:55:30,200 --> 01:55:31,250
但它不耗费时间。

2644
01:55:31,250 --> 01:55:32,630
它不需要很多资源。

2645
01:55:32,630 --> 01:55:34,190
而且花费不多。

2646
01:55:34,190 --> 01:55:35,990
这是一方面，我认为

2647
01:55:35,990 --> 01:55:38,465
这还涉及到金钱的问题。

2648
01:55:38,465 --> 01:55:41,930
我们有时间回答一到两个问题。

2649
01:55:41,930 --> 01:55:43,685
来自观众的。

2650
01:55:43,685 --> 01:55:46,130
但是来自观众的那些人，

2651
01:55:46,130 --> 01:55:51,695
大型网络延迟容忍网络(NDN)社区的主要参与者，

2652
01:55:51,695 --> 01:55:54,320
~!@#$%^&*()

2653
01:55:54,320 --> 01:55:56,240
这个面板是谁？

2654
01:55:56,240 --> 01:55:59,285
实际上是在寻求更好的解决方案吗？

2655
01:55:59,285 --> 01:56:01,130
有人想聊天吗？

2656
01:56:01,130 --> 01:56:04,350
如果没有人想聊天，我就去找别人聊。

2657
01:56:06,070 --> 01:56:10,020
哇，你们今天都很害羞啊。

2658
01:56:12,940 --> 01:56:15,530
>> 我要提一个问题。

2659
01:56:15,530 --> 01:56:17,105
>> 请说。

2660
01:56:17,105 --> 01:56:19,190
>> 这是有趣的讨论

2661
01:56:19,190 --> 01:56:21,300
关于表现。

2662
01:56:22,960 --> 01:56:25,460
到目前为止，我的意思是，

2663
01:56:25,460 --> 01:56:27,320
到目前为止，NDN的表现还没有

2664
01:56:27,320 --> 01:56:30,605
达到了预期的效果，因为它还处于实验阶段。

2665
01:56:30,605 --> 01:56:32,090
这是可以理解的。

2666
01:56:32,090 --> 01:56:36,440
但是你看见了吗？

2667
01:56:36,440 --> 01:56:38,660
性能的缺失

2668
01:56:38,660 --> 01:56:41,310
将人们从NDN赶走？

2669
01:56:44,710 --> 01:56:47,795
>> ~!@#$%^&*()

2670
01:56:47,795 --> 01:56:51,200
>> 当然。正如我所说，关键是，我的意思是，

2671
01:56:51,200 --> 01:56:52,520
如果我们稍微退后一点儿

2672
01:56:52,520 --> 01:56:54,110
从仅仅是表现来看，

2673
01:56:54,110 --> 01:56:56,585
业界固守旧习，

2674
01:56:56,585 --> 01:56:58,085
因缺乏更合适的词汇。

2675
01:56:58,085 --> 01:56:59,390
因为代码量很大，

2676
01:56:59,390 --> 01:57:00,530
有着如此悠久的历史，

2677
01:57:00,530 --> 01:57:02,030
有着如此悠久的历史，在其中花费了很多时间来

2678
01:57:02,030 --> 01:57:04,310
发展他们所拥有的一切；

2679
01:57:04,310 --> 01:57:05,765
系统、基于代码的

2680
01:57:05,765 --> 01:57:07,415
软件，所有这些。

2681
01:57:07,415 --> 01:57:09,530
为了改变这一点，

2682
01:57:09,530 --> 01:57:11,195
你需要一个司机。

2683
01:57:11,195 --> 01:57:13,430
现在，他们中的一个

2684
01:57:13,430 --> 01:57:14,750
肯定可以是表现。

2685
01:57:14,750 --> 01:57:17,615
我认为我们在说的是我们需要

2686
01:57:17,615 --> 01:57:19,385
无论那个司机是什么

2687
01:57:19,385 --> 01:57:21,350
那更大的推动力需要到来。

2688
01:57:21,350 --> 01:57:23,585
那么，如果是性能的话，它可以成为……

2689
01:57:23,585 --> 01:57:26,480
是的，当然那将是一个驱动因素。

2690
01:57:26,480 --> 01:57:28,640
另一个同样会

2691
01:57:28,640 --> 01:57:30,320
便利是如果它

2692
01:57:30,320 --> 01:57:33,590
容易是因为假设，

2693
01:57:33,590 --> 01:57:34,895
我有我的 Kubernetes 应用程序，

2694
01:57:34,895 --> 01:57:36,590
那么嘿，我们都知道

2695
01:57:36,590 --> 01:57:38,555
Kubernetes存在许多问题。

2696
01:57:38,555 --> 01:57:39,860
它不进行服务发现，它

2697
01:57:39,860 --> 01:57:41,120
它不适应网络变化

2698
01:57:41,120 --> 01:57:42,680
~!@#$%^&*()

2699
01:57:42,680 --> 01:57:43,760
>> 如果你能说，“嘿，

2700
01:57:43,760 --> 01:57:47,150
只需安装这个NDN插件然后就放上去

2701
01:57:47,150 --> 01:57:48,650
将这些安装在所有这些节点上的集群中，

2702
01:57:48,650 --> 01:57:49,460
设备，突然

2703
01:57:49,460 --> 01:57:50,675
你将拥有这些能力。

2704
01:57:50,675 --> 01:57:51,950
你仍然会得到一切。

2705
01:57:51,950 --> 01:57:53,195
你拥有的其他一切。

2706
01:57:53,195 --> 01:57:56,480
如果我们能让转变变得容易，

2707
01:57:56,480 --> 01:57:58,100
那些额外的好处是

2708
01:57:58,100 --> 01:58:00,275
很可能会被接受。

2709
01:58:00,275 --> 01:58:02,225
我不知道那是否回答了你的问题。

2710
01:58:02,225 --> 01:58:06,830
确实如此。我们

2711
01:58:06,830 --> 01:58:08,240
确实如此。我们

2712
01:58:08,240 --> 01:58:10,115
NDN让很多通话变得更加容易。

2713
01:58:10,115 --> 01:58:12,035
但是当你给用户

2714
01:58:12,035 --> 01:58:13,790
让他们的生活变得更轻松的事情，

2715
01:58:13,790 --> 01:58:16,490
他们接下来提出的问题是，

2716
01:58:16,490 --> 01:58:19,320
我怎样才能使它表现得更好？

2717
01:58:19,480 --> 01:58:23,570
Kubernetes，这与NDN很搭。

2718
01:58:23,570 --> 01:58:25,610
那么他们就会抱怨说，

2719
01:58:25,610 --> 01:58:27,395
那么，我的表现在哪里？

2720
01:58:27,395 --> 01:58:30,800
你是如何回答那个问题的？

2721
01:58:30,800 --> 01:58:32,570
那是一个非常好的观点。那是我~!@#$%^&*()

2722
01:58:32,570 --> 01:58:34,220
think the merging IP and NDN needs to happen

认为IP和NDN的合并需要发生

2723
01:58:34,220 --> 01:58:35,975
NDN需要发生。

2724
01:58:35,975 --> 01:58:37,760
有点好转，因为让我们诚实一点，

2725
01:58:37,760 --> 01:58:39,170
IP不会消失。

2726
01:58:39,170 --> 01:58:40,400
所以问题是，我们怎样能够~!@#$%^&*()

2727
01:58:40,400 --> 01:58:42,590
增加NDN的好处？

2728
01:58:42,590 --> 01:58:44,690
Regarding your question, it is about how...

2729
01:58:44,690 --> 01:58:46,340
你能提高性能吗？

2730
01:58:46,340 --> 01:58:48,605
已经有很多关于知识产权的研究在进行中。

2731
01:58:48,605 --> 01:58:51,065
这个问题是，那些能翻译吗？

2732
01:58:51,065 --> 01:58:53,420
并不是所有的事情都必须用NDN来完成。

2733
01:58:53,420 --> 01:58:55,115
您只需说NDN带来了

2734
01:58:55,115 --> 01:58:57,395
所有这些附加功能

2735
01:58:57,395 --> 01:58:58,730
以一种更加简单的方式。

2736
01:58:58,730 --> 01:58:59,960
但是，你仍然可以

2737
01:58:59,960 --> 01:59:02,660
也许可以在IP上进行你的优化。

2738
01:59:02,660 --> 01:59:04,820
也谈到了性能表现，

2739
01:59:04,820 --> 01:59:06,425
我提到的那几点，

2740
01:59:06,425 --> 01:59:08,240
NDN的性能确实更好。

2741
01:59:08,240 --> 01:59:10,490
实际上，在什么情况下

2742
01:59:10,490 --> 01:59:12,890
我们发现的是资源的极端动态性。

2743
01:59:12,890 --> 01:59:16,160
Kubernetes 目前还不能处理这个问题。

2744
01:59:16,160 --> 01:59:17,870
有一些小口袋

2745
01:59:17,870 --> 01:59:19,520
NDN表现得更好。

2746
01:59:19,520 --> 01:59:21,350
关键是你如何去整合

2747
01:59:21,350 --> 01:59:23,045
你如何将其与其他所有事物整合在一起？

2748
01:59:23,045 --> 01:59:24,350
总体而言，表现

2749
01:59:24,350 --> 01:59:26,090
增长而不失去已有的东西

2750
01:59:26,090 --> 01:59:28,020
他们已经拥有的。

2751
01:59:28,030 --> 01:59:30,185
我不知道这是否有帮助。

2752
01:59:30,185 --> 01:59:33,200
是的。我认为我们的时间都用完了。

2753
01:59:33,200 --> 01:59:36,695
我做了一些简短的笔记。

2754
01:59:36,695 --> 01:59:41,480
如果我再次查看这里的笔记，

2755
01:59:41,480 --> 01:59:43,880
请注意，这是一个非常好的过渡。

2756
01:59:43,880 --> 01:59:45,305
进入你自己的面板。

2757
01:59:45,305 --> 01:59:48,710
我认为这里有一个问题需要解决。

2758
01:59:48,710 --> 01:59:51,995
确信NDN本质上

2759
01:59:51,995 --> 01:59:54,800
被认为是一个潜在的解决方案在

2760
01:59:54,800 --> 01:59:58,610
他人正在应对的世界。

2761
01:59:58,610 --> 01:59:59,960
这样的表现是

2762
01:59:59,960 --> 02:00:03,695
这些事情有些人是知道的，有些人却不知道。

2763
02:00:03,695 --> 02:00:09,560
需要更好地整合

2764
02:00:09,560 --> 02:00:11,390
需要更好地整合数据系统与主要功能进行~!@#$%^&*()

2765
02:00:11,390 --> 02:00:13,460
需要与主要功能进行

2766
02:00:13,460 --> 02:00:15,530
回到Dirk的问题，

2767
02:00:15,530 --> 02:00:17,870
如果数据是解决方案，那么问题是什么？

2768
02:00:17,870 --> 02:00:19,025
我认为它正在

2769
02:00:19,025 --> 02:00:21,590
所有这些分布式的系统，

2770
02:00:21,590 --> 02:00:24,560
协同工作的方式，

2771
02:00:24,560 --> 02:00:27,380
功能性和生产力强的，

2772
02:00:27,380 --> 02:00:29,150
功能性和生产力强的，并且表现出色的方式。

2773
02:00:29,150 --> 02:00:32,210
非常感谢你们四位。

2774
02:00:32,210 --> 02:00:34,475
非常感谢各位观众。

2775
02:00:34,475 --> 02:00:37,590
你太安静了，不过没关系。

2776
02:00:38,410 --> 02:00:40,550
我认为这里在东海岸，是午餐时间。

2777
02:00:40,550 --> 02:00:42,425
东海岸，现在是午餐时间。

2778
02:00:42,425 --> 02:00:44,855
我觉得Dirk，你要去吃晚饭了。

2779
02:00:44,855 --> 02:00:47,000
我很想

2780
02:00:47,000 --> 02:00:49,820
继续讨论这个团队。

2781
02:00:49,820 --> 02:00:51,515
非常感谢大家。

2782
02:00:51,515 --> 02:00:53,600
我们很可能会见到

2783
02:00:53,600 --> 02:00:56,060
我们很可能会见到，在某个不同的Zoom会议中，彼此相遇。

2784
02:00:56,060 --> 02:00:58,140
在某个时刻。谢谢你。

2785
02:00:59,380 --> 02:01:01,520
>> 谢谢你。再见。

2786
02:01:01,520 --> 02:01:05,480
~!@#$%^&*()

2787
02:01:05,480 --> 02:01:06,785
>> 谢谢大家。

2788
02:01:06,785 --> 02:01:09,930
我们将在下午1点回来。

