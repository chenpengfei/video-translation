1
00:00:00,200 --> 00:00:02,700
>> Hey, welcome
back everyone

2
00:00:02,700 --> 00:00:04,290
to session number 6,

3
00:00:04,290 --> 00:00:05,700
which would be chaired

4
00:00:05,700 --> 00:00:08,175
by Christos Papadopoulos.

5
00:00:08,175 --> 00:00:11,160
Christos is known to
most of you and was

6
00:00:11,160 --> 00:00:14,700
just introduced to in
panel that just ended.

7
00:00:14,700 --> 00:00:18,910
Christos you can
go ahead, please.

8
00:00:19,670 --> 00:00:22,215
>> Thank you Lotfi no
need to introduce me.

9
00:00:22,215 --> 00:00:24,420
For the for the
sake of time,

10
00:00:24,420 --> 00:00:25,460
but I think I'm
going to jump

11
00:00:25,460 --> 00:00:28,080
directly into
introductions.

12
00:00:28,340 --> 00:00:30,860
I think we have
about a 100 minutes

13
00:00:30,860 --> 00:00:32,120
and five presentations.

14
00:00:32,120 --> 00:00:34,445
About 20 minutes
per presentation.

15
00:00:34,445 --> 00:00:36,320
To the presenters,
I'll try to

16
00:00:36,320 --> 00:00:38,360
turn on my video
when we're getting

17
00:00:38,360 --> 00:00:39,710
close to the end
of your time

18
00:00:39,710 --> 00:00:40,940
so you can see me and

19
00:00:40,940 --> 00:00:44,050
then I'll give you
a verbal cue also.

20
00:00:44,050 --> 00:00:46,695
The first presenter
is Kathleen Nichols,

21
00:00:46,695 --> 00:00:48,850
who is the CTO of Pollere.

22
00:00:48,850 --> 00:00:50,300
She received a PhD

23
00:00:50,300 --> 00:00:51,560
in electrical
engineering from

24
00:00:51,560 --> 00:00:54,120
UC Berkeley and she

25
00:00:54,120 --> 00:00:56,130
says she claims
a long time ago.

26
00:00:56,130 --> 00:00:58,790
Her current interests
are in using

27
00:00:58,790 --> 00:01:00,995
NDM to solve edge
network problems,

28
00:01:00,995 --> 00:01:03,200
which has led to
the development of

29
00:01:03,200 --> 00:01:05,225
the open source
Delta Centric

30
00:01:05,225 --> 00:01:06,890
tool kit or DCT.

31
00:01:06,890 --> 00:01:09,290
Although she retains
a soft spot for

32
00:01:09,290 --> 00:01:12,345
network measurement.
Kathy, please go ahead.

33
00:01:12,345 --> 00:01:13,990
>> Okay. I guess I need to

34
00:01:13,990 --> 00:01:16,390
start sharing my screen.

35
00:01:16,390 --> 00:01:19,845
[NOISE] Let's try this
out and it worked,

36
00:01:19,845 --> 00:01:22,720
but there's key note.

37
00:01:30,020 --> 00:01:32,280
Are you seeing it?

38
00:01:32,280 --> 00:01:34,485
>> Yes. This is
good thank you.

39
00:01:34,485 --> 00:01:37,700
>> Okay. I just

40
00:01:37,700 --> 00:01:40,730
wanted to say that
I was doing this in

41
00:01:40,730 --> 00:01:44,490
the general spirit of

42
00:01:49,100 --> 00:01:52,470
a community meeting
and talking

43
00:01:52,470 --> 00:01:55,540
about this is some
things that we

44
00:01:55,540 --> 00:01:56,740
should be thinking
out taking

45
00:01:56,740 --> 00:01:58,690
a look at and I'm

46
00:01:58,690 --> 00:02:00,280
definitely not an expert

47
00:02:00,280 --> 00:02:02,110
in industrial
applications,

48
00:02:02,110 --> 00:02:03,970
like many of the people

49
00:02:03,970 --> 00:02:05,500
in the panel
earlier today,

50
00:02:05,500 --> 00:02:08,605
which was really
just a great animal.

51
00:02:08,605 --> 00:02:10,750
I wanted to make

52
00:02:10,750 --> 00:02:12,760
sure I got that
out of the way.

53
00:02:12,760 --> 00:02:20,515
[inaudible] I
wanted to say,

54
00:02:20,515 --> 00:02:22,660
a couple of things
that I think

55
00:02:22,660 --> 00:02:24,595
are really important
to keep in mind.

56
00:02:24,595 --> 00:02:27,205
I feel like it's
time for NDN to

57
00:02:27,205 --> 00:02:30,785
show its value by solving
some hard problems.

58
00:02:30,785 --> 00:02:32,645
I really think we have to

59
00:02:32,645 --> 00:02:35,000
show and not tell and I

60
00:02:35,000 --> 00:02:36,950
don't think I'm alone
in that based on

61
00:02:36,950 --> 00:02:39,900
some things that were
said earlier today.

62
00:02:39,900 --> 00:02:42,650
In this particular area,

63
00:02:42,650 --> 00:02:44,660
in addition to
the things we

64
00:02:44,660 --> 00:02:46,670
heard about in the
panel earlier,

65
00:02:46,670 --> 00:02:50,540
our NIST colleagues are
also able to point us

66
00:02:50,540 --> 00:02:53,975
at the value that

67
00:02:53,975 --> 00:02:57,499
has been solving
hard problems,

68
00:02:57,499 --> 00:02:59,880
try and get rid of
all those chunks.

69
00:03:03,800 --> 00:03:05,900
You see, I can't

70
00:03:05,900 --> 00:03:07,310
tell exactly what
I'm sharing.

71
00:03:07,310 --> 00:03:13,970
[LAUGHTER] I think
that we should

72
00:03:13,970 --> 00:03:15,680
look at the operational

73
00:03:15,680 --> 00:03:17,120
technologies because it

74
00:03:17,120 --> 00:03:18,185
has issues that

75
00:03:18,185 --> 00:03:20,755
conventional networking
doesn't address.

76
00:03:20,755 --> 00:03:23,480
I also think that
this requires

77
00:03:23,480 --> 00:03:25,685
a somewhat different
approach from

78
00:03:25,685 --> 00:03:28,370
the NDN-based Future
Internet work.

79
00:03:28,370 --> 00:03:31,250
It just how NDN
got started.

80
00:03:31,250 --> 00:03:34,880
We need to think a
little bit about that.

81
00:03:34,880 --> 00:03:36,590
What is it that we need

82
00:03:36,590 --> 00:03:39,550
for these types
of applications?

83
00:03:39,550 --> 00:03:43,670
I'm using these
particular definitions.

84
00:03:43,670 --> 00:03:46,790
The one for operational
technology is

85
00:03:46,790 --> 00:03:50,270
coming from this
website and

86
00:03:50,270 --> 00:03:53,210
also Wikipedia has

87
00:03:53,210 --> 00:03:57,045
some further calls
it like this,

88
00:03:57,045 --> 00:04:00,320
so-called IT in the
non carpeted areas.

89
00:04:00,320 --> 00:04:01,820
I also want to use

90
00:04:01,820 --> 00:04:04,400
the term conventional
networking

91
00:04:04,400 --> 00:04:06,740
because a lot
of times people

92
00:04:06,740 --> 00:04:09,695
talk about like
NDN versus IP.

93
00:04:09,695 --> 00:04:13,975
But NDN does run over
IP and that seems,

94
00:04:13,975 --> 00:04:15,860
with few
exceptions, that's

95
00:04:15,860 --> 00:04:17,740
mostly the way
we're using it.

96
00:04:17,740 --> 00:04:18,950
It's certainly the way

97
00:04:18,950 --> 00:04:20,660
that I've been using it.

98
00:04:20,660 --> 00:04:24,495
But yet NDN is not
conventional networking.

99
00:04:24,495 --> 00:04:28,400
I'm thinking of it
as NDN versus CN.

100
00:04:28,400 --> 00:04:30,225
Finally, things,

101
00:04:30,225 --> 00:04:31,575
I'm going to use

102
00:04:31,575 --> 00:04:35,720
RFC8520 definition of a
group of objects that

103
00:04:35,720 --> 00:04:38,000
are specifically
not intended to be

104
00:04:38,000 --> 00:04:42,210
used for general purpose
computing tasks.

105
00:04:50,750 --> 00:04:52,260
That here.

106
00:04:52,260 --> 00:04:56,960
[LAUGHTER] The OT networks
have increasingly

107
00:04:56,960 --> 00:04:59,630
become wireless and
this makes it really

108
00:04:59,630 --> 00:05:00,890
difficult for it to use

109
00:05:00,890 --> 00:05:03,170
its traditional
security approaches,

110
00:05:03,170 --> 00:05:04,985
which were things
like firewalls and

111
00:05:04,985 --> 00:05:07,515
air gaps and the idea,

112
00:05:07,515 --> 00:05:09,630
if you had this a wire

113
00:05:09,630 --> 00:05:11,270
where there was
only one thing at

114
00:05:11,270 --> 00:05:12,650
the end of the wire

115
00:05:12,650 --> 00:05:16,000
that authentication
becomes easier.

116
00:05:16,000 --> 00:05:19,920
The area of Zero Trust
Architectures with

117
00:05:19,920 --> 00:05:23,840
their never trust and
always verify approach.

118
00:05:23,840 --> 00:05:26,210
They tried to address
this by using

119
00:05:26,210 --> 00:05:28,835
TCP and TLS encryption.

120
00:05:28,835 --> 00:05:30,930
But in CN these

121
00:05:30,930 --> 00:05:37,865
the ad hoc conversational
communications

122
00:05:37,865 --> 00:05:39,200
are going to make
it really hard

123
00:05:39,200 --> 00:05:41,695
to establish trust
relationships.

124
00:05:41,695 --> 00:05:45,290
Unlike IT networks,
OT networks are

125
00:05:45,290 --> 00:05:46,850
restricting the roles in

126
00:05:46,850 --> 00:05:49,235
communications and
intent for their things.

127
00:05:49,235 --> 00:05:53,075
That makes it really
different where in IT,

128
00:05:53,075 --> 00:05:55,310
we want more of
the ability to

129
00:05:55,310 --> 00:05:59,325
say many things
to many places.

130
00:05:59,325 --> 00:06:02,260
In RFC 8520 notes

131
00:06:02,260 --> 00:06:04,850
that there's just
a small number of

132
00:06:04,850 --> 00:06:07,040
communications patterns
that come out of

133
00:06:07,040 --> 00:06:10,070
those restricted
roles and intentions,

134
00:06:10,070 --> 00:06:12,410
which important
to think of too.

135
00:06:12,410 --> 00:06:15,320
It says, while these
patterns can be

136
00:06:15,320 --> 00:06:16,160
expressed as

137
00:06:16,160 --> 00:06:18,545
Manufacturer Usage
Descriptions,

138
00:06:18,545 --> 00:06:20,390
and we have
similar concepts

139
00:06:20,390 --> 00:06:22,220
in Matter and ZigBee and

140
00:06:22,220 --> 00:06:23,989
the OneData Model
descriptions

141
00:06:23,989 --> 00:06:26,585
we're really
describing things

142
00:06:26,585 --> 00:06:28,850
in a very constrained
way and the

143
00:06:28,850 --> 00:06:31,730
ways they can interact
is constraint.

144
00:06:31,730 --> 00:06:35,540
We're trying to use that

145
00:06:35,540 --> 00:06:39,425
and go one further
than that.

146
00:06:39,425 --> 00:06:41,840
But what they do with MUD

147
00:06:41,840 --> 00:06:43,940
is they can only enforce

148
00:06:43,940 --> 00:06:45,170
those patterns using

149
00:06:45,170 --> 00:06:47,210
conventional
network through

150
00:06:47,210 --> 00:06:48,260
this things like

151
00:06:48,260 --> 00:06:52,115
externally applied
Access Control Lists.

152
00:06:52,115 --> 00:06:54,350
There's NIST publication

153
00:06:54,350 --> 00:06:56,420
that discusses
applications of

154
00:06:56,420 --> 00:06:57,920
MUD to small business and

155
00:06:57,920 --> 00:07:00,835
home IoT, which
is interesting.

156
00:07:00,835 --> 00:07:04,215
This picture is
from RFC 8520,

157
00:07:04,215 --> 00:07:06,630
and I've inserted in it,

158
00:07:06,630 --> 00:07:09,900
this which is in the
NIST publication,

159
00:07:09,900 --> 00:07:11,300
the idea that
you could have

160
00:07:11,300 --> 00:07:13,295
the threat
signaling server.

161
00:07:13,295 --> 00:07:14,795
But if you look at this,

162
00:07:14,795 --> 00:07:17,420
everything that
has to do with

163
00:07:17,420 --> 00:07:21,535
security is external
to the things.

164
00:07:21,535 --> 00:07:24,050
This is a great
way to make use of

165
00:07:24,050 --> 00:07:26,840
existing things in
conventional networking.

166
00:07:26,840 --> 00:07:29,810
But then when we go
to the use of DTLS,

167
00:07:29,810 --> 00:07:31,190
which is required by

168
00:07:31,190 --> 00:07:32,825
architectures
like the matter.

169
00:07:32,825 --> 00:07:34,775
Now suddenly
we're blinding

170
00:07:34,775 --> 00:07:37,045
deep packet inspection.

171
00:07:37,045 --> 00:07:41,235
They are giving you
an either or choice.

172
00:07:41,235 --> 00:07:42,590
But in NDN,

173
00:07:42,590 --> 00:07:45,080
we can enforce those
communication patterns

174
00:07:45,080 --> 00:07:46,385
on every thing,

175
00:07:46,385 --> 00:07:48,200
and we don't
have to rely on

176
00:07:48,200 --> 00:07:51,020
external servers the
routers and we can

177
00:07:51,020 --> 00:07:52,925
also take advantage of

178
00:07:52,925 --> 00:07:55,730
robust multicasts
properties that

179
00:07:55,730 --> 00:07:59,430
we could get by using
NDN primitives.

180
00:07:59,840 --> 00:08:03,015
Because of this,
I'm saying, okay,

181
00:08:03,015 --> 00:08:05,555
the VerSec
architecture that

182
00:08:05,555 --> 00:08:07,505
fans started talking about

183
00:08:07,505 --> 00:08:13,445
in 2019 provides a
better way to secure OT.

184
00:08:13,445 --> 00:08:15,665
The key elements are,

185
00:08:15,665 --> 00:08:17,300
you have this trust
schema that's

186
00:08:17,300 --> 00:08:20,150
integral to
transport and also

187
00:08:20,150 --> 00:08:23,210
you're using a sync
protocol to distribute

188
00:08:23,210 --> 00:08:24,830
your signing
certificates in

189
00:08:24,830 --> 00:08:27,560
your group keys as
well as your data.

190
00:08:27,560 --> 00:08:29,150
Everything is all being

191
00:08:29,150 --> 00:08:31,825
distributed through
your sync protocol.

192
00:08:31,825 --> 00:08:34,235
A really important aspect

193
00:08:34,235 --> 00:08:35,420
of the trust schema for

194
00:08:35,420 --> 00:08:37,910
VerSec is that it's a
declarative approach

195
00:08:37,910 --> 00:08:39,530
to specifying things.

196
00:08:39,530 --> 00:08:41,270
You can get these
arbitrarily

197
00:08:41,270 --> 00:08:42,715
fine-grain rules

198
00:08:42,715 --> 00:08:44,959
and those are used to
check the soundness

199
00:08:44,959 --> 00:08:47,360
to construct valid
data names and to

200
00:08:47,360 --> 00:08:49,010
enforce the validity of

201
00:08:49,010 --> 00:08:51,230
the data that you receive.

202
00:08:51,230 --> 00:08:54,425
When I say arbitrarily
fine-grained,

203
00:08:54,425 --> 00:08:56,330
that also means
you don't have to

204
00:08:56,330 --> 00:08:59,080
be very fine-grained
at all.

205
00:08:59,080 --> 00:09:01,940
I've have an example

206
00:09:01,940 --> 00:09:04,220
on the website
that is listed

207
00:09:04,220 --> 00:09:06,920
below of really just

208
00:09:06,920 --> 00:09:09,424
securing things
by signing,

209
00:09:09,424 --> 00:09:11,870
which is a little
bit closer

210
00:09:11,870 --> 00:09:13,370
to what you would

211
00:09:13,370 --> 00:09:15,455
get with conventional
networking.

212
00:09:15,455 --> 00:09:16,880
But it's still

213
00:09:16,880 --> 00:09:20,540
a little bit harder
security teams

214
00:09:20,540 --> 00:09:22,480
and what they can provide.

215
00:09:22,480 --> 00:09:25,390
Then another
aspect of this

216
00:09:25,390 --> 00:09:27,985
is that any
communicating entities

217
00:09:27,985 --> 00:09:29,200
have to publish

218
00:09:29,200 --> 00:09:30,490
the public search
that they're

219
00:09:30,490 --> 00:09:33,255
signing chain before
they can communicate.

220
00:09:33,255 --> 00:09:35,800
We don't have any
issues with you get

221
00:09:35,800 --> 00:09:37,330
something and then go

222
00:09:37,330 --> 00:09:38,785
out and try to get keys,

223
00:09:38,785 --> 00:09:42,520
which opens you up to
performance issues,

224
00:09:42,520 --> 00:09:46,595
denial of service,
all bad things.

225
00:09:46,595 --> 00:09:49,240
The trust schema,
along with

226
00:09:49,240 --> 00:09:51,520
its particular
root of trust,

227
00:09:51,520 --> 00:09:52,660
the trust thinker,

228
00:09:52,660 --> 00:09:54,400
it defines a
trust zone and

229
00:09:54,400 --> 00:09:57,350
they think someone
mentioned that earlier.

230
00:09:57,380 --> 00:10:00,820
Our reference
implementation along

231
00:10:00,820 --> 00:10:03,040
with a Pub/Sub API,

232
00:10:03,040 --> 00:10:05,930
which is vaguely
inspired by

233
00:10:05,930 --> 00:10:11,580
MQTT is available on
GitHub at this site.

234
00:10:11,660 --> 00:10:14,745
With using VerSec,

235
00:10:14,745 --> 00:10:16,880
data movement is always

236
00:10:16,880 --> 00:10:18,710
governed by the
trust schema.

237
00:10:18,710 --> 00:10:20,960
This is a slightly
different concept

238
00:10:20,960 --> 00:10:22,820
and I'm going to use
this example which

239
00:10:22,820 --> 00:10:24,830
is home IoT because

240
00:10:24,830 --> 00:10:27,625
it's always easy to
wrap your head around.

241
00:10:27,625 --> 00:10:30,275
If you look at
the trust schema,

242
00:10:30,275 --> 00:10:33,515
this is how we're
defining the search.

243
00:10:33,515 --> 00:10:36,920
This is a device which
is something that

244
00:10:36,920 --> 00:10:39,110
any particular
device would have to

245
00:10:39,110 --> 00:10:42,300
have and it's signed
by the netCert.

246
00:10:42,320 --> 00:10:45,150
Within this, we've
got a Switch Cert,

247
00:10:45,150 --> 00:10:46,605
which is a device

248
00:10:46,605 --> 00:10:50,565
Cert with its role
set the switch.

249
00:10:50,565 --> 00:10:53,265
We've also got
a Light Cert

250
00:10:53,265 --> 00:10:55,590
and it has its
role set to light.

251
00:10:55,590 --> 00:10:58,010
The way that we make

252
00:10:58,010 --> 00:11:01,220
things correspond
to each other is we

253
00:11:01,220 --> 00:11:03,170
have correspondences
between

254
00:11:03,170 --> 00:11:05,870
these components
that are located

255
00:11:05,870 --> 00:11:07,910
in the trust
schema rule for

256
00:11:07,910 --> 00:11:09,620
the Cert as well as

257
00:11:09,620 --> 00:11:11,945
a trust scheme
of publication.

258
00:11:11,945 --> 00:11:14,870
If we take a look
at some switch

259
00:11:14,870 --> 00:11:17,825
and one of the search
that we've given it,

260
00:11:17,825 --> 00:11:20,270
what's in that
location field,

261
00:11:20,270 --> 00:11:22,535
It's quitting
in coffee bar.

262
00:11:22,535 --> 00:11:24,770
Now, that's saying
that this is

263
00:11:24,770 --> 00:11:28,380
a switch for the light
over the coffee bar.

264
00:11:28,380 --> 00:11:31,220
Now, if it makes
a publication and

265
00:11:31,220 --> 00:11:34,970
it's publishing a sub
command to a light,

266
00:11:34,970 --> 00:11:37,175
and it says coffee bar.

267
00:11:37,175 --> 00:11:41,670
It's telling it to turn
on, act that light.

268
00:11:41,670 --> 00:11:44,750
It's able to use the
trust schema to say,

269
00:11:44,750 --> 00:11:47,600
is this signed by
something that has

270
00:11:47,600 --> 00:11:50,720
coffee bar
corresponding to look,

271
00:11:50,720 --> 00:11:52,430
and I have coffee bar,

272
00:11:52,430 --> 00:11:56,075
I'm the coffee bar
light and it turns on.

273
00:11:56,075 --> 00:11:59,860
This is a really
different way of

274
00:11:59,860 --> 00:12:03,130
thinking about the
movement and use of data.

275
00:12:03,130 --> 00:12:04,810
I guess I should say,

276
00:12:04,810 --> 00:12:06,685
so here's the
trust schema.

277
00:12:06,685 --> 00:12:08,820
That's written
ahead of time.

278
00:12:08,820 --> 00:12:11,540
Then the switches
get put into

279
00:12:11,540 --> 00:12:12,710
devices by

280
00:12:12,710 --> 00:12:15,155
the enrollment tools
that you're using.

281
00:12:15,155 --> 00:12:19,595
Then this is what's
happening at runtime.

282
00:12:19,595 --> 00:12:22,280
I think something that

283
00:12:22,280 --> 00:12:24,920
Alex had mentioned I
guess yesterday is,

284
00:12:24,920 --> 00:12:28,220
maybe we could
have approaches or

285
00:12:28,220 --> 00:12:30,830
architectures
where we take

286
00:12:30,830 --> 00:12:33,350
the trust
architecture first.

287
00:12:33,350 --> 00:12:34,670
I just want to say this

288
00:12:34,670 --> 00:12:37,009
is a step in
that direction.

289
00:12:37,009 --> 00:12:38,600
We have to think
about ways of

290
00:12:38,600 --> 00:12:41,180
making the writing of

291
00:12:41,180 --> 00:12:43,295
this trust schemas
friendlier,

292
00:12:43,295 --> 00:12:45,320
because I think
this is a way

293
00:12:45,320 --> 00:12:47,510
that a lot of people think

294
00:12:47,510 --> 00:12:49,910
about their problems in OT

295
00:12:49,910 --> 00:12:53,820
is how do I want to
design the trust.

296
00:12:54,150 --> 00:12:56,875
I want to say a
little bit more

297
00:12:56,875 --> 00:12:59,470
about how this can
become a little

298
00:12:59,470 --> 00:13:01,495
bit more flexible
because we can

299
00:13:01,495 --> 00:13:04,145
then turn around
and say, "Well,

300
00:13:04,145 --> 00:13:05,390
I'm also going to

301
00:13:05,390 --> 00:13:07,715
enroll this
particular switch,

302
00:13:07,715 --> 00:13:09,575
it's switch number 42

303
00:13:09,575 --> 00:13:14,795
with a cert that
has counter in it,

304
00:13:14,795 --> 00:13:16,445
which now says, oh,

305
00:13:16,445 --> 00:13:18,545
I can now issue

306
00:13:18,545 --> 00:13:22,040
commands that have
counter in it."

307
00:13:22,040 --> 00:13:23,915
If it does that,

308
00:13:23,915 --> 00:13:26,240
counter doesn't have to be

309
00:13:26,240 --> 00:13:29,900
one particular light like

310
00:13:29,900 --> 00:13:31,775
the one that's over
the coffee bar,

311
00:13:31,775 --> 00:13:33,379
it can be the counter

312
00:13:33,379 --> 00:13:36,785
that's all sprinkled
throughout the kitchen.

313
00:13:36,785 --> 00:13:38,810
This could be talking to

314
00:13:38,810 --> 00:13:41,120
several different
lights that say,

315
00:13:41,120 --> 00:13:43,295
I'm listening for counter.

316
00:13:43,295 --> 00:13:45,290
Then it can always
check and say was

317
00:13:45,290 --> 00:13:47,390
this publication issued by

318
00:13:47,390 --> 00:13:49,130
someone who has

319
00:13:49,130 --> 00:13:53,910
that attribute
in their certs.

320
00:13:54,240 --> 00:13:56,920
Just some features
of the approach I

321
00:13:56,920 --> 00:13:58,630
want to reiterate is

322
00:13:58,630 --> 00:14:01,090
that then a thing signing

323
00:14:01,090 --> 00:14:04,075
id restricts what
I can legally say.

324
00:14:04,075 --> 00:14:06,915
Now everything that's
in the trust zone

325
00:14:06,915 --> 00:14:10,175
knows what is and
what is not legal.

326
00:14:10,175 --> 00:14:12,230
Here we're
deliberately not

327
00:14:12,230 --> 00:14:14,045
liberal in
what's accepted.

328
00:14:14,045 --> 00:14:15,920
That was saying we're
moving away from

329
00:14:15,920 --> 00:14:17,750
that Internet model,

330
00:14:17,750 --> 00:14:19,700
here are the IT model.

331
00:14:19,700 --> 00:14:21,725
A Thing can also

332
00:14:21,725 --> 00:14:23,780
listen for and accept
communications

333
00:14:23,780 --> 00:14:27,740
from multiple name
prefixed data and it's

334
00:14:27,740 --> 00:14:29,510
trust schema-enabled
transport

335
00:14:29,510 --> 00:14:30,590
ensures that those are

336
00:14:30,590 --> 00:14:31,970
valid before it even

337
00:14:31,970 --> 00:14:34,040
passes it to the
application.

338
00:14:34,040 --> 00:14:35,780
When Things come in,

339
00:14:35,780 --> 00:14:38,480
if it's not valid,

340
00:14:38,480 --> 00:14:40,490
you toss it away early.

341
00:14:40,490 --> 00:14:41,900
We always try to toss

342
00:14:41,900 --> 00:14:44,345
Things as early
as possible.

343
00:14:44,345 --> 00:14:47,600
A light in a
building system can

344
00:14:47,600 --> 00:14:48,800
listen for data that's

345
00:14:48,800 --> 00:14:50,960
for its specific location.

346
00:14:50,960 --> 00:14:53,120
If it's what he said,

347
00:14:53,120 --> 00:14:55,445
their coffee bar
or it's room,

348
00:14:55,445 --> 00:14:58,100
the floor that it's
on or all lights

349
00:14:58,100 --> 00:14:59,180
you could turn
them all on at

350
00:14:59,180 --> 00:15:01,085
once or turn them all off.

351
00:15:01,085 --> 00:15:04,160
That same light
is only able to

352
00:15:04,160 --> 00:15:05,615
report its status and they

353
00:15:05,615 --> 00:15:07,850
can't cause any actions.

354
00:15:07,850 --> 00:15:11,000
I think probably
many of you are

355
00:15:11,000 --> 00:15:14,540
aware of this
nice work that

356
00:15:14,540 --> 00:15:17,060
checkpoint did
showing compromising

357
00:15:17,060 --> 00:15:18,920
a Philips light
bulb and then being

358
00:15:18,920 --> 00:15:21,395
able to take over
an entire network,

359
00:15:21,395 --> 00:15:24,950
so we really need to
limit those devices.

360
00:15:24,950 --> 00:15:27,140
They're not as dumb
as we think they are.

361
00:15:27,140 --> 00:15:29,360
They're running
processors.

362
00:15:29,360 --> 00:15:30,800
If we let people take them

363
00:15:30,800 --> 00:15:33,020
over and we let them

364
00:15:33,020 --> 00:15:35,930
issue any command because

365
00:15:35,930 --> 00:15:37,355
they're inside
of our network,

366
00:15:37,355 --> 00:15:38,750
then we're dead.

367
00:15:38,750 --> 00:15:41,765
If we use trust
schema-based enrollment,

368
00:15:41,765 --> 00:15:43,550
then the
communications are

369
00:15:43,550 --> 00:15:45,905
now enforced at
every single Thing

370
00:15:45,905 --> 00:15:47,810
or every entity
and we don't need

371
00:15:47,810 --> 00:15:50,390
those external
servers and routers.

372
00:15:50,390 --> 00:15:51,770
That gets rid of having

373
00:15:51,770 --> 00:15:53,660
this single
point of attack,

374
00:15:53,660 --> 00:15:55,070
where if you think back to

375
00:15:55,070 --> 00:15:56,840
the picture I
showed earlier,

376
00:15:56,840 --> 00:15:58,370
if you were
trying to attack

377
00:15:58,370 --> 00:15:59,660
the system, you
would say, "Oh,

378
00:15:59,660 --> 00:16:00,830
look at these servers,

379
00:16:00,830 --> 00:16:04,520
here's the place it
says attack me here".

380
00:16:04,520 --> 00:16:06,755
Finally, I want
to note that

381
00:16:06,755 --> 00:16:08,270
now the communications can

382
00:16:08,270 --> 00:16:10,565
exploit that
broadcast nature

383
00:16:10,565 --> 00:16:12,035
of having wireless,

384
00:16:12,035 --> 00:16:14,210
but without
compromising security

385
00:16:14,210 --> 00:16:16,460
because every
single entity

386
00:16:16,460 --> 00:16:17,960
has the trust scrolls

387
00:16:17,960 --> 00:16:21,845
and has built-in
enforcement.

388
00:16:21,845 --> 00:16:25,235
I want to move on
thinking more about,

389
00:16:25,235 --> 00:16:27,020
so data movement is

390
00:16:27,020 --> 00:16:29,210
governed by the
trust schema.

391
00:16:29,210 --> 00:16:31,460
I want to think a
little bit more about,

392
00:16:31,460 --> 00:16:33,845
well, how do we
work with that?

393
00:16:33,845 --> 00:16:37,040
Everything that's on the
same network segment

394
00:16:37,040 --> 00:16:39,080
might not be in the
same trust zone.

395
00:16:39,080 --> 00:16:41,045
If you look over
on this side,

396
00:16:41,045 --> 00:16:43,130
maybe this laptop isn't

397
00:16:43,130 --> 00:16:44,870
a member of the
trust zone,

398
00:16:44,870 --> 00:16:46,430
but it doesn't
really matter

399
00:16:46,430 --> 00:16:48,710
because it can't publish

400
00:16:48,710 --> 00:16:51,080
anything the green stuff

401
00:16:51,080 --> 00:16:52,820
is going to listen to,

402
00:16:52,820 --> 00:16:55,530
it doesn't have the
right identity.

403
00:16:56,770 --> 00:16:59,360
The other problem is that

404
00:16:59,360 --> 00:17:00,950
we might want to
have entities

405
00:17:00,950 --> 00:17:02,480
that are in the same
trust zone that

406
00:17:02,480 --> 00:17:04,670
aren't the same
network segment.

407
00:17:04,670 --> 00:17:07,670
Currently in the DCT stuff

408
00:17:07,670 --> 00:17:09,635
that cuts out
in the GitHub,

409
00:17:09,635 --> 00:17:12,395
we only have one
trust zone, per Face.

410
00:17:12,395 --> 00:17:15,110
But we're working on
relay applications

411
00:17:15,110 --> 00:17:18,335
that extend the trust
zone between the Faces.

412
00:17:18,335 --> 00:17:20,150
That would be the
idea here is that

413
00:17:20,150 --> 00:17:23,000
this relay app is
talking through

414
00:17:23,000 --> 00:17:25,100
the modem and
a relay app on

415
00:17:25,100 --> 00:17:28,370
the other side is
passing things on.

416
00:17:28,370 --> 00:17:31,550
Now, those relay
applications could filter

417
00:17:31,550 --> 00:17:33,320
the publications
that go through them

418
00:17:33,320 --> 00:17:35,180
or they can just
pass them through.

419
00:17:35,180 --> 00:17:37,010
But you might envision

420
00:17:37,010 --> 00:17:40,580
a default deny because
you want to be

421
00:17:40,580 --> 00:17:42,650
really careful
about what goes

422
00:17:42,650 --> 00:17:46,280
across the
physical boundary.

423
00:17:46,280 --> 00:17:47,330
It's not a trust,

424
00:17:47,330 --> 00:17:49,775
it doesn't go across
a trust boundary.

425
00:17:49,775 --> 00:17:52,250
Since signing
identities are

426
00:17:52,250 --> 00:17:53,930
associated with
the trust zone,

427
00:17:53,930 --> 00:17:55,745
those would be
used everywhere.

428
00:17:55,745 --> 00:17:57,800
But the way we're
setting this up is that

429
00:17:57,800 --> 00:18:00,890
our data encryption
keys are face specific,

430
00:18:00,890 --> 00:18:03,440
so if data is encrypted

431
00:18:03,440 --> 00:18:06,395
everything on this side
uses one group key,

432
00:18:06,395 --> 00:18:08,765
use a different key across

433
00:18:08,765 --> 00:18:12,155
here and yet
another one here.

434
00:18:12,155 --> 00:18:14,480
This is something
that it's

435
00:18:14,480 --> 00:18:16,985
the current area
of work for me.

436
00:18:16,985 --> 00:18:19,939
Now here's some
half-baked ideas,

437
00:18:19,939 --> 00:18:21,755
oops I've got to
wrap up here.

438
00:18:21,755 --> 00:18:25,205
The reason I put the
half-baked ideas out

439
00:18:25,205 --> 00:18:28,175
is to try to
inspire people to

440
00:18:28,175 --> 00:18:29,690
realize that
there's a lot of

441
00:18:29,690 --> 00:18:32,330
cool things to work on
here and we need to

442
00:18:32,330 --> 00:18:36,605
solve these problems in
order to move forward

443
00:18:36,605 --> 00:18:42,710
and present
solutions for OT.

444
00:18:42,710 --> 00:18:43,520
Here's some of

445
00:18:43,520 --> 00:18:45,410
the opportunities
I've thought about.

446
00:18:45,410 --> 00:18:47,240
Crystal, should I
just stop here or

447
00:18:47,240 --> 00:18:49,700
should I run through
these quickly?

448
00:18:49,700 --> 00:18:51,965
>> We are at the
one-minute mark.

449
00:18:51,965 --> 00:18:53,015
Please wrap up.

450
00:18:53,015 --> 00:18:55,580
>> Okay. Here's some
opportunities I

451
00:18:55,580 --> 00:18:58,010
can think of that if

452
00:18:58,010 --> 00:19:00,110
we can solve the
hard problems in

453
00:19:00,110 --> 00:19:02,780
a wide range of
special-purpose applications,

454
00:19:02,780 --> 00:19:04,400
we might be able
to make NDN

455
00:19:04,400 --> 00:19:05,735
immediately relevant

456
00:19:05,735 --> 00:19:10,580
commercially for some
sense of relevancy.

457
00:19:10,580 --> 00:19:13,370
Then if we're applying

458
00:19:13,370 --> 00:19:16,145
this NDN architecture
to an OT problem,

459
00:19:16,145 --> 00:19:17,570
it should lead to creating

460
00:19:17,570 --> 00:19:20,090
a new data-centric
innovations and

461
00:19:20,090 --> 00:19:21,620
new understandings of

462
00:19:21,620 --> 00:19:24,800
non-endpoint-centric
communications.

463
00:19:24,800 --> 00:19:27,425
Some things with the
trust schema is,

464
00:19:27,425 --> 00:19:30,260
maybe we get a
form-based trust schemas

465
00:19:30,260 --> 00:19:32,360
and they would
be specific to

466
00:19:32,360 --> 00:19:34,655
particular classes
of problem,

467
00:19:34,655 --> 00:19:35,975
or maybe we would have

468
00:19:35,975 --> 00:19:38,330
MUD-to-trust
schema translator,

469
00:19:38,330 --> 00:19:40,970
but there's just
various things

470
00:19:40,970 --> 00:19:43,010
that could be
worked on there.

471
00:19:43,010 --> 00:19:45,950
NDN-specific
approaches to updating

472
00:19:45,950 --> 00:19:47,675
identities and
trust schemas

473
00:19:47,675 --> 00:19:49,940
that maybe make use of

474
00:19:49,940 --> 00:19:52,580
TPM or other hardware
security modules.

475
00:19:52,580 --> 00:19:55,370
I think the work
that we saw earlier

476
00:19:55,370 --> 00:19:58,295
today of bootstrapping
over the network,

477
00:19:58,295 --> 00:20:02,615
that's, one beginning
in this area.

478
00:20:02,615 --> 00:20:04,535
There's the other idea of

479
00:20:04,535 --> 00:20:07,070
extending the
communication model

480
00:20:07,070 --> 00:20:10,070
APIs that DCT has

481
00:20:10,070 --> 00:20:12,785
for other types
of transit carts.

482
00:20:12,785 --> 00:20:15,080
Everything we've put
out as open source.

483
00:20:15,080 --> 00:20:16,805
If you don't like some,

484
00:20:16,805 --> 00:20:20,240
take what you want and
put your own stuff in.

485
00:20:20,240 --> 00:20:23,690
Also, maybe we won't
listen or subscribe

486
00:20:23,690 --> 00:20:25,460
only applications
that create

487
00:20:25,460 --> 00:20:27,605
audit trails for
trust zones,

488
00:20:27,605 --> 00:20:29,000
recording the names and

489
00:20:29,000 --> 00:20:30,260
the signers time a day,

490
00:20:30,260 --> 00:20:31,940
those kinds of things.

491
00:20:31,940 --> 00:20:33,920
Work on hierarchical

492
00:20:33,920 --> 00:20:35,450
and federated trust zones.

493
00:20:35,450 --> 00:20:37,190
I had to sit through.

494
00:20:37,190 --> 00:20:39,140
What about
security audits?

495
00:20:39,140 --> 00:20:40,370
Do we have people who

496
00:20:40,370 --> 00:20:43,460
could do that for us and

497
00:20:43,460 --> 00:20:46,010
understand how do we

498
00:20:46,010 --> 00:20:48,740
systematize the
security audits

499
00:20:48,740 --> 00:20:50,525
that we want to do here?

500
00:20:50,525 --> 00:20:54,275
Then the use of
identifiers and identities

501
00:20:54,275 --> 00:20:55,970
other than just using

502
00:20:55,970 --> 00:20:58,040
the ones that you give
out in a trust zone,

503
00:20:58,040 --> 00:20:59,270
could we do something

504
00:20:59,270 --> 00:21:01,880
with self sovereign
identity?

505
00:21:01,880 --> 00:21:03,860
Also, we just wanted to

506
00:21:03,860 --> 00:21:06,080
exploit NDN
characteristics to

507
00:21:06,080 --> 00:21:08,780
make communications
that are both robust to

508
00:21:08,780 --> 00:21:12,035
failure and robust
to cyber threats.

509
00:21:12,035 --> 00:21:14,270
I think there's lots more.

510
00:21:14,270 --> 00:21:17,585
That's my presentation.
I'm done.

511
00:21:17,585 --> 00:21:18,380
>> Thank you.

512
00:21:18,380 --> 00:21:19,550
Appreciate it.
Just one question

513
00:21:19,550 --> 00:21:20,930
on select if you wanted
to [OVERLAPPING].

514
00:21:20,930 --> 00:21:23,630
>> No worries,
I'm here to help.

515
00:21:23,630 --> 00:21:24,905
>> Very good.

516
00:21:24,905 --> 00:21:27,530
>> Varun, please
go ahead and share

517
00:21:27,530 --> 00:21:31,410
screen so we can start
seeing your slides.

518
00:21:31,410 --> 00:21:34,000
Brief introduction
to Varun.

519
00:21:34,000 --> 00:21:36,085
Just giving you a very
brief introduction.

520
00:21:36,085 --> 00:21:37,960
He is a computer science
graduate student at

521
00:21:37,960 --> 00:21:40,815
UCLA working with Alicia.

522
00:21:40,815 --> 00:21:42,770
His research
interests are in

523
00:21:42,770 --> 00:21:45,425
systems in data-centric
networking.

524
00:21:45,425 --> 00:21:47,360
He is currently working on

525
00:21:47,360 --> 00:21:49,130
the NDN sync protocol.

526
00:21:49,130 --> 00:21:50,615
Varun, go ahead,
take your way.

527
00:21:50,615 --> 00:21:51,710
>> Thank you Christos.

528
00:21:51,710 --> 00:21:53,765
Can you see my
slides and hear me?

529
00:21:53,765 --> 00:21:56,345
>> Yes, you go good.

530
00:21:56,345 --> 00:21:56,890
>> Cool.

531
00:21:56,890 --> 00:21:59,300
I'm going to be
talking about building

532
00:21:59,300 --> 00:22:01,190
high-level
transports over NDN

533
00:22:01,190 --> 00:22:03,540
in particular over sync.

534
00:22:05,800 --> 00:22:08,390
The first thing we
want to identify

535
00:22:08,390 --> 00:22:10,085
before building
anything is that,

536
00:22:10,085 --> 00:22:12,365
what do the
applications want?

537
00:22:12,365 --> 00:22:14,810
The way we can do
this is by looking

538
00:22:14,810 --> 00:22:17,990
at what do the
applications have already.

539
00:22:17,990 --> 00:22:21,275
The first thing is
that they have IP,

540
00:22:21,275 --> 00:22:24,575
but none of the applications
use IP directly.

541
00:22:24,575 --> 00:22:26,840
It should be easy to
use because dealing

542
00:22:26,840 --> 00:22:29,600
with individual data
packets is hard.

543
00:22:29,600 --> 00:22:32,060
The apps produce objects

544
00:22:32,060 --> 00:22:35,120
of an arbitrary sizes
and any number of them.

545
00:22:35,120 --> 00:22:37,265
You can just use IP
directly for this.

546
00:22:37,265 --> 00:22:38,795
That's why we have TCP

547
00:22:38,795 --> 00:22:40,475
as the transport in IP.

548
00:22:40,475 --> 00:22:43,235
Then we also need
built-in security.

549
00:22:43,235 --> 00:22:44,735
Apps can't do

550
00:22:44,735 --> 00:22:46,340
encryption and
signing themselves.

551
00:22:46,340 --> 00:22:48,320
You have TLS
that works with

552
00:22:48,320 --> 00:22:50,510
TCP/IP to do
security for you,

553
00:22:50,510 --> 00:22:52,310
and the application
will just give

554
00:22:52,310 --> 00:22:55,115
a certificate or
a key to TLS.

555
00:22:55,115 --> 00:22:57,590
Third, is that
we also need to

556
00:22:57,590 --> 00:22:59,750
have communication
between multiple parties.

557
00:22:59,750 --> 00:23:01,865
TCP/IP is just
point-to-point.

558
00:23:01,865 --> 00:23:06,050
We do have solutions
like MQTT that support

559
00:23:06,050 --> 00:23:10,955
secure transport
for applications

560
00:23:10,955 --> 00:23:12,890
of between
multiple parties.

561
00:23:12,890 --> 00:23:15,110
It's like
basically pops up.

562
00:23:15,110 --> 00:23:17,195
Then applications
also want

563
00:23:17,195 --> 00:23:18,845
all this to be
decentralized.

564
00:23:18,845 --> 00:23:21,080
Well, that is the
place where you don't

565
00:23:21,080 --> 00:23:23,270
really have a very
concrete solution in IP,

566
00:23:23,270 --> 00:23:24,499
there are some solutions,

567
00:23:24,499 --> 00:23:25,310
but they end up doing

568
00:23:25,310 --> 00:23:27,050
some N cross N
communication

569
00:23:27,050 --> 00:23:30,080
because of the
node-centric nature of IP.

570
00:23:30,080 --> 00:23:32,105
Trying to identify
the solution,

571
00:23:32,105 --> 00:23:33,185
we think that

572
00:23:33,185 --> 00:23:35,150
decentralized
Pub/Sub running over

573
00:23:35,150 --> 00:23:37,010
NDN is a potential
solution

574
00:23:37,010 --> 00:23:39,140
that solves all
these problems.

575
00:23:39,140 --> 00:23:41,600
By creating such a system,

576
00:23:41,600 --> 00:23:42,680
we will be supporting

577
00:23:42,680 --> 00:23:44,360
a popular design
pattern that has

578
00:23:44,360 --> 00:23:45,590
been very widely

579
00:23:45,590 --> 00:23:47,705
deployed successfully
in industry.

580
00:23:47,705 --> 00:23:51,140
It is multiplied
party and pops up

581
00:23:51,140 --> 00:23:55,550
itself while it is mostly
centralized in IP,

582
00:23:55,550 --> 00:23:57,245
there's nothing
about pops of itself

583
00:23:57,245 --> 00:23:59,195
that cannot be
decentralized.

584
00:23:59,195 --> 00:24:01,415
We can decentralize
pops up.

585
00:24:01,415 --> 00:24:03,710
The question is,
how do we support

586
00:24:03,710 --> 00:24:05,495
Pub/Sub over NDN?

587
00:24:05,495 --> 00:24:07,070
To do that, we
first look at

588
00:24:07,070 --> 00:24:08,690
the protocols
that we have.

589
00:24:08,690 --> 00:24:11,570
The closest that we
come to is sync.

590
00:24:11,570 --> 00:24:13,280
The sync provides
namespace

591
00:24:13,280 --> 00:24:14,510
synchronization in IP.

592
00:24:14,510 --> 00:24:16,955
Basically, it informs
the consumers

593
00:24:16,955 --> 00:24:19,550
of what new data is
available for fetching.

594
00:24:19,550 --> 00:24:21,900
It's a transport of NDN.

595
00:24:21,900 --> 00:24:24,804
There are existing
sync protocols.

596
00:24:24,804 --> 00:24:26,830
I've listed them
here and we build

597
00:24:26,830 --> 00:24:28,030
our implementation on

598
00:24:28,030 --> 00:24:29,365
the synchronization
protocol.

599
00:24:29,365 --> 00:24:31,960
Just the switches take
rehearsing because it

600
00:24:31,960 --> 00:24:35,570
is resilient and
efficient in its job.

601
00:24:35,950 --> 00:24:39,530
Let's identify first
that what does sync

602
00:24:39,530 --> 00:24:41,150
provide us and what is

603
00:24:41,150 --> 00:24:43,295
it missing from what
applications want?

604
00:24:43,295 --> 00:24:45,050
Sync synchronizes
namespace

605
00:24:45,050 --> 00:24:46,535
for individual packets,

606
00:24:46,535 --> 00:24:49,160
but developers need
higher level APIs.

607
00:24:49,160 --> 00:24:51,380
That's the one that
I mentioned earlier.

608
00:24:51,380 --> 00:24:53,630
If you use sync directly,

609
00:24:53,630 --> 00:24:54,710
you still need
to deal with

610
00:24:54,710 --> 00:24:55,970
interest data
exchanges and

611
00:24:55,970 --> 00:24:57,770
you still need to
sign every packet.

612
00:24:57,770 --> 00:25:00,260
Sync will just
inform the consumers

613
00:25:00,260 --> 00:25:02,585
about a certain packet
being available.

614
00:25:02,585 --> 00:25:04,850
It doesn't do anything
more than that.

615
00:25:04,850 --> 00:25:07,070
We still need to fill
this gap between

616
00:25:07,070 --> 00:25:09,725
what is needed and what
does sync provide,

617
00:25:09,725 --> 00:25:11,120
but before we do that,

618
00:25:11,120 --> 00:25:13,655
let's just take a
look at sync itself.

619
00:25:13,655 --> 00:25:16,160
That is our
lowermost layer,

620
00:25:16,160 --> 00:25:18,740
that is a transport
itself, which is sync.

621
00:25:18,740 --> 00:25:20,870
We take a look at
State Vector Sync.

622
00:25:20,870 --> 00:25:22,490
State Vector Sync encodes

623
00:25:22,490 --> 00:25:24,380
the entire state in

624
00:25:24,380 --> 00:25:26,840
a single sync interest.
What is the state?

625
00:25:26,840 --> 00:25:29,660
The state is
just a list of

626
00:25:29,660 --> 00:25:31,550
tuples which are producer

627
00:25:31,550 --> 00:25:32,915
and sequence number pairs.

628
00:25:32,915 --> 00:25:36,245
For each entity in
this sync group,

629
00:25:36,245 --> 00:25:38,255
we'll keep a
sequence number.

630
00:25:38,255 --> 00:25:40,190
They will put their
sequence number and

631
00:25:40,190 --> 00:25:42,785
their producer prefix
into the state vector.

632
00:25:42,785 --> 00:25:44,660
Now, this entire
state vector will be

633
00:25:44,660 --> 00:25:46,655
put into a single
sync interest.

634
00:25:46,655 --> 00:25:48,320
The sync interest
is multicast to

635
00:25:48,320 --> 00:25:50,180
everyone else in
the sync group.

636
00:25:50,180 --> 00:25:51,620
This way, if anyone

637
00:25:51,620 --> 00:25:53,300
updates their
sequence number,

638
00:25:53,300 --> 00:25:55,010
which is my update,

639
00:25:55,010 --> 00:25:56,750
they increase their
sequence number,

640
00:25:56,750 --> 00:25:58,580
then they just send
out a sync interests

641
00:25:58,580 --> 00:26:00,980
and everyone else
will know about it.

642
00:26:00,980 --> 00:26:03,140
When next time,
if someone misses

643
00:26:03,140 --> 00:26:04,550
the sync interest
when anyone

644
00:26:04,550 --> 00:26:06,155
else sends the
sync interest,

645
00:26:06,155 --> 00:26:07,475
then they will also know

646
00:26:07,475 --> 00:26:09,290
its state changes
both of them.

647
00:26:09,290 --> 00:26:11,000
This way, state of records

648
00:26:11,000 --> 00:26:12,740
sync interest is
very resilient to

649
00:26:12,740 --> 00:26:14,285
losses because of its

650
00:26:14,285 --> 00:26:16,055
encoding the
entire state in

651
00:26:16,055 --> 00:26:18,950
single sync interest
and its use of

652
00:26:18,950 --> 00:26:20,060
sequence numbers as

653
00:26:20,060 --> 00:26:22,040
the resilient
transport identifier,

654
00:26:22,040 --> 00:26:23,360
but if you miss
something in between,

655
00:26:23,360 --> 00:26:25,100
you can just know it
later because you

656
00:26:25,100 --> 00:26:25,970
know that you are

657
00:26:25,970 --> 00:26:27,410
missing some
sequence numbers.

658
00:26:27,410 --> 00:26:30,230
Sync interest is a
very simple design.

659
00:26:30,230 --> 00:26:31,640
One point is that

660
00:26:31,640 --> 00:26:32,990
sync interest does
not follow a set of

661
00:26:32,990 --> 00:26:35,630
replies to the multicast
sync interests.

662
00:26:35,630 --> 00:26:37,835
This avoids the
negative impact

663
00:26:37,835 --> 00:26:41,460
of having potentially
multiple replies.

664
00:26:42,580 --> 00:26:45,440
Sync Interest serves as

665
00:26:45,440 --> 00:26:46,640
just a modification to

666
00:26:46,640 --> 00:26:48,260
everyone else
in sync group

667
00:26:48,260 --> 00:26:49,850
about new data
that is available,

668
00:26:49,850 --> 00:26:52,310
there is no reply to
the sync interest,

669
00:26:52,310 --> 00:26:55,100
but let's instead
look at what

670
00:26:55,100 --> 00:26:57,560
the application
actually publishes.

671
00:26:57,560 --> 00:26:59,630
We can say that
the application

672
00:26:59,630 --> 00:27:02,225
will publish a
name data BLOB.

673
00:27:02,225 --> 00:27:03,920
The naming of
the blob will

674
00:27:03,920 --> 00:27:05,480
be done by the
application.

675
00:27:05,480 --> 00:27:06,920
We don't worry about that.

676
00:27:06,920 --> 00:27:09,560
It's application
define semantics.

677
00:27:09,560 --> 00:27:11,810
The applications
don't want

678
00:27:11,810 --> 00:27:12,935
to know about the
network layer.

679
00:27:12,935 --> 00:27:16,010
They don't care about
the MTU limitations,

680
00:27:16,010 --> 00:27:17,120
or they don't want to

681
00:27:17,120 --> 00:27:19,415
manipulate interests
data directly.

682
00:27:19,415 --> 00:27:21,935
This blob can
be of any size.

683
00:27:21,935 --> 00:27:24,050
As I said earlier,
sync will only

684
00:27:24,050 --> 00:27:26,360
provide a namespace
synchronization

685
00:27:26,360 --> 00:27:28,340
for individual packets.

686
00:27:28,340 --> 00:27:30,440
It will not do any kind of

687
00:27:30,440 --> 00:27:32,345
segmentation on its own.

688
00:27:32,345 --> 00:27:34,610
We need this
segmentation in

689
00:27:34,610 --> 00:27:36,680
one layer above
sync where we

690
00:27:36,680 --> 00:27:40,280
can publish objects
of any size on sync

691
00:27:40,280 --> 00:27:42,170
and then this object

692
00:27:42,170 --> 00:27:44,255
will become available
to everyone else.

693
00:27:44,255 --> 00:27:46,115
The second problem,
if you notice,

694
00:27:46,115 --> 00:27:47,600
is that because of

695
00:27:47,600 --> 00:27:49,910
the use of sequence
numbers in sync,

696
00:27:49,910 --> 00:27:52,430
you cannot have
the semantic name

697
00:27:52,430 --> 00:27:53,570
of the application
to fetch

698
00:27:53,570 --> 00:27:57,140
the data and documents
as well as particular.

699
00:27:57,140 --> 00:27:59,330
Sync uses
sequence numbers,

700
00:27:59,330 --> 00:28:01,940
so you just know the
producers prefix

701
00:28:01,940 --> 00:28:02,900
and the sequence number

702
00:28:02,900 --> 00:28:04,040
corresponding to
that producer.

703
00:28:04,040 --> 00:28:06,200
You have no idea about
the semantic name of

704
00:28:06,200 --> 00:28:07,670
the application
object when you get

705
00:28:07,670 --> 00:28:10,070
the update from SBS.

706
00:28:10,070 --> 00:28:11,960
That becomes
our next step.

707
00:28:11,960 --> 00:28:15,390
How do we do data
delivery over sync?

708
00:28:15,390 --> 00:28:18,625
This is our approach
to this problem,

709
00:28:18,625 --> 00:28:20,620
that we first get

710
00:28:20,620 --> 00:28:22,675
the name and the blob
from the application.

711
00:28:22,675 --> 00:28:25,210
It's a name that
is defined by

712
00:28:25,210 --> 00:28:28,270
the application and
it's defined here.

713
00:28:28,270 --> 00:28:30,610
It's the topic or
something and the blob

714
00:28:30,610 --> 00:28:33,255
is just a binary
data of any size.

715
00:28:33,255 --> 00:28:36,470
Then the transport library

716
00:28:36,470 --> 00:28:37,925
that is the data
delivery layer

717
00:28:37,925 --> 00:28:40,100
will chop this blob up
into smaller pieces

718
00:28:40,100 --> 00:28:41,270
such that when it

719
00:28:41,270 --> 00:28:42,680
creates the final
data packet,

720
00:28:42,680 --> 00:28:45,110
it will still fit
in the network MTU.

721
00:28:45,110 --> 00:28:47,000
These are these B0-Bn

722
00:28:47,000 --> 00:28:49,115
and these are
parts of the blob.

723
00:28:49,115 --> 00:28:51,455
Then we put each
of these blobs

724
00:28:51,455 --> 00:28:54,110
into NDN data packet and

725
00:28:54,110 --> 00:28:56,360
this data packet
will be named using

726
00:28:56,360 --> 00:28:58,580
the application
semantic name

727
00:28:58,580 --> 00:29:00,125
and a segment number.

728
00:29:00,125 --> 00:29:04,550
This encapsulated data
packet as mentioned

729
00:29:04,550 --> 00:29:06,380
here is semantically

730
00:29:06,380 --> 00:29:07,640
a complete NDN data

731
00:29:07,640 --> 00:29:09,140
packet that you can fetch.

732
00:29:09,140 --> 00:29:10,190
It is named using the NDN

733
00:29:10,190 --> 00:29:11,840
conventions and you can

734
00:29:11,840 --> 00:29:13,400
fetch this packet directly

735
00:29:13,400 --> 00:29:15,065
to get the application
data blob.

736
00:29:15,065 --> 00:29:17,345
But we still have the
problem that Sync only

737
00:29:17,345 --> 00:29:19,775
informs others about
the sequence numbers.

738
00:29:19,775 --> 00:29:22,010
We put this data
packet inside

739
00:29:22,010 --> 00:29:23,180
another data
packet that is

740
00:29:23,180 --> 00:29:25,430
named using the
sequence number.

741
00:29:25,430 --> 00:29:27,950
We put the
producers prefix

742
00:29:27,950 --> 00:29:29,090
and the sequence number in

743
00:29:29,090 --> 00:29:30,905
the name of this
outer data packet.

744
00:29:30,905 --> 00:29:32,870
As soon as when

745
00:29:32,870 --> 00:29:36,455
the producer produces
this data packet,

746
00:29:36,455 --> 00:29:37,910
they inform everyone else

747
00:29:37,910 --> 00:29:39,215
about the new
sequence number,

748
00:29:39,215 --> 00:29:41,180
and using just
the information

749
00:29:41,180 --> 00:29:43,265
inside the sink
interests in SVS,

750
00:29:43,265 --> 00:29:45,380
they can actually fix
this data packet.

751
00:29:45,380 --> 00:29:47,600
When they fetch all of
these data packets,

752
00:29:47,600 --> 00:29:49,580
they can then
encapsulate them and

753
00:29:49,580 --> 00:29:50,810
put the blobs together and

754
00:29:50,810 --> 00:29:52,830
return it to the consumer.

755
00:29:52,960 --> 00:29:55,490
By doing this,
what we achieved

756
00:29:55,490 --> 00:29:57,170
was that we got

757
00:29:57,170 --> 00:29:59,345
this application
data unit of

758
00:29:59,345 --> 00:30:00,620
arbitrary size to

759
00:30:00,620 --> 00:30:02,270
everyone else in
the Sync group.

760
00:30:02,270 --> 00:30:03,620
We fill that
requirement gap

761
00:30:03,620 --> 00:30:05,930
partially and now the
consumers can also

762
00:30:05,930 --> 00:30:08,060
fetch the data and
use the contents

763
00:30:08,060 --> 00:30:10,715
of the data which
is of any size.

764
00:30:10,715 --> 00:30:12,740
But now there is one
more problem that

765
00:30:12,740 --> 00:30:14,705
we can identify
here is that

766
00:30:14,705 --> 00:30:16,340
the consumer does not

767
00:30:16,340 --> 00:30:17,390
know what it is fetching

768
00:30:17,390 --> 00:30:19,850
before actually fetching
it because of again,

769
00:30:19,850 --> 00:30:21,080
the use of
sequence number,

770
00:30:21,080 --> 00:30:22,400
the application
name is not

771
00:30:22,400 --> 00:30:24,035
exposed to the consumer.

772
00:30:24,035 --> 00:30:26,300
The consumer will know
only after fetching

773
00:30:26,300 --> 00:30:28,310
it what data is

774
00:30:28,310 --> 00:30:29,780
and whether they
actually need it.

775
00:30:29,780 --> 00:30:31,085
We need a mechanism to

776
00:30:31,085 --> 00:30:32,495
inform the
consumers of what

777
00:30:32,495 --> 00:30:33,920
is published so that

778
00:30:33,920 --> 00:30:35,910
they can fetch it
only if they needed.

779
00:30:35,910 --> 00:30:39,400
That brings us up to
the layer of Pub/Sub

780
00:30:39,400 --> 00:30:40,780
where we want to

781
00:30:40,780 --> 00:30:43,275
fetch only what the
application needs.

782
00:30:43,275 --> 00:30:47,705
Doing Pub/Sub over SVS
we take this approach.

783
00:30:47,705 --> 00:30:49,790
A fundamental
problem is that

784
00:30:49,790 --> 00:30:52,085
the subscriber of
Pub/Sub needs to know

785
00:30:52,085 --> 00:30:53,420
the data name before

786
00:30:53,420 --> 00:30:55,490
fetching the object using

787
00:30:55,490 --> 00:30:57,710
the sequence number and

788
00:30:57,710 --> 00:30:59,795
SVS provides only
the sequence number.

789
00:30:59,795 --> 00:31:01,730
To do this, we do

790
00:31:01,730 --> 00:31:03,170
what we do
elsewhere in NDN.

791
00:31:03,170 --> 00:31:04,490
We ask for the data name.

792
00:31:04,490 --> 00:31:06,560
For this, we sent out
a mapping interest,

793
00:31:06,560 --> 00:31:08,960
we simply ask the
producer that what is

794
00:31:08,960 --> 00:31:10,880
the application data
name corresponding to

795
00:31:10,880 --> 00:31:13,145
this producer and
the sequence number.

796
00:31:13,145 --> 00:31:14,630
Then you send

797
00:31:14,630 --> 00:31:15,350
the mapping interest and

798
00:31:15,350 --> 00:31:16,130
the producer will just

799
00:31:16,130 --> 00:31:18,380
reply with the
application name

800
00:31:18,380 --> 00:31:20,135
for that particular
sequence number.

801
00:31:20,135 --> 00:31:23,570
Then the subscriber can
just look up the list

802
00:31:23,570 --> 00:31:24,920
of subscriptions
and if they

803
00:31:24,920 --> 00:31:26,810
are subscribed
to that object,

804
00:31:26,810 --> 00:31:27,740
then they can
just fetch it

805
00:31:27,740 --> 00:31:29,045
using the data interests.

806
00:31:29,045 --> 00:31:31,565
We can optimize
this step by

807
00:31:31,565 --> 00:31:33,650
just putting the
application data name

808
00:31:33,650 --> 00:31:35,195
onto the Sync
interest itself.

809
00:31:35,195 --> 00:31:37,415
Every time you publish
something new,

810
00:31:37,415 --> 00:31:39,380
you send out an
event-driven

811
00:31:39,380 --> 00:31:41,180
Sync interest in SVS.

812
00:31:41,180 --> 00:31:43,430
We just put the
application data name

813
00:31:43,430 --> 00:31:44,585
into the Sync interest.

814
00:31:44,585 --> 00:31:46,040
This way you can skip

815
00:31:46,040 --> 00:31:47,120
this mapping interest and

816
00:31:47,120 --> 00:31:48,890
data retrieval if you

817
00:31:48,890 --> 00:31:50,540
got the first
Sync interest.

818
00:31:50,540 --> 00:31:52,100
If you did not get
the Sync interest,

819
00:31:52,100 --> 00:31:52,970
then of course
you still need

820
00:31:52,970 --> 00:31:53,960
to fetch the name

821
00:31:53,960 --> 00:31:54,950
before deciding whether to

822
00:31:54,950 --> 00:31:56,495
fetch the data object.

823
00:31:56,495 --> 00:31:58,595
Now by doing this,

824
00:31:58,595 --> 00:32:01,655
what we already have
is fetching data of

825
00:32:01,655 --> 00:32:03,350
arbitrary sizes but now

826
00:32:03,350 --> 00:32:04,820
only the consumers who

827
00:32:04,820 --> 00:32:07,025
need that data will
actually fetch it.

828
00:32:07,025 --> 00:32:09,440
Now we are left
with one problem

829
00:32:09,440 --> 00:32:10,760
that we didn't talk

830
00:32:10,760 --> 00:32:12,455
about security
in all of this.

831
00:32:12,455 --> 00:32:15,230
The application still
needs to sign into

832
00:32:15,230 --> 00:32:16,610
our packets and
so where does

833
00:32:16,610 --> 00:32:18,455
this really go
in all of this?

834
00:32:18,455 --> 00:32:21,830
That's our last layer
which is security.

835
00:32:21,830 --> 00:32:24,500
The question is how
do we do security?

836
00:32:24,500 --> 00:32:25,550
The first thing is who

837
00:32:25,550 --> 00:32:26,960
signs the data packets?

838
00:32:26,960 --> 00:32:29,750
The answer to this
is that that was

839
00:32:29,750 --> 00:32:31,160
the first thing that
applications do

840
00:32:31,160 --> 00:32:32,780
not sign individual
data packets.

841
00:32:32,780 --> 00:32:35,210
The transport or some
security framework

842
00:32:35,210 --> 00:32:37,670
should sign every
data packet.

843
00:32:37,670 --> 00:32:39,140
The second question is,

844
00:32:39,140 --> 00:32:40,505
how do we sign
this packet?

845
00:32:40,505 --> 00:32:41,960
Well, someone has
to give the keys

846
00:32:41,960 --> 00:32:43,655
and that has to be
the application

847
00:32:43,655 --> 00:32:45,290
and it might also be

848
00:32:45,290 --> 00:32:47,390
the security framework
that gets keys.

849
00:32:47,390 --> 00:32:49,025
For example, if you have

850
00:32:49,025 --> 00:32:50,810
encryption on the
data packets,

851
00:32:50,810 --> 00:32:51,980
then you have to have

852
00:32:51,980 --> 00:32:52,880
a security framework

853
00:32:52,880 --> 00:32:53,945
that we'll distribute this

854
00:32:53,945 --> 00:32:55,340
group keys to everyone

855
00:32:55,340 --> 00:32:56,990
and then that will
give the key to

856
00:32:56,990 --> 00:32:58,760
the transport
and that'll be

857
00:32:58,760 --> 00:33:01,070
used to encrypt and
sign the data packets.

858
00:33:01,070 --> 00:33:02,870
The next two
questions, which

859
00:33:02,870 --> 00:33:03,950
I will go into more detail

860
00:33:03,950 --> 00:33:06,800
are what to sign and
how often to sign.

861
00:33:06,800 --> 00:33:08,375
The first question is that

862
00:33:08,375 --> 00:33:09,800
what to sign
and we want to

863
00:33:09,800 --> 00:33:13,160
minimize the sign-in
cost as we do this.

864
00:33:13,160 --> 00:33:16,070
The first observation
is that we have to sign

865
00:33:16,070 --> 00:33:18,650
the application
data blob because

866
00:33:18,650 --> 00:33:20,390
everything has to be
signed whether it's in

867
00:33:20,390 --> 00:33:22,730
transit or it's at rest.

868
00:33:22,730 --> 00:33:24,770
When you put
the data packet

869
00:33:24,770 --> 00:33:26,120
inside another
data packet,

870
00:33:26,120 --> 00:33:28,430
we have to sign the
inner data packet.

871
00:33:28,430 --> 00:33:30,320
That means that
the encapsulated

872
00:33:30,320 --> 00:33:31,640
data packet can be signed.

873
00:33:31,640 --> 00:33:33,830
We can reduce this
cost by aggregating

874
00:33:33,830 --> 00:33:35,075
the inner data
packet which is

875
00:33:35,075 --> 00:33:36,395
what I'll talk about next.

876
00:33:36,395 --> 00:33:38,180
But what about the
outer data packet?

877
00:33:38,180 --> 00:33:41,150
We can assign
each data packet

878
00:33:41,150 --> 00:33:42,575
that we put on the network

879
00:33:42,575 --> 00:33:44,329
using asymmetric
key signatures.

880
00:33:44,329 --> 00:33:45,560
The problem with
this approach is

881
00:33:45,560 --> 00:33:47,660
that producing this
signature creates

882
00:33:47,660 --> 00:33:49,250
a lot of overhead and if

883
00:33:49,250 --> 00:33:50,570
the application
is producing

884
00:33:50,570 --> 00:33:51,890
a large number of objects,

885
00:33:51,890 --> 00:33:52,940
then this is going to

886
00:33:52,940 --> 00:33:54,980
add to the overhead a lot.

887
00:33:54,980 --> 00:33:57,080
The one way to
reduce this overhead

888
00:33:57,080 --> 00:33:59,089
is to use symmetric
key signatures.

889
00:33:59,089 --> 00:34:00,275
For this, we need

890
00:34:00,275 --> 00:34:02,015
a group key
distribution mechanism

891
00:34:02,015 --> 00:34:03,935
that is somewhere in
the security framework.

892
00:34:03,935 --> 00:34:06,905
One advantage that
we get by doing this

893
00:34:06,905 --> 00:34:08,525
is that we can
also encrypt

894
00:34:08,525 --> 00:34:10,010
the outer data packet.

895
00:34:10,010 --> 00:34:12,530
If we encrypt the
outer data packet then

896
00:34:12,530 --> 00:34:14,060
no one can read the name

897
00:34:14,060 --> 00:34:15,155
of the inner data packet.

898
00:34:15,155 --> 00:34:16,805
It provides the
application with

899
00:34:16,805 --> 00:34:20,135
name privacy for the
application data name.

900
00:34:20,135 --> 00:34:22,340
The next thing is that we

901
00:34:22,340 --> 00:34:23,930
can reduce the
sign-in cost further

902
00:34:23,930 --> 00:34:28,760
by aggregating the
application data into one.

903
00:34:28,760 --> 00:34:30,770
The simple idea here is

904
00:34:30,770 --> 00:34:32,390
that the application
might produce

905
00:34:32,390 --> 00:34:33,500
multiple data objects of

906
00:34:33,500 --> 00:34:35,660
small sizes and
we cut this into

907
00:34:35,660 --> 00:34:36,964
one before publishing

908
00:34:36,964 --> 00:34:39,350
a single page
application data object.

909
00:34:39,350 --> 00:34:40,670
This will reduce
the signing

910
00:34:40,670 --> 00:34:41,930
overhead because
now you don't have

911
00:34:41,930 --> 00:34:42,620
to sign each of

912
00:34:42,620 --> 00:34:44,569
these smaller packets
individually.

913
00:34:44,569 --> 00:34:45,815
Here's an example that

914
00:34:45,815 --> 00:34:47,720
if you have a
temperature sensor

915
00:34:47,720 --> 00:34:48,830
which generates

916
00:34:48,830 --> 00:34:51,215
temperature readings
every 15 minutes,

917
00:34:51,215 --> 00:34:53,930
then you can just club
them 30 minutes at

918
00:34:53,930 --> 00:34:54,950
a time and put them into

919
00:34:54,950 --> 00:34:56,870
a single application
data object,

920
00:34:56,870 --> 00:34:58,040
and then publish
this object.

921
00:34:58,040 --> 00:34:59,690
You need to sign
them only once now.

922
00:34:59,690 --> 00:35:01,820
The advantage of doing
this is obvious,

923
00:35:01,820 --> 00:35:04,040
you reduce the
signing overhead,

924
00:35:04,040 --> 00:35:04,820
you can have

925
00:35:04,820 --> 00:35:06,110
network throughput
because you have

926
00:35:06,110 --> 00:35:07,460
lower channel access for

927
00:35:07,460 --> 00:35:09,335
wireless just lower
packet count.

928
00:35:09,335 --> 00:35:11,030
The problem with this
approach is that

929
00:35:11,030 --> 00:35:12,740
semantic naming
may be difficult.

930
00:35:12,740 --> 00:35:14,360
In this case, naming

931
00:35:14,360 --> 00:35:16,760
this outer bigger
aggregated object

932
00:35:16,760 --> 00:35:19,550
was easy but it might
not always be so.

933
00:35:19,550 --> 00:35:22,100
An example of
this is here that

934
00:35:22,100 --> 00:35:23,240
you have temperature
data and

935
00:35:23,240 --> 00:35:24,260
you have humidity data

936
00:35:24,260 --> 00:35:26,960
so now you cannot
aggregate all these into

937
00:35:26,960 --> 00:35:29,510
one single object and

938
00:35:29,510 --> 00:35:32,030
name it which makes
sense as well.

939
00:35:32,030 --> 00:35:34,250
Here's a secondary
approach

940
00:35:34,250 --> 00:35:35,330
that we can also do

941
00:35:35,330 --> 00:35:36,590
to reduce the sign-in cost

942
00:35:36,590 --> 00:35:38,750
is that of a
signature manifest.

943
00:35:38,750 --> 00:35:41,285
We take individual
data packets,

944
00:35:41,285 --> 00:35:42,995
we publish them
immediately,

945
00:35:42,995 --> 00:35:45,455
and then instead of
signing each data packet,

946
00:35:45,455 --> 00:35:46,670
we periodically publish

947
00:35:46,670 --> 00:35:48,320
a signature for
all of these.

948
00:35:48,320 --> 00:35:49,925
For doing this we take

949
00:35:49,925 --> 00:35:51,200
the names of each

950
00:35:51,200 --> 00:35:52,280
of these data
packets that are

951
00:35:52,280 --> 00:35:54,140
already published
and then we take

952
00:35:54,140 --> 00:35:56,090
the dieses which
might be part of

953
00:35:56,090 --> 00:35:57,710
the name and we
put them all into

954
00:35:57,710 --> 00:36:00,425
one data packet and we
give this data packet

955
00:36:00,425 --> 00:36:02,000
a name that identifies

956
00:36:02,000 --> 00:36:03,275
that this is the signature

957
00:36:03,275 --> 00:36:05,195
for these data packets

958
00:36:05,195 --> 00:36:07,145
which is just
represented over here.

959
00:36:07,145 --> 00:36:08,840
Then we assign
this data packet.

960
00:36:08,840 --> 00:36:11,705
As soon as you get
this big data packet,

961
00:36:11,705 --> 00:36:13,610
the signature
manifest, then you can

962
00:36:13,610 --> 00:36:15,845
verify all of the
previous data packets.

963
00:36:15,845 --> 00:36:17,615
By doing this, we

964
00:36:17,615 --> 00:36:19,160
retain semantic
naming for each

965
00:36:19,160 --> 00:36:20,975
of the individual
data packets

966
00:36:20,975 --> 00:36:22,340
that we published earlier.

967
00:36:22,340 --> 00:36:23,900
All of these smaller

968
00:36:23,900 --> 00:36:25,160
packets will also
be published

969
00:36:25,160 --> 00:36:26,420
earlier and
then we publish

970
00:36:26,420 --> 00:36:27,680
the signature manifest to

971
00:36:27,680 --> 00:36:29,700
verify all of these.

972
00:36:29,770 --> 00:36:32,000
There are two
more questions.

973
00:36:32,000 --> 00:36:34,445
What do we do with
this aggregation?

974
00:36:34,445 --> 00:36:36,620
The answer is that
the Pub/Sub library

975
00:36:36,620 --> 00:36:38,660
or the transport
library must do this.

976
00:36:38,660 --> 00:36:40,340
Again, we don't
want to leave this

977
00:36:40,340 --> 00:36:41,810
to the application
to actually do

978
00:36:41,810 --> 00:36:43,580
this because you need to

979
00:36:43,580 --> 00:36:46,415
know other network
layer stuff to do this.

980
00:36:46,415 --> 00:36:49,490
But whether we
want to do this,

981
00:36:49,490 --> 00:36:51,590
this should be defined
by the application.

982
00:36:51,590 --> 00:36:52,910
It's behaviorally
defined by

983
00:36:52,910 --> 00:36:55,460
the application than in
the Pub/Sub library.

984
00:36:55,460 --> 00:36:57,275
There is a
downside to doing

985
00:36:57,275 --> 00:36:58,970
this which is
that it would add

986
00:36:58,970 --> 00:37:00,860
delay because
you cannot now

987
00:37:00,860 --> 00:37:01,880
fetch and

988
00:37:01,880 --> 00:37:03,965
verify the data in
real-time anymore.

989
00:37:03,965 --> 00:37:05,615
If you're using
signature manifest,

990
00:37:05,615 --> 00:37:07,280
then you still need to get

991
00:37:07,280 --> 00:37:09,575
the manifest to actually
verify the data and

992
00:37:09,575 --> 00:37:11,180
it's the same
for aggregating

993
00:37:11,180 --> 00:37:12,680
the data into one
packet that you still

994
00:37:12,680 --> 00:37:13,865
need to wait before

995
00:37:13,865 --> 00:37:15,200
the producer
actually sends

996
00:37:15,200 --> 00:37:17,190
out the big data packet.

997
00:37:18,010 --> 00:37:20,510
>> Three minutes left.

998
00:37:20,510 --> 00:37:22,160
>> Thank you. There are

999
00:37:22,160 --> 00:37:23,330
two use cases where we

1000
00:37:23,330 --> 00:37:25,070
can demonstrate
this aggregation.

1001
00:37:25,070 --> 00:37:26,780
The first is that we have

1002
00:37:26,780 --> 00:37:28,910
generation plant
status updates

1003
00:37:28,910 --> 00:37:30,170
where we have
regularly scheduled

1004
00:37:30,170 --> 00:37:31,670
readings and we
need to get this

1005
00:37:31,670 --> 00:37:33,260
to the consumers
as fast as

1006
00:37:33,260 --> 00:37:35,210
possible with
minimal latency.

1007
00:37:35,210 --> 00:37:36,590
The second is that we

1008
00:37:36,590 --> 00:37:37,880
have nuclear power
plant sensors.

1009
00:37:37,880 --> 00:37:39,470
There are a lot of
these and we just

1010
00:37:39,470 --> 00:37:41,255
need to get
updates from these

1011
00:37:41,255 --> 00:37:43,730
at every hour and we have

1012
00:37:43,730 --> 00:37:45,245
very limited wireless

1013
00:37:45,245 --> 00:37:46,745
data bandwidth
and capacity.

1014
00:37:46,745 --> 00:37:48,620
It's obvious that
for the first case,

1015
00:37:48,620 --> 00:37:50,450
we cannot do
aggregation because

1016
00:37:50,450 --> 00:37:51,620
we cannot tolerate
that delay

1017
00:37:51,620 --> 00:37:52,520
that it brings,

1018
00:37:52,520 --> 00:37:54,410
and for the second case,

1019
00:37:54,410 --> 00:37:56,240
the aggregation will
bring about a lot of

1020
00:37:56,240 --> 00:37:57,800
benefits because
we are going

1021
00:37:57,800 --> 00:37:59,795
to reduce the
channel access and

1022
00:37:59,795 --> 00:38:00,320
we have to better

1023
00:38:00,320 --> 00:38:02,820
utilize our
network capacity.

1024
00:38:03,100 --> 00:38:05,540
At the end of all of this,

1025
00:38:05,540 --> 00:38:07,310
what we have is we
built a system in

1026
00:38:07,310 --> 00:38:09,530
which we have
the application

1027
00:38:09,530 --> 00:38:11,570
producing data units of

1028
00:38:11,570 --> 00:38:13,640
arbitrary size
and these are

1029
00:38:13,640 --> 00:38:15,680
signed and it can also

1030
00:38:15,680 --> 00:38:16,955
be encrypted by either the

1031
00:38:16,955 --> 00:38:19,205
security framework
or the transport

1032
00:38:19,205 --> 00:38:20,810
using the keys provided by

1033
00:38:20,810 --> 00:38:21,860
the application or

1034
00:38:21,860 --> 00:38:23,660
the security framework
or the transport.

1035
00:38:23,660 --> 00:38:25,220
Then these are
delivered by

1036
00:38:25,220 --> 00:38:27,215
the transport only
to the consumers

1037
00:38:27,215 --> 00:38:29,000
that actually
need this data

1038
00:38:29,000 --> 00:38:30,965
regardless of the
size or the number of

1039
00:38:30,965 --> 00:38:32,780
data units and
this is done

1040
00:38:32,780 --> 00:38:36,080
efficiently regardless
of what they are.

1041
00:38:36,080 --> 00:38:39,035
The entire process
is summarized in

1042
00:38:39,035 --> 00:38:40,310
this slide which I
don't really want to

1043
00:38:40,310 --> 00:38:42,780
cover because it's
a bit complicated.

1044
00:38:42,940 --> 00:38:45,500
The future directions
for this work is

1045
00:38:45,500 --> 00:38:47,120
that we want to
investigate how

1046
00:38:47,120 --> 00:38:48,980
do we scale SVS because we

1047
00:38:48,980 --> 00:38:50,885
put the entire
dataset into

1048
00:38:50,885 --> 00:38:53,450
one Sync interest
which is obviously not

1049
00:38:53,450 --> 00:38:56,285
going to work if you
have a lot of producers.

1050
00:38:56,285 --> 00:38:57,935
This needs working that we

1051
00:38:57,935 --> 00:38:58,490
can send out

1052
00:38:58,490 --> 00:38:59,690
partial state
vectors or something

1053
00:38:59,690 --> 00:39:01,190
like that and
we also want to

1054
00:39:01,190 --> 00:39:04,400
investigate data
aggregation further.

1055
00:39:04,400 --> 00:39:07,055
Those are our ongoing
and future directions.

1056
00:39:07,055 --> 00:39:08,570
I guess that's it for
our presentation.

1057
00:39:08,570 --> 00:39:09,905
Thank you.

1058
00:39:09,905 --> 00:39:12,800
>> Thank you. I
really appreciate it.

1059
00:39:12,800 --> 00:39:14,975
Go ahead and stop sharing

1060
00:39:14,975 --> 00:39:18,905
and there's some
discussion on slack.

1061
00:39:18,905 --> 00:39:20,090
Well, if you want to join,

1062
00:39:20,090 --> 00:39:23,285
I think Lisa is
already working on it.

1063
00:39:23,285 --> 00:39:25,925
The next
presentation will be

1064
00:39:25,925 --> 00:39:28,835
by Proyash who is
a PhD student at

1065
00:39:28,835 --> 00:39:31,640
Florida International
University working

1066
00:39:31,640 --> 00:39:34,115
with Alex Afanasyev and

1067
00:39:34,115 --> 00:39:35,420
his research interests

1068
00:39:35,420 --> 00:39:36,770
include the security of

1069
00:39:36,770 --> 00:39:37,940
computer networks

1070
00:39:37,940 --> 00:39:40,445
and future internet
architectures,

1071
00:39:40,445 --> 00:39:41,960
specifically at the end

1072
00:39:41,960 --> 00:39:44,240
and he's also
working on projects

1073
00:39:44,240 --> 00:39:45,770
that involve using NDN in

1074
00:39:45,770 --> 00:39:49,260
vehicular environments.
Go ahead Proyash.

1075
00:39:52,060 --> 00:39:59,690
>> You're actually
muted. Proyash,

1076
00:39:59,690 --> 00:40:01,250
can you guys hear
me? You're muted.

1077
00:40:01,250 --> 00:40:07,965
>> Yeah.

1078
00:40:07,965 --> 00:40:09,835
>> Can you hear me now?

1079
00:40:09,835 --> 00:40:10,900
>> I can hear you now,

1080
00:40:10,900 --> 00:40:12,860
but we lost your screen.

1081
00:40:13,410 --> 00:40:15,520
>> Can you see
the screen now?

1082
00:40:15,520 --> 00:40:18,560
>> Yes, you're good
to go. Thank you.

1083
00:40:18,810 --> 00:40:20,710
>> Thank you Christos for

1084
00:40:20,710 --> 00:40:22,210
the introduction
and hello everyone.

1085
00:40:22,210 --> 00:40:24,220
I am Proyash Podder
and I will be

1086
00:40:24,220 --> 00:40:26,905
presenting our work sV2Pc.

1087
00:40:26,905 --> 00:40:29,605
Where we will try to

1088
00:40:29,605 --> 00:40:31,870
scale the communication

1089
00:40:31,870 --> 00:40:33,265
in vehicle or environment.

1090
00:40:33,265 --> 00:40:35,290
We are specifically
focused on

1091
00:40:35,290 --> 00:40:38,950
the V-to-P communication
using Indian.

1092
00:40:38,950 --> 00:40:41,290
This is a collaborative
project between

1093
00:40:41,290 --> 00:40:43,120
Florida International
University

1094
00:40:43,120 --> 00:40:45,770
and Ford Motor Company.

1095
00:40:46,560 --> 00:40:48,970
The very high
level objective

1096
00:40:48,970 --> 00:40:50,530
of the project is
to demonstrate

1097
00:40:50,530 --> 00:40:53,860
the advantageous of NDN
in CV2X environment.

1098
00:40:53,860 --> 00:40:55,690
We have sorted
out some issues

1099
00:40:55,690 --> 00:40:56,710
in the current system,

1100
00:40:56,710 --> 00:40:59,080
mainly scalability
issue in the context of

1101
00:40:59,080 --> 00:41:01,930
pedestrian safety
applications and propose

1102
00:41:01,930 --> 00:41:04,300
some insights that we
might use to solve

1103
00:41:04,300 --> 00:41:06,370
such issues by leveraging

1104
00:41:06,370 --> 00:41:08,425
the benefits of using NDN.

1105
00:41:08,425 --> 00:41:10,750
Based on that, we
have developed

1106
00:41:10,750 --> 00:41:13,780
sV2Pc and NDN
forwarding strategy,

1107
00:41:13,780 --> 00:41:15,445
which is a better suit

1108
00:41:15,445 --> 00:41:17,050
in vehicular environment

1109
00:41:17,050 --> 00:41:19,159
to ensure scalability.

1110
00:41:19,230 --> 00:41:22,210
Before a deep dive
into our presentation,

1111
00:41:22,210 --> 00:41:23,755
I first wanted to provide

1112
00:41:23,755 --> 00:41:25,495
an overview of PSM

1113
00:41:25,495 --> 00:41:27,310
or a personal
safety message,

1114
00:41:27,310 --> 00:41:29,650
which although not
implemented yet,

1115
00:41:29,650 --> 00:41:31,270
but it is
considered a viable

1116
00:41:31,270 --> 00:41:33,760
solution for ensuring
pedestrian safety.

1117
00:41:33,760 --> 00:41:37,990
In PSM, all vulnerable
roadside users,

1118
00:41:37,990 --> 00:41:40,420
like the pedestrian,
the cyclist, etcetera.

1119
00:41:40,420 --> 00:41:41,890
They will broadcast PSM

1120
00:41:41,890 --> 00:41:43,495
messages periodically.

1121
00:41:43,495 --> 00:41:45,370
Those messages contain

1122
00:41:45,370 --> 00:41:48,565
some basic information
like their speed,

1123
00:41:48,565 --> 00:41:50,320
their position in
which direction

1124
00:41:50,320 --> 00:41:52,330
they're heading
to, etcetera.

1125
00:41:52,330 --> 00:41:56,305
The period of the
broadcast is one second.

1126
00:41:56,305 --> 00:41:59,800
In each second, all
of these entities

1127
00:41:59,800 --> 00:42:02,140
actually generate
one new message

1128
00:42:02,140 --> 00:42:04,685
and transmit to
the network.

1129
00:42:04,685 --> 00:42:06,150
Now,

1130
00:42:06,150 --> 00:42:08,630
imagine a crowded
intersection like this,

1131
00:42:08,630 --> 00:42:11,140
and what will happen
if all of them

1132
00:42:11,140 --> 00:42:14,050
broadcasting PSM messages
in every second.

1133
00:42:14,050 --> 00:42:16,090
In this case, we
need to facilitate

1134
00:42:16,090 --> 00:42:18,415
a huge amount of
bandwidth for that.

1135
00:42:18,415 --> 00:42:20,470
We can say it
like this system

1136
00:42:20,470 --> 00:42:22,855
is not scalable at all.

1137
00:42:22,855 --> 00:42:26,020
To address this
scalability issue, mainly,

1138
00:42:26,020 --> 00:42:28,090
we think of using
NDN to solve

1139
00:42:28,090 --> 00:42:30,400
this issue and
first simulation,

1140
00:42:30,400 --> 00:42:31,480
we have used a simple

1141
00:42:31,480 --> 00:42:33,635
intersectional
awareness application.

1142
00:42:33,635 --> 00:42:35,430
We have designed
a forwarding

1143
00:42:35,430 --> 00:42:36,810
strategy as sV2Pc,

1144
00:42:36,810 --> 00:42:39,570
which is completely
distributed and simple,

1145
00:42:39,570 --> 00:42:40,920
and works on by

1146
00:42:40,920 --> 00:42:42,660
suppressing similar type

1147
00:42:42,660 --> 00:42:44,070
of interesting
data packets.

1148
00:42:44,070 --> 00:42:45,270
Then also work on like

1149
00:42:45,270 --> 00:42:46,290
geographical boundaries

1150
00:42:46,290 --> 00:42:48,970
for interest forwarding.

1151
00:42:49,500 --> 00:42:52,630
To identify the
communication issue and

1152
00:42:52,630 --> 00:42:54,850
also highlight the
proposed design decisions.

1153
00:42:54,850 --> 00:42:56,320
We have developed
a simplified

1154
00:42:56,320 --> 00:42:57,820
use case application named

1155
00:42:57,820 --> 00:42:59,365
NDN-PSA or

1156
00:42:59,365 --> 00:43:01,765
NDN based pedestrian
safety application.

1157
00:43:01,765 --> 00:43:03,910
More specifically
it will enable

1158
00:43:03,910 --> 00:43:06,670
communication
between cars who

1159
00:43:06,670 --> 00:43:08,485
are like approaching
to the intersection,

1160
00:43:08,485 --> 00:43:09,790
and pedestrians who are

1161
00:43:09,790 --> 00:43:12,310
like crossing the
intersection are located

1162
00:43:12,310 --> 00:43:13,540
near the
intersection using

1163
00:43:13,540 --> 00:43:14,590
our request response

1164
00:43:14,590 --> 00:43:16,180
based NDN mechanism to

1165
00:43:16,180 --> 00:43:18,175
avoid any potential
coalition.

1166
00:43:18,175 --> 00:43:20,380
For example, the
cars will send

1167
00:43:20,380 --> 00:43:22,090
interest to know whether

1168
00:43:22,090 --> 00:43:23,574
there would be
any pedestrian

1169
00:43:23,574 --> 00:43:25,270
in any particular area

1170
00:43:25,270 --> 00:43:27,144
that may be on
its trajectory

1171
00:43:27,144 --> 00:43:28,810
and relevant pedestrians.

1172
00:43:28,810 --> 00:43:31,765
I mean, like who might be

1173
00:43:31,765 --> 00:43:34,195
present in a
close proximity

1174
00:43:34,195 --> 00:43:35,425
of the target location,

1175
00:43:35,425 --> 00:43:38,410
will reply with a data
packets and by this,

1176
00:43:38,410 --> 00:43:39,520
the car will know that,

1177
00:43:39,520 --> 00:43:41,320
they're pedestrians
presence

1178
00:43:41,320 --> 00:43:43,700
and take decisions
accordingly.

1179
00:43:44,100 --> 00:43:46,480
Designing the
naming scheme is

1180
00:43:46,480 --> 00:43:48,955
a very crucial factor
for NDN application.

1181
00:43:48,955 --> 00:43:50,215
To keep things simple,

1182
00:43:50,215 --> 00:43:52,165
our naming scheme consists

1183
00:43:52,165 --> 00:43:53,590
of just three components.

1184
00:43:53,590 --> 00:43:56,650
The app name, which is
NDN-PSA in our case.

1185
00:43:56,650 --> 00:43:58,645
We will have the region of

1186
00:43:58,645 --> 00:44:00,955
interest which is actually

1187
00:44:00,955 --> 00:44:03,475
our coarsely defined area

1188
00:44:03,475 --> 00:44:06,370
about what a car
wants to query,

1189
00:44:06,370 --> 00:44:07,330
like whether there'll be

1190
00:44:07,330 --> 00:44:08,905
any pedestrian or not.

1191
00:44:08,905 --> 00:44:10,780
We also include the time

1192
00:44:10,780 --> 00:44:12,085
of sending the interest.

1193
00:44:12,085 --> 00:44:14,860
However, as sV2Pc mainly

1194
00:44:14,860 --> 00:44:16,630
works on suppressing

1195
00:44:16,630 --> 00:44:18,415
similar types of interest,

1196
00:44:18,415 --> 00:44:20,230
or maybe the
packets we'd have

1197
00:44:20,230 --> 00:44:21,895
the same name or
similar name.

1198
00:44:21,895 --> 00:44:23,290
These components, that

1199
00:44:23,290 --> 00:44:24,550
region of interest time,

1200
00:44:24,550 --> 00:44:26,425
this must be
coarse enough,

1201
00:44:26,425 --> 00:44:28,035
so that we can get like

1202
00:44:28,035 --> 00:44:30,330
a repeatable names and

1203
00:44:30,330 --> 00:44:32,490
how we have made the
name of details,

1204
00:44:32,490 --> 00:44:34,965
we will discuss in
the later slides.

1205
00:44:34,965 --> 00:44:37,560
In this slide,
I will provide

1206
00:44:37,560 --> 00:44:38,835
a high level overview

1207
00:44:38,835 --> 00:44:40,575
of our use case
application.

1208
00:44:40,575 --> 00:44:43,185
Suppose this
blue-marked car

1209
00:44:43,185 --> 00:44:44,580
is approaching to

1210
00:44:44,580 --> 00:44:46,680
the intersection
and wants to

1211
00:44:46,680 --> 00:44:49,770
know if some pedestrian
might be there.

1212
00:44:49,770 --> 00:44:51,515
It sends an interest,

1213
00:44:51,515 --> 00:44:53,740
and the interest name,

1214
00:44:53,740 --> 00:44:55,300
we can see the
application name,

1215
00:44:55,300 --> 00:44:56,830
then the target location.

1216
00:44:56,830 --> 00:44:58,420
For simulation
purposes it is like

1217
00:44:58,420 --> 00:45:01,025
a geo coordinate and
also the current time.

1218
00:45:01,025 --> 00:45:04,185
Imagine these
two pedestrian

1219
00:45:04,185 --> 00:45:06,240
the green one and
the orange one.

1220
00:45:06,240 --> 00:45:08,070
They are in the
transmission range

1221
00:45:08,070 --> 00:45:10,775
of the car and they
receives the interests.

1222
00:45:10,775 --> 00:45:12,670
Then they will calculate

1223
00:45:12,670 --> 00:45:15,130
their own position
or geolocation and

1224
00:45:15,130 --> 00:45:17,200
compare if they are in

1225
00:45:17,200 --> 00:45:20,245
a close proximity with
the target location,

1226
00:45:20,245 --> 00:45:21,490
which is actually
expressed

1227
00:45:21,490 --> 00:45:22,990
in the interest name.

1228
00:45:22,990 --> 00:45:25,900
The green guy, it
says that, "Hey,

1229
00:45:25,900 --> 00:45:27,820
I'm far away
from the target

1230
00:45:27,820 --> 00:45:30,145
location" and it can
ignore the interest.

1231
00:45:30,145 --> 00:45:31,990
But the orange one is

1232
00:45:31,990 --> 00:45:33,910
located in close
proximity and

1233
00:45:33,910 --> 00:45:36,100
thus he sends
a data packet

1234
00:45:36,100 --> 00:45:37,900
back with its position,

1235
00:45:37,900 --> 00:45:38,875
speed, etcetera, to

1236
00:45:38,875 --> 00:45:41,180
alert the
approaching vehicle.

1237
00:45:41,940 --> 00:45:44,440
It may seem to some of you

1238
00:45:44,440 --> 00:45:46,390
that we just shift
the paradigm of

1239
00:45:46,390 --> 00:45:48,685
PSM where I like
interest instead of

1240
00:45:48,685 --> 00:45:51,130
the pedestrian
broadcasting messages,

1241
00:45:51,130 --> 00:45:52,270
the car sending interest

1242
00:45:52,270 --> 00:45:54,505
periodically and the
pedestrians respond,

1243
00:45:54,505 --> 00:45:57,175
if it's simpler level
and which is true.

1244
00:45:57,175 --> 00:45:58,810
But however now
the question is,

1245
00:45:58,810 --> 00:46:00,460
will any request response

1246
00:46:00,460 --> 00:46:02,410
based system will
solve the issue?

1247
00:46:02,410 --> 00:46:04,960
The answer is no. Think of

1248
00:46:04,960 --> 00:46:07,390
this busy intersection
with lots of cars.

1249
00:46:07,390 --> 00:46:10,015
If all of them start
asking question,

1250
00:46:10,015 --> 00:46:12,385
or sending interest
in NDN term,

1251
00:46:12,385 --> 00:46:13,825
in every second,

1252
00:46:13,825 --> 00:46:16,645
a huge network traffic
would be generated.

1253
00:46:16,645 --> 00:46:18,744
Again, the crowded
intersection,

1254
00:46:18,744 --> 00:46:21,010
if all the
pedestrian reply

1255
00:46:21,010 --> 00:46:23,260
with every interest
they have received,

1256
00:46:23,260 --> 00:46:24,670
again, we will generating

1257
00:46:24,670 --> 00:46:26,485
a huge network traffic.

1258
00:46:26,485 --> 00:46:30,220
In both cases, these
are no better than PSM.

1259
00:46:30,220 --> 00:46:32,110
Here comes NDN to solve

1260
00:46:32,110 --> 00:46:34,855
the issue with some of
it's unique feature

1261
00:46:34,855 --> 00:46:37,060
NDN can provide
solution to solve

1262
00:46:37,060 --> 00:46:38,110
this issue and build

1263
00:46:38,110 --> 00:46:40,250
a physical communication.

1264
00:46:40,890 --> 00:46:43,990
Inspirit from the
previous two issues,

1265
00:46:43,990 --> 00:46:45,820
we first ask the question,

1266
00:46:45,820 --> 00:46:47,455
do all the cars

1267
00:46:47,455 --> 00:46:50,230
actually need to send
interest packets?

1268
00:46:50,230 --> 00:46:52,180
Think of a scenario

1269
00:46:52,180 --> 00:46:55,060
where these two
mark cars want

1270
00:46:55,060 --> 00:46:57,085
to know about
the presence of

1271
00:46:57,085 --> 00:46:59,695
any pedestrian in
the same location.

1272
00:46:59,695 --> 00:47:02,590
As like they are running
in the same lane,

1273
00:47:02,590 --> 00:47:05,140
they will cross
the steam portion

1274
00:47:05,140 --> 00:47:06,985
with the crosswalk,

1275
00:47:06,985 --> 00:47:09,580
their region of
interest would be seen.

1276
00:47:09,580 --> 00:47:12,340
We can assume that they

1277
00:47:12,340 --> 00:47:14,785
are trying to send
the same interests,

1278
00:47:14,785 --> 00:47:16,705
at least with the
same interest name.

1279
00:47:16,705 --> 00:47:20,050
Instead of sending our
new interest package,

1280
00:47:20,050 --> 00:47:21,280
it may happen that one of

1281
00:47:21,280 --> 00:47:23,110
them can ask and other can

1282
00:47:23,110 --> 00:47:24,550
simply use the answer

1283
00:47:24,550 --> 00:47:25,285
instead of

1284
00:47:25,285 --> 00:47:27,685
transmitting a new
interest packet.

1285
00:47:27,685 --> 00:47:29,860
Based on this assumption,

1286
00:47:29,860 --> 00:47:31,270
we have used the interests

1287
00:47:31,270 --> 00:47:32,905
separation mechanism

1288
00:47:32,905 --> 00:47:34,390
so that if a group of

1289
00:47:34,390 --> 00:47:36,385
car wants to ask

1290
00:47:36,385 --> 00:47:38,365
the same question and

1291
00:47:38,365 --> 00:47:40,300
one of them has
already asked,

1292
00:47:40,300 --> 00:47:41,230
then the others will

1293
00:47:41,230 --> 00:47:43,490
suppress their
own interest.

1294
00:47:43,530 --> 00:47:46,855
Now lots of interest
has been suppressed.

1295
00:47:46,855 --> 00:47:48,355
But think of
this again for

1296
00:47:48,355 --> 00:47:50,365
all the interests
that being sent.

1297
00:47:50,365 --> 00:47:52,525
If all the pedestrians,

1298
00:47:52,525 --> 00:47:54,490
they reply with
data packets back,

1299
00:47:54,490 --> 00:47:55,810
then again, we will

1300
00:47:55,810 --> 00:47:58,400
generate a huge
amount of traffic.

1301
00:47:58,920 --> 00:48:01,240
The same question
now we can

1302
00:48:01,240 --> 00:48:02,890
ask for the
pedestrian also,

1303
00:48:02,890 --> 00:48:05,665
do all the pedestrians
need to reply?

1304
00:48:05,665 --> 00:48:08,905
Suppose this
blue-marked car

1305
00:48:08,905 --> 00:48:10,900
want to take a right turn,

1306
00:48:10,900 --> 00:48:13,300
at the intersection
and wants to

1307
00:48:13,300 --> 00:48:14,620
know if there would be

1308
00:48:14,620 --> 00:48:16,555
any pedestrian
in region one,

1309
00:48:16,555 --> 00:48:18,775
and thus sends an
interest packet.

1310
00:48:18,775 --> 00:48:21,400
Now, all of the
pedestrian in

1311
00:48:21,400 --> 00:48:24,310
region one would
receive the interest.

1312
00:48:24,310 --> 00:48:27,490
Theoretically
they can try to

1313
00:48:27,490 --> 00:48:29,410
reply for the
interest packet

1314
00:48:29,410 --> 00:48:31,295
and send individual
data packets.

1315
00:48:31,295 --> 00:48:33,120
But at least for

1316
00:48:33,120 --> 00:48:35,340
the context of
our application.

1317
00:48:35,340 --> 00:48:36,960
Which is like the car

1318
00:48:36,960 --> 00:48:38,280
wants to know
if there would

1319
00:48:38,280 --> 00:48:41,675
be any obstacle in his
trajectory or not.

1320
00:48:41,675 --> 00:48:43,750
At least in our context,

1321
00:48:43,750 --> 00:48:44,920
we can say that this is

1322
00:48:44,920 --> 00:48:47,965
quite unnecessary
and single reply

1323
00:48:47,965 --> 00:48:49,780
is sufficient to alert

1324
00:48:49,780 --> 00:48:52,015
the vehicles
from R1 region.

1325
00:48:52,015 --> 00:48:53,740
Based on this assumption,

1326
00:48:53,740 --> 00:48:56,965
we have used that data
suppression mechanism

1327
00:48:56,965 --> 00:48:58,600
to suppress any
unnecessary

1328
00:48:58,600 --> 00:49:00,055
and redundant traffic.

1329
00:49:00,055 --> 00:49:02,635
In data suppression,

1330
00:49:02,635 --> 00:49:05,110
if any pedestrian receives

1331
00:49:05,110 --> 00:49:08,170
any interest and
is able to reply,

1332
00:49:08,170 --> 00:49:10,105
but some other
pedestrian has

1333
00:49:10,105 --> 00:49:11,290
already replied for

1334
00:49:11,290 --> 00:49:12,640
the same interest packet,

1335
00:49:12,640 --> 00:49:15,050
then it will not
reply anymore.

1336
00:49:15,450 --> 00:49:17,740
We have also introduced

1337
00:49:17,740 --> 00:49:19,570
some other types
of suppression.

1338
00:49:19,570 --> 00:49:21,070
This suppression
mechanisms have

1339
00:49:21,070 --> 00:49:22,600
been used in lots
of previous world,

1340
00:49:22,600 --> 00:49:24,340
but we find them to

1341
00:49:24,340 --> 00:49:26,825
be better used
in our context,

1342
00:49:26,825 --> 00:49:29,129
like in a multiple
hops scenario,

1343
00:49:29,129 --> 00:49:30,855
for order should
only follow up

1344
00:49:30,855 --> 00:49:32,190
the interest in
the direction of

1345
00:49:32,190 --> 00:49:33,770
reporting shared
data producer.

1346
00:49:33,770 --> 00:49:35,170
For example,
this car sends

1347
00:49:35,170 --> 00:49:37,450
an interest packet and
all these three cars,

1348
00:49:37,450 --> 00:49:38,860
receive the interest and

1349
00:49:38,860 --> 00:49:40,510
theoretically they can all

1350
00:49:40,510 --> 00:49:42,175
rebroadcast the
interest again.

1351
00:49:42,175 --> 00:49:43,795
But in our scenario,

1352
00:49:43,795 --> 00:49:46,810
a potential data
producer will be present

1353
00:49:46,810 --> 00:49:50,885
on or near the
intersection.

1354
00:49:50,885 --> 00:49:52,870
Now the question is,

1355
00:49:52,870 --> 00:49:55,630
will this red marked
car rebroadcast

1356
00:49:55,630 --> 00:49:58,040
would be helpful or not?

1357
00:49:58,290 --> 00:50:01,540
It is obvious that
these rebroadcast

1358
00:50:01,540 --> 00:50:02,800
will not be
helpful because

1359
00:50:02,800 --> 00:50:04,750
this is in the
opposite direction

1360
00:50:04,750 --> 00:50:06,880
from the potential
data producer.

1361
00:50:06,880 --> 00:50:09,010
In this case, this
car just discard

1362
00:50:09,010 --> 00:50:10,030
the interest and

1363
00:50:10,030 --> 00:50:12,945
the other scheduling
broadcast.

1364
00:50:12,945 --> 00:50:15,065
Again in this example,

1365
00:50:15,065 --> 00:50:16,655
these cars sends interest

1366
00:50:16,655 --> 00:50:18,410
and both of these cars,

1367
00:50:18,410 --> 00:50:19,745
receive the interest now.

1368
00:50:19,745 --> 00:50:21,770
Both of them can
rebroadcast actually.

1369
00:50:21,770 --> 00:50:23,405
But based on our example,

1370
00:50:23,405 --> 00:50:26,180
this red markers
rebroadcast

1371
00:50:26,180 --> 00:50:27,230
would be more helpful

1372
00:50:27,230 --> 00:50:29,390
because it is closer

1373
00:50:29,390 --> 00:50:32,220
to potential
data producer.

1374
00:50:33,010 --> 00:50:35,240
This is our
design approach

1375
00:50:35,240 --> 00:50:36,860
from consumer's
perspective,

1376
00:50:36,860 --> 00:50:38,720
like when a car is close

1377
00:50:38,720 --> 00:50:40,745
to an intersection
by certain limit,

1378
00:50:40,745 --> 00:50:42,590
then it expresses
an interest

1379
00:50:42,590 --> 00:50:43,985
from the application side,

1380
00:50:43,985 --> 00:50:47,735
and then it moved to
our sV2Pc Forwarder,

1381
00:50:47,735 --> 00:50:48,950
which actually based

1382
00:50:48,950 --> 00:50:51,290
on some suppression logic.

1383
00:50:51,290 --> 00:50:52,670
Besides like whether to

1384
00:50:52,670 --> 00:50:55,310
actually foward the
interest or not.

1385
00:50:55,310 --> 00:50:57,290
This is our
design approach

1386
00:50:57,290 --> 00:50:59,105
from the producers
perspective,

1387
00:50:59,105 --> 00:51:01,190
like when a node
receive the interest it

1388
00:51:01,190 --> 00:51:02,480
first check whether it

1389
00:51:02,480 --> 00:51:04,400
is relevant to him or not.

1390
00:51:04,400 --> 00:51:06,035
That means if it is

1391
00:51:06,035 --> 00:51:07,520
close proximity to

1392
00:51:07,520 --> 00:51:09,440
the target
location or not,

1393
00:51:09,440 --> 00:51:11,900
and if yes, then
it publishes

1394
00:51:11,900 --> 00:51:14,090
the data from the
application site,

1395
00:51:14,090 --> 00:51:17,735
which later moves to
that sV2Pc Forwarder.

1396
00:51:17,735 --> 00:51:19,760
That actually
decides whether

1397
00:51:19,760 --> 00:51:22,410
to forward that
data or not.

1398
00:51:22,600 --> 00:51:25,550
How interests suppression
works and before

1399
00:51:25,550 --> 00:51:27,860
describing that loop back

1400
00:51:27,860 --> 00:51:29,360
at what suppression is.

1401
00:51:29,360 --> 00:51:30,740
These two cars will

1402
00:51:30,740 --> 00:51:32,345
try to send the
same interest

1403
00:51:32,345 --> 00:51:33,530
and so one of

1404
00:51:33,530 --> 00:51:36,185
their interest will
be suppressed.

1405
00:51:36,185 --> 00:51:38,045
The question is now as

1406
00:51:38,045 --> 00:51:40,160
our system is
completely distributed,

1407
00:51:40,160 --> 00:51:41,405
one car might not know

1408
00:51:41,405 --> 00:51:43,130
whether other car has

1409
00:51:43,130 --> 00:51:44,795
send the same
interest or not.

1410
00:51:44,795 --> 00:51:46,565
To solve this issue,

1411
00:51:46,565 --> 00:51:48,425
before transmitting
a new interest,

1412
00:51:48,425 --> 00:51:50,015
you know to first check

1413
00:51:50,015 --> 00:51:52,835
if it receives the
same interests before.

1414
00:51:52,835 --> 00:51:54,875
If yes, that means someone

1415
00:51:54,875 --> 00:51:57,200
else has already sent
the same interest,

1416
00:51:57,200 --> 00:51:59,840
and then it can discard
the new transmission.

1417
00:51:59,840 --> 00:52:02,525
But if all the car

1418
00:52:02,525 --> 00:52:04,400
send the interest
at the same time,

1419
00:52:04,400 --> 00:52:06,635
say at the beginning
of each second,

1420
00:52:06,635 --> 00:52:08,090
then one would not hear

1421
00:52:08,090 --> 00:52:09,380
like what others across

1422
00:52:09,380 --> 00:52:10,145
meeting and

1423
00:52:10,145 --> 00:52:12,620
no-interest population
would happen.

1424
00:52:12,620 --> 00:52:16,040
We have added a random
delay to the cars to

1425
00:52:16,040 --> 00:52:17,990
transmit so that
the cars who

1426
00:52:17,990 --> 00:52:20,225
are scheduled
transmit later,

1427
00:52:20,225 --> 00:52:21,620
they can get a
chance about

1428
00:52:21,620 --> 00:52:23,405
what other cars
are transmitting,

1429
00:52:23,405 --> 00:52:27,210
and interests
suppression can happen.

1430
00:52:27,580 --> 00:52:30,140
I think we have this slide

1431
00:52:30,140 --> 00:52:31,835
before content of these,

1432
00:52:31,835 --> 00:52:33,590
because to be the
same interests

1433
00:52:33,590 --> 00:52:34,655
the name should be same,

1434
00:52:34,655 --> 00:52:37,550
and we have three
components here.

1435
00:52:37,550 --> 00:52:39,290
The application name
is always same.

1436
00:52:39,290 --> 00:52:41,270
We need to make

1437
00:52:41,270 --> 00:52:42,725
this target location at

1438
00:52:42,725 --> 00:52:44,165
time a bit coarse because

1439
00:52:44,165 --> 00:52:46,580
if they're too much
granular then it

1440
00:52:46,580 --> 00:52:47,690
would be a rare case that

1441
00:52:47,690 --> 00:52:49,190
two interest name
would be seen,

1442
00:52:49,190 --> 00:52:51,680
and we can see no
interest suppression.

1443
00:52:51,680 --> 00:52:54,320
We have made this
location portion

1444
00:52:54,320 --> 00:52:56,910
and the time a
big granular.

1445
00:52:57,040 --> 00:53:00,185
Let's assume this
blue mark car

1446
00:53:00,185 --> 00:53:01,685
wants to know how about

1447
00:53:01,685 --> 00:53:03,965
blue region and this
orange mark car

1448
00:53:03,965 --> 00:53:05,990
wants to know about
the orange region.

1449
00:53:05,990 --> 00:53:09,815
Now as the target
location varies here,

1450
00:53:09,815 --> 00:53:12,215
their interest name
would not be seen.

1451
00:53:12,215 --> 00:53:14,345
Instead, if both of

1452
00:53:14,345 --> 00:53:17,090
them wants to know about
the yellow region,

1453
00:53:17,090 --> 00:53:19,265
which is the combined
of both their resumes,

1454
00:53:19,265 --> 00:53:20,795
then their target portion

1455
00:53:20,795 --> 00:53:22,625
of the interest
name will be same.

1456
00:53:22,625 --> 00:53:26,120
In similar way, blue mark

1457
00:53:26,120 --> 00:53:30,920
car send the interest
in 25.02 seconds.

1458
00:53:30,920 --> 00:53:32,075
As we mentioned that we

1459
00:53:32,075 --> 00:53:33,785
have introduced
a random delay,

1460
00:53:33,785 --> 00:53:36,980
and see these
orange mark car

1461
00:53:36,980 --> 00:53:40,040
send the interest
at 25.07 seconds.

1462
00:53:40,040 --> 00:53:43,280
In the name instead
of 25.02 or

1463
00:53:43,280 --> 00:53:47,090
25.07 if we
mentioned like 25,

1464
00:53:47,090 --> 00:53:49,940
just only, then
the time component

1465
00:53:49,940 --> 00:53:52,610
will also be seen
for disinterest.

1466
00:53:52,610 --> 00:53:55,025
That will make this
two interest same,

1467
00:53:55,025 --> 00:53:56,450
which actually
paves the way

1468
00:53:56,450 --> 00:53:58,830
for interest
suppression to happen.

1469
00:53:58,990 --> 00:54:01,730
Data suppression
also works in

1470
00:54:01,730 --> 00:54:03,650
the same way as
interests suppression,

1471
00:54:03,650 --> 00:54:05,780
so before sending
data packet,

1472
00:54:05,780 --> 00:54:07,700
a node checks like
if it receives

1473
00:54:07,700 --> 00:54:08,930
any data packet at

1474
00:54:08,930 --> 00:54:11,540
the same interest
name or before.

1475
00:54:11,540 --> 00:54:14,225
Again, like if all
the pedestrian

1476
00:54:14,225 --> 00:54:15,320
from a group of

1477
00:54:15,320 --> 00:54:17,630
closely located
people replies

1478
00:54:17,630 --> 00:54:20,000
immediately after
receiving an interest,

1479
00:54:20,000 --> 00:54:22,055
then no separation
will ever happen.

1480
00:54:22,055 --> 00:54:23,150
We can think of like

1481
00:54:23,150 --> 00:54:24,920
any closely located area.

1482
00:54:24,920 --> 00:54:26,120
There are a number of

1483
00:54:26,120 --> 00:54:28,115
people and all
of them receive

1484
00:54:28,115 --> 00:54:30,170
interest at the same time

1485
00:54:30,170 --> 00:54:31,985
and immediately reply.

1486
00:54:31,985 --> 00:54:35,060
Lower node will here

1487
00:54:35,060 --> 00:54:36,725
like what others
are transmitting.

1488
00:54:36,725 --> 00:54:38,000
In this case like no

1489
00:54:38,000 --> 00:54:39,770
data separation
will happen.

1490
00:54:39,770 --> 00:54:41,390
We have also added

1491
00:54:41,390 --> 00:54:44,365
random delay that
actually ensure that

1492
00:54:44,365 --> 00:54:46,030
other pedestrian who are

1493
00:54:46,030 --> 00:54:48,070
transmitting a bit
later position can

1494
00:54:48,070 --> 00:54:49,720
have the chance to hear

1495
00:54:49,720 --> 00:54:51,805
what others are saying,

1496
00:54:51,805 --> 00:54:53,950
and this will help

1497
00:54:53,950 --> 00:54:56,600
us to make data
suppression work.

1498
00:54:57,400 --> 00:55:01,085
We have evaluated
our application

1499
00:55:01,085 --> 00:55:04,475
by comparing our
application with PSM,

1500
00:55:04,475 --> 00:55:05,990
which is also a
pedestrian safety

1501
00:55:05,990 --> 00:55:07,520
application as baseline,

1502
00:55:07,520 --> 00:55:08,930
and we have compared

1503
00:55:08,930 --> 00:55:11,195
the bandwidth to total
number of packets,

1504
00:55:11,195 --> 00:55:13,160
and we have done
the evaluation

1505
00:55:13,160 --> 00:55:15,230
for the device scenario

1506
00:55:15,230 --> 00:55:16,580
like different
pedestrian count,

1507
00:55:16,580 --> 00:55:18,260
different that
vehicle density and

1508
00:55:18,260 --> 00:55:20,885
for both single and
multiple hops scenario.

1509
00:55:20,885 --> 00:55:23,195
As evaluation
tool, we have

1510
00:55:23,195 --> 00:55:25,950
used the Indian
Sim and Sumo.

1511
00:55:28,180 --> 00:55:30,845
This is the
resulting graph

1512
00:55:30,845 --> 00:55:33,470
describing a single
hub scenario.

1513
00:55:33,470 --> 00:55:36,305
In the x-axis, we have

1514
00:55:36,305 --> 00:55:38,675
the number of pedestrians,

1515
00:55:38,675 --> 00:55:41,810
and growing
exponentially from 40,

1516
00:55:41,810 --> 00:55:44,735
80, 160, 320 to 640.

1517
00:55:44,735 --> 00:55:46,730
In the y-axis we

1518
00:55:46,730 --> 00:55:49,295
have the number of total
transmitted packet.

1519
00:55:49,295 --> 00:55:52,670
We have around
10 simulations

1520
00:55:52,670 --> 00:55:55,685
and then take the
mean value for that.

1521
00:55:55,685 --> 00:55:57,650
We also tried to

1522
00:55:57,650 --> 00:55:59,975
simulate different
densities of car,

1523
00:55:59,975 --> 00:56:02,599
like low, medium
and high densities.

1524
00:56:02,599 --> 00:56:04,835
Besides for the
comparison,

1525
00:56:04,835 --> 00:56:06,965
we also created
a scenario that

1526
00:56:06,965 --> 00:56:09,650
mimic WSM as
baseline scenario.

1527
00:56:09,650 --> 00:56:12,830
From that scenario
we actually round

1528
00:56:12,830 --> 00:56:14,420
with all the
same parameters

1529
00:56:14,420 --> 00:56:16,325
that our Indian one like.

1530
00:56:16,325 --> 00:56:18,050
We have calculated

1531
00:56:18,050 --> 00:56:19,685
the total
transmitted amout

1532
00:56:19,685 --> 00:56:21,110
which we have denoted as

1533
00:56:21,110 --> 00:56:23,180
baseline in that
yellow color.

1534
00:56:23,180 --> 00:56:26,675
We can see that for a
single hop scenario,

1535
00:56:26,675 --> 00:56:28,340
in all cases,

1536
00:56:28,340 --> 00:56:31,340
our approach like
outperforms PSM.

1537
00:56:31,340 --> 00:56:34,430
While PSM has an
exponential growth,

1538
00:56:34,430 --> 00:56:36,140
I mean it's
like the 40-80,

1539
00:56:36,140 --> 00:56:37,400
it has an
exponential growth

1540
00:56:37,400 --> 00:56:39,410
with the number of
pedestrian counts.

1541
00:56:39,410 --> 00:56:41,885
But our approach has

1542
00:56:41,885 --> 00:56:44,610
almost a constant result.

1543
00:56:45,970 --> 00:56:48,140
Now in this slide,

1544
00:56:48,140 --> 00:56:50,060
we have actually
tried to compare

1545
00:56:50,060 --> 00:56:52,280
the results in a
multiple hops scenario.

1546
00:56:52,280 --> 00:56:53,390
But for your information,

1547
00:56:53,390 --> 00:56:54,920
this is not an apple to

1548
00:56:54,920 --> 00:56:57,365
apple comparison
because in PSM,

1549
00:56:57,365 --> 00:56:59,750
our packet can
travel only one hop.

1550
00:56:59,750 --> 00:57:01,880
Whereas in our
Indian approach,

1551
00:57:01,880 --> 00:57:02,900
a packet can transmit

1552
00:57:02,900 --> 00:57:04,430
it through multiple hops.

1553
00:57:04,430 --> 00:57:07,310
This actually is
very much helpful

1554
00:57:07,310 --> 00:57:10,460
because a car can learn

1555
00:57:10,460 --> 00:57:11,510
about the presence of

1556
00:57:11,510 --> 00:57:13,640
any obstacles from
a longer distance

1557
00:57:13,640 --> 00:57:15,140
and can decide his action

1558
00:57:15,140 --> 00:57:17,615
accordingly within
a longer time.

1559
00:57:17,615 --> 00:57:19,700
Although this is an apple

1560
00:57:19,700 --> 00:57:21,335
to an orange comparison,

1561
00:57:21,335 --> 00:57:23,690
but still we can see
that when the number of

1562
00:57:23,690 --> 00:57:26,075
pedestrians are a bit
high, for example,

1563
00:57:26,075 --> 00:57:27,785
in a crowded intersection,

1564
00:57:27,785 --> 00:57:31,580
so our approach can still
outperform the PSM.

1565
00:57:31,580 --> 00:57:34,550
We have tried to
break the bars in

1566
00:57:34,550 --> 00:57:35,960
accordance with
the distance of

1567
00:57:35,960 --> 00:57:38,045
the consumers and
the intersection,

1568
00:57:38,045 --> 00:57:42,155
to compare in a
more similar way.

1569
00:57:42,155 --> 00:57:44,645
>> Proyash you
got two minutes.

1570
00:57:44,645 --> 00:57:46,910
>> Yeah, this is the
last slide actually.

1571
00:57:46,910 --> 00:57:52,250
[LAUGHTER] We also
identified actually

1572
00:57:52,250 --> 00:57:54,710
a large corpus of
future work to

1573
00:57:54,710 --> 00:57:56,960
[inaudible] improve
the scalability

1574
00:57:56,960 --> 00:57:59,134
of vehicle to pedestrian
communication.

1575
00:57:59,134 --> 00:58:00,890
The first one is,

1576
00:58:00,890 --> 00:58:04,040
we have considered
the applicability of

1577
00:58:04,040 --> 00:58:06,485
very general Indian
security mechanisms

1578
00:58:06,485 --> 00:58:08,075
in our use case
application.

1579
00:58:08,075 --> 00:58:09,530
But eventually,

1580
00:58:09,530 --> 00:58:12,710
if we want to make it
a more robust work,

1581
00:58:12,710 --> 00:58:14,060
then we need to

1582
00:58:14,060 --> 00:58:16,595
ensure a proper
security mechanism.

1583
00:58:16,595 --> 00:58:18,170
For example, we need to

1584
00:58:18,170 --> 00:58:20,030
define a trust schema.

1585
00:58:20,030 --> 00:58:22,340
We need to think of
how to distribute

1586
00:58:22,340 --> 00:58:22,790
keys in

1587
00:58:22,790 --> 00:58:25,340
a vehicle environment
and other stuff.

1588
00:58:25,340 --> 00:58:28,985
Secondly, it is evident
that we only show

1589
00:58:28,985 --> 00:58:30,890
one use-case
application that

1590
00:58:30,890 --> 00:58:33,080
leverages the benefits
of this sV2Pc.

1591
00:58:33,080 --> 00:58:35,105
However, we need to

1592
00:58:35,105 --> 00:58:37,295
explore similar
applications

1593
00:58:37,295 --> 00:58:39,680
where we can give
some benefits from

1594
00:58:39,680 --> 00:58:42,155
the interest name
repeatability,

1595
00:58:42,155 --> 00:58:44,000
and geo bound can

1596
00:58:44,000 --> 00:58:45,830
be helpful while
forwarding,

1597
00:58:45,830 --> 00:58:48,650
and in those application
we can also use

1598
00:58:48,650 --> 00:58:51,995
the sV2Pc, and it's good.

1599
00:58:51,995 --> 00:58:56,090
Finally, for the
current state of sV2Pc,

1600
00:58:56,090 --> 00:58:58,130
we think of a completely

1601
00:58:58,130 --> 00:58:59,735
distributed mechanism.

1602
00:58:59,735 --> 00:59:01,385
However, we can use

1603
00:59:01,385 --> 00:59:05,090
some centralized
knowledge that

1604
00:59:05,090 --> 00:59:06,634
may be from the ISCU

1605
00:59:06,634 --> 00:59:08,255
of an intersection or so,

1606
00:59:08,255 --> 00:59:09,860
that might be helpful to

1607
00:59:09,860 --> 00:59:12,560
improve the suppression
logic a lot more.

1608
00:59:12,560 --> 00:59:16,140
Well, thank you very
much for listening.

1609
00:59:18,260 --> 00:59:19,260
[inaudible].

1610
00:59:19,260 --> 00:59:21,414
>> Thank you. Go ahead
and stop sharing.

1611
00:59:21,414 --> 00:59:23,195
Always happy to see you.

1612
00:59:23,195 --> 00:59:25,510
Automotive
applications of India.

1613
00:59:25,510 --> 00:59:29,980
Our next presentation
will be by Ashiq,

1614
00:59:29,980 --> 00:59:32,500
who is a computer
science PhD student

1615
00:59:32,500 --> 00:59:33,920
at the University
of Arizona.

1616
00:59:33,920 --> 00:59:35,680
His research
interests involve

1617
00:59:35,680 --> 00:59:37,510
future Internet
architectures

1618
00:59:37,510 --> 00:59:39,455
and wireless
communication.

1619
00:59:39,455 --> 00:59:41,180
He's currently working on

1620
00:59:41,180 --> 00:59:43,260
datacentric wireless
networking from

1621
00:59:43,260 --> 00:59:46,045
the link layer to the
application layer.

1622
00:59:46,045 --> 00:59:48,500
Ashiq, go ahead.

1623
00:59:48,500 --> 00:59:50,345
>> I believe video, audio,

1624
00:59:50,345 --> 00:59:51,670
and slides are okay.

1625
00:59:51,670 --> 00:59:53,930
>> Yes. You're good.

1626
00:59:53,930 --> 00:59:57,280
>> Thank you.
[NOISE] Today

1627
00:59:57,280 --> 00:59:59,190
I'll be talking
about BLEnD

1628
00:59:59,190 --> 01:00:01,150
: Improving NDN
performance over

1629
01:00:01,150 --> 01:00:04,370
wireless links using
interest bundling.

1630
01:00:04,370 --> 01:00:07,880
I'm Ashiq from the
University of Arizona.

1631
01:00:09,660 --> 01:00:12,640
Everyone's saying
that wireless devices

1632
01:00:12,640 --> 01:00:15,890
are practically taking
over everything.

1633
01:00:15,890 --> 01:00:19,760
Just a few quick
examples, AR VR,

1634
01:00:19,760 --> 01:00:21,645
even in military networks,

1635
01:00:21,645 --> 01:00:23,800
I hit the satellite
links a little bit,

1636
01:00:23,800 --> 01:00:25,775
but it's also there.

1637
01:00:25,775 --> 01:00:27,310
Then we have IoTs and

1638
01:00:27,310 --> 01:00:29,105
of course, Edge computing.

1639
01:00:29,105 --> 01:00:32,075
Everywhere wireless
networking is

1640
01:00:32,075 --> 01:00:34,075
becoming the
part and parcel.

1641
01:00:34,075 --> 01:00:37,270
However, they also expect

1642
01:00:37,270 --> 01:00:39,280
high throughput
and reliability.

1643
01:00:39,280 --> 01:00:41,125
But in reality,

1644
01:00:41,125 --> 01:00:42,965
when we talk about
wireless communication,

1645
01:00:42,965 --> 01:00:44,200
we can see that when we

1646
01:00:44,200 --> 01:00:46,034
talk about a
particular channel,

1647
01:00:46,034 --> 01:00:49,885
it's half-duplex, either
sends or receives.

1648
01:00:49,885 --> 01:00:52,450
We also have channel
access contention.

1649
01:00:52,450 --> 01:00:55,630
That is, a pretty
cool ascender

1650
01:00:55,630 --> 01:00:58,655
would pause until the
channel is available.

1651
01:00:58,655 --> 01:01:01,270
Then of course, we also
have other challenges

1652
01:01:01,270 --> 01:01:04,510
such as collision and
of course congestion.

1653
01:01:04,510 --> 01:01:06,330
When we talk about data is

1654
01:01:06,330 --> 01:01:08,099
changing in
wireless medium,

1655
01:01:08,099 --> 01:01:09,700
[NOISE] we come
to talk about

1656
01:01:09,700 --> 01:01:10,865
the congestion control and

1657
01:01:10,865 --> 01:01:12,995
loss recovery a lot.

1658
01:01:12,995 --> 01:01:16,350
To balance this,
what happens is that

1659
01:01:16,350 --> 01:01:18,210
there is an
exchange between

1660
01:01:18,210 --> 01:01:20,610
signals for data packets.

1661
01:01:20,610 --> 01:01:23,135
What are the
signal packets?

1662
01:01:23,135 --> 01:01:25,690
In TCP/IP we know them
as acknowledgments,

1663
01:01:25,690 --> 01:01:26,860
and in NDN,

1664
01:01:26,860 --> 01:01:27,880
we can consider

1665
01:01:27,880 --> 01:01:29,865
the interests packets
as the signals.

1666
01:01:29,865 --> 01:01:32,560
We have the signal
and data packets.

1667
01:01:32,560 --> 01:01:33,845
Let's say that we have

1668
01:01:33,845 --> 01:01:37,340
this theoretical
channel capacity.

1669
01:01:37,340 --> 01:01:39,790
There is a signal packet,

1670
01:01:39,790 --> 01:01:41,900
and with respect to that,

1671
01:01:41,900 --> 01:01:43,430
some data packet comes in.

1672
01:01:43,430 --> 01:01:44,860
However, we can
see that there's

1673
01:01:44,860 --> 01:01:47,455
a small gap between
the signal and data.

1674
01:01:47,455 --> 01:01:49,810
Inter-frame
spacing, link-layer

1675
01:01:49,810 --> 01:01:51,520
acknowledgment, RTS/CTS,

1676
01:01:51,520 --> 01:01:53,305
and channel excess delay.

1677
01:01:53,305 --> 01:01:56,720
This takes place in
between the two packets.

1678
01:01:56,720 --> 01:01:58,945
When we consider

1679
01:01:58,945 --> 01:02:02,710
multiple signal
and data packets,

1680
01:02:02,710 --> 01:02:04,045
what happens is that

1681
01:02:04,045 --> 01:02:05,500
when we combine
the data packets,

1682
01:02:05,500 --> 01:02:07,745
we can see the
effective bandwidth is

1683
01:02:07,745 --> 01:02:09,145
actually much lower

1684
01:02:09,145 --> 01:02:11,300
than the channel capacity.

1685
01:02:11,850 --> 01:02:15,275
Then we ask the question
is that how can we

1686
01:02:15,275 --> 01:02:18,665
increase the channel
access for data?

1687
01:02:18,665 --> 01:02:22,460
The basic idea is to
reduce signal frequency.

1688
01:02:22,460 --> 01:02:24,880
It asks for a trade-off

1689
01:02:24,880 --> 01:02:27,155
between the amount
of signals that we

1690
01:02:27,155 --> 01:02:30,365
provide to the network
or the amount of

1691
01:02:30,365 --> 01:02:32,045
channel that
we access that

1692
01:02:32,045 --> 01:02:34,105
we want to increase
for the data packets.

1693
01:02:34,105 --> 01:02:37,445
In TCP/IP, the
basic idea is

1694
01:02:37,445 --> 01:02:39,219
to have one acknowledgment

1695
01:02:39,219 --> 01:02:41,300
for multiple data packets.

1696
01:02:41,300 --> 01:02:44,350
In the end, what we
can do is that we can

1697
01:02:44,350 --> 01:02:46,105
use one interest packet

1698
01:02:46,105 --> 01:02:47,835
to fetch multiple
data packets.

1699
01:02:47,835 --> 01:02:50,335
Again, we have the
signal and data.

1700
01:02:50,335 --> 01:02:52,855
Then again, we have
the channel capacity.

1701
01:02:52,855 --> 01:02:55,910
We have our old
effective bandwidth.

1702
01:02:55,910 --> 01:02:57,990
In this particular
example,

1703
01:02:57,990 --> 01:02:59,245
we have one single packet

1704
01:02:59,245 --> 01:03:01,795
that touches multiple
data packets.

1705
01:03:01,795 --> 01:03:03,605
If we sum them
up together,

1706
01:03:03,605 --> 01:03:05,765
we can see that the new
effective bandwidth

1707
01:03:05,765 --> 01:03:08,075
is much more than
the old one.

1708
01:03:08,075 --> 01:03:09,805
This is an interesting.

1709
01:03:09,805 --> 01:03:13,495
We can also already see
that it can be done.

1710
01:03:13,495 --> 01:03:16,400
Let's try to put
it into test

1711
01:03:16,400 --> 01:03:17,315
and see what can be

1712
01:03:17,315 --> 01:03:19,400
done or what can
be achieved.

1713
01:03:19,400 --> 01:03:20,950
We see that interest

1714
01:03:20,950 --> 01:03:23,245
bundling improves
throughput.

1715
01:03:23,245 --> 01:03:25,750
We tested it on
single-hop Wi-Fi

1716
01:03:25,750 --> 01:03:26,920
in infrastructure mode,

1717
01:03:26,920 --> 01:03:29,845
just an access point
as a producer and

1718
01:03:29,845 --> 01:03:32,245
a consumer that sends

1719
01:03:32,245 --> 01:03:35,945
a single interest to
fetch continuous data.

1720
01:03:35,945 --> 01:03:39,155
What we see here is
that when there is

1721
01:03:39,155 --> 01:03:41,895
no bundling going on

1722
01:03:41,895 --> 01:03:44,110
or it's only one interest,

1723
01:03:44,110 --> 01:03:46,025
one data communication,

1724
01:03:46,025 --> 01:03:48,550
effective bandwidth
extremely low

1725
01:03:48,550 --> 01:03:50,570
compared to what we have.

1726
01:03:50,570 --> 01:03:52,510
If we send only
one interest

1727
01:03:52,510 --> 01:03:54,310
to fetch continuous data,

1728
01:03:54,310 --> 01:03:56,800
we can see that
goodput can be

1729
01:03:56,800 --> 01:03:59,075
improved almost
like 60 percent

1730
01:03:59,075 --> 01:04:02,330
or even up to more
than 90 percent

1731
01:04:02,330 --> 01:04:05,010
in simulated environments.

1732
01:04:05,010 --> 01:04:08,055
Next question we
want to ask is that

1733
01:04:08,055 --> 01:04:11,420
where do we bundle
or unbundle?

1734
01:04:11,420 --> 01:04:15,040
By where I mean in the
network stack itself.

1735
01:04:15,530 --> 01:04:17,740
The reason I'm presenting

1736
01:04:17,740 --> 01:04:20,290
a reverse triangle
is to present

1737
01:04:20,290 --> 01:04:21,820
the amount of
difficulty from

1738
01:04:21,820 --> 01:04:25,790
top in terms of the
size of the area.

1739
01:04:25,790 --> 01:04:28,060
If we consider bundling

1740
01:04:28,060 --> 01:04:29,110
at the application layer,

1741
01:04:29,110 --> 01:04:32,170
what happens is
that we end up in

1742
01:04:32,170 --> 01:04:35,170
an end-to-end
communication and it ends

1743
01:04:35,170 --> 01:04:39,035
up breaking everything
at the lower layers.

1744
01:04:39,035 --> 01:04:42,280
If we tried to do it at
the transport, again,

1745
01:04:42,280 --> 01:04:44,200
it's tightly coupled with

1746
01:04:44,200 --> 01:04:45,365
the application is still

1747
01:04:45,365 --> 01:04:46,670
almost end-to-an end,

1748
01:04:46,670 --> 01:04:48,310
breaks the
forwarding part.

1749
01:04:48,310 --> 01:04:50,860
If we tried to do it
at the network layer,

1750
01:04:50,860 --> 01:04:53,810
it requires
complex changes

1751
01:04:53,810 --> 01:04:56,740
to this stateful
forwarding.

1752
01:04:56,740 --> 01:04:59,490
The safest part
that we could

1753
01:04:59,490 --> 01:05:01,950
find is the link
layer that would need

1754
01:05:01,950 --> 01:05:04,455
the least number of
changes and would

1755
01:05:04,455 --> 01:05:07,185
also be able to hide
all the bundling,

1756
01:05:07,185 --> 01:05:10,285
unbundling operations
from the upper layer.

1757
01:05:10,285 --> 01:05:12,640
That would be
really helpful.

1758
01:05:12,640 --> 01:05:15,295
That's where the
high level idea

1759
01:05:15,295 --> 01:05:17,405
of this work comes
into play that

1760
01:05:17,405 --> 01:05:19,620
is blanked like
bundling interests

1761
01:05:19,620 --> 01:05:22,820
with link layer
encoding and decoding.

1762
01:05:22,910 --> 01:05:25,310
At the higher level idea,

1763
01:05:25,310 --> 01:05:27,305
what happens here
is that we consider

1764
01:05:27,305 --> 01:05:28,960
only a single hub for

1765
01:05:28,960 --> 01:05:31,320
this part because it's
at the link level.

1766
01:05:31,320 --> 01:05:34,120
At the sender, the
forwarding steps

1767
01:05:34,120 --> 01:05:36,384
takes place as usual.

1768
01:05:36,384 --> 01:05:38,615
Let's say we have multiple
interest packets.

1769
01:05:38,615 --> 01:05:40,285
The link would bundle

1770
01:05:40,285 --> 01:05:42,110
those interest
packets into one,

1771
01:05:42,110 --> 01:05:43,935
send over the
wireless channel,

1772
01:05:43,935 --> 01:05:45,350
and at the receiver side,

1773
01:05:45,350 --> 01:05:46,480
the link receives it,

1774
01:05:46,480 --> 01:05:48,770
unbundles into multiple
interest packets,

1775
01:05:48,770 --> 01:05:50,875
and it goes to
the forwarder.

1776
01:05:50,875 --> 01:05:53,465
Caching aggregation,
routing, everything is

1777
01:05:53,465 --> 01:05:57,830
practically unaffected.
This is good.

1778
01:05:59,780 --> 01:06:02,290
Let's look at a little bit

1779
01:06:02,290 --> 01:06:04,730
deeper at the technical
aspects of it.

1780
01:06:04,730 --> 01:06:06,925
We have two
parts in BLEnD,

1781
01:06:06,925 --> 01:06:08,350
sender-side encoding and

1782
01:06:08,350 --> 01:06:09,805
receiver-side decoding.

1783
01:06:09,805 --> 01:06:11,885
When we talk about the
sender-side encoding

1784
01:06:11,885 --> 01:06:14,165
is actually has two parts.

1785
01:06:14,165 --> 01:06:16,000
Like a cross layer design

1786
01:06:16,000 --> 01:06:17,740
between the transport
and the link layer.

1787
01:06:17,740 --> 01:06:20,260
It starts at the
transport scheduler

1788
01:06:20,260 --> 01:06:22,520
where an interest packet,

1789
01:06:22,520 --> 01:06:25,690
we assume it
contains name,

1790
01:06:25,690 --> 01:06:27,220
and also sequence number,

1791
01:06:27,220 --> 01:06:28,955
and also the nonce.

1792
01:06:28,955 --> 01:06:30,400
The transport
scheduler what

1793
01:06:30,400 --> 01:06:31,345
it does is that,

1794
01:06:31,345 --> 01:06:35,675
it adds an LP tag to
the interest packet,

1795
01:06:35,675 --> 01:06:38,900
and marks if it's a
retransmission or not,

1796
01:06:38,900 --> 01:06:41,455
and also the current
congestion window.

1797
01:06:41,455 --> 01:06:45,475
The bTAG is practically
a 64-bit LP tag.

1798
01:06:45,475 --> 01:06:48,645
The first field marks

1799
01:06:48,645 --> 01:06:50,590
if it's a
retransmission or not.

1800
01:06:50,590 --> 01:06:51,720
The second field

1801
01:06:51,720 --> 01:06:53,545
contains the
congestion window.

1802
01:06:53,545 --> 01:06:55,360
Then this packet carries

1803
01:06:55,360 --> 01:06:58,930
over through the NFD.

1804
01:06:58,930 --> 01:07:01,630
NFD, all the
states pit FAPE,

1805
01:07:01,630 --> 01:07:02,710
everything is based on

1806
01:07:02,710 --> 01:07:05,170
the main sequence
and also nonce,

1807
01:07:05,170 --> 01:07:07,190
so everything is
pretty much unchanged.

1808
01:07:07,190 --> 01:07:09,085
At the link layer,

1809
01:07:09,085 --> 01:07:10,825
magic starts to happen.

1810
01:07:10,825 --> 01:07:12,310
Sorry for saying magic,

1811
01:07:12,310 --> 01:07:13,630
but what has happened is

1812
01:07:13,630 --> 01:07:16,400
that the link layer
first checks if

1813
01:07:16,400 --> 01:07:18,775
it's a retransmission
or not

1814
01:07:18,775 --> 01:07:22,050
based on the bundle
tag or bTAG.

1815
01:07:22,050 --> 01:07:24,020
If it is, then

1816
01:07:24,020 --> 01:07:26,260
what it does is
that locally it

1817
01:07:26,260 --> 01:07:27,730
calculates a start and

1818
01:07:27,730 --> 01:07:29,530
ending sequence
and it sets to

1819
01:07:29,530 --> 01:07:31,435
the sequence number
that it already

1820
01:07:31,435 --> 01:07:33,855
cedes from the
interest packet.

1821
01:07:33,855 --> 01:07:36,790
If it's not, then
it checks if

1822
01:07:36,790 --> 01:07:38,665
a sequence is sent

1823
01:07:38,665 --> 01:07:40,475
in a previous
bundle already.

1824
01:07:40,475 --> 01:07:42,580
If it's yes, then it
will just drop it

1825
01:07:42,580 --> 01:07:45,215
because it's already
sent it out in a bundle.

1826
01:07:45,215 --> 01:07:47,310
If not, then it

1827
01:07:47,310 --> 01:07:49,210
calculates the start and

1828
01:07:49,210 --> 01:07:51,755
end sequence based on,

1829
01:07:51,755 --> 01:07:53,525
of course, the
sequence number of

1830
01:07:53,525 --> 01:07:55,130
the current interest and

1831
01:07:55,130 --> 01:07:58,060
some sequence
in the future.

1832
01:08:00,390 --> 01:08:02,500
It would be the minimum of

1833
01:08:02,500 --> 01:08:03,590
the congestion window

1834
01:08:03,590 --> 01:08:06,655
or some constant
bundle interval.

1835
01:08:06,655 --> 01:08:08,890
Yes, practically is

1836
01:08:08,890 --> 01:08:10,150
the end sequence which

1837
01:08:10,150 --> 01:08:12,590
points to future
sequence numbers.

1838
01:08:12,590 --> 01:08:15,065
Then the link layer
would make a bundle.

1839
01:08:15,065 --> 01:08:17,560
Where it would remove

1840
01:08:17,560 --> 01:08:18,550
the sequence number from

1841
01:08:18,550 --> 01:08:21,940
the main part
and re-encode

1842
01:08:21,940 --> 01:08:24,910
the start and end
sequence on the bTAG.

1843
01:08:24,910 --> 01:08:26,805
We can see that the bTAG

1844
01:08:26,805 --> 01:08:28,515
carries the start
and end sequence.

1845
01:08:28,515 --> 01:08:30,650
It's practically a range.

1846
01:08:30,650 --> 01:08:35,890
When it goes,
so again, bTAG,

1847
01:08:35,890 --> 01:08:37,960
it updates the updates

1848
01:08:37,960 --> 01:08:40,160
with the start
and end sequence,

1849
01:08:40,160 --> 01:08:42,055
and then we move to

1850
01:08:42,055 --> 01:08:45,220
the receiver side decoding

1851
01:08:45,220 --> 01:08:47,165
when the receiver
side receives it.

1852
01:08:47,165 --> 01:08:48,910
The receiver side decoding

1853
01:08:48,910 --> 01:08:51,220
is purely on
the link layer.

1854
01:08:51,220 --> 01:08:53,590
Interest comes
in. It checks

1855
01:08:53,590 --> 01:08:55,570
if it has a bundle
tag or not.

1856
01:08:55,570 --> 01:08:57,980
If no, directly send
it to the forwarder.

1857
01:08:57,980 --> 01:09:00,280
If yes, it looks at

1858
01:09:00,280 --> 01:09:02,450
the start and end
sequence are equal,

1859
01:09:02,450 --> 01:09:06,600
practically indicating
a retransmission.

1860
01:09:06,600 --> 01:09:10,145
What happens here
is that if yes,

1861
01:09:10,145 --> 01:09:12,070
then it would
have a decode,

1862
01:09:12,070 --> 01:09:13,570
start sequence and decode

1863
01:09:13,570 --> 01:09:16,790
end sequence that assigns

1864
01:09:16,790 --> 01:09:18,485
to the start sequence,

1865
01:09:18,485 --> 01:09:19,870
if it's a retransmission.

1866
01:09:19,870 --> 01:09:22,225
Otherwise, it looks at

1867
01:09:22,225 --> 01:09:25,460
if an end sequence has
been previously seen.

1868
01:09:25,460 --> 01:09:27,050
What it means is that,

1869
01:09:27,050 --> 01:09:30,700
this bundle has
already been received

1870
01:09:30,700 --> 01:09:35,170
and unbundled so we
can ignore it safely.

1871
01:09:35,170 --> 01:09:38,120
That's what it
does, drops it.

1872
01:09:38,120 --> 01:09:40,090
If it's a new
end sequence,

1873
01:09:40,090 --> 01:09:41,555
what it does is that it

1874
01:09:41,555 --> 01:09:42,940
assigns the decode start

1875
01:09:42,940 --> 01:09:44,890
sequence to the previous

1876
01:09:44,890 --> 01:09:46,655
end sequence plus one.

1877
01:09:46,655 --> 01:09:48,130
We will come into

1878
01:09:48,130 --> 01:09:50,425
explanation of it a
little bit later.

1879
01:09:50,425 --> 01:09:53,975
After doing so, it
has a start sequence

1880
01:09:53,975 --> 01:09:55,530
and end sequence for

1881
01:09:55,530 --> 01:09:57,685
the decoding information.

1882
01:09:57,685 --> 01:10:00,970
Then it goes to
the next step.

1883
01:10:00,970 --> 01:10:03,280
Basically a loop, where it

1884
01:10:03,280 --> 01:10:05,500
loops over from
the decode start

1885
01:10:05,500 --> 01:10:09,265
sequence to the decode
end sequence and

1886
01:10:09,265 --> 01:10:11,405
just adds back

1887
01:10:11,405 --> 01:10:13,990
the sequence number
to the name itself.

1888
01:10:13,990 --> 01:10:16,030
We can see that we
are reconstructing

1889
01:10:16,030 --> 01:10:18,145
from a bundled interest to

1890
01:10:18,145 --> 01:10:20,795
multiple unbundled
interests and

1891
01:10:20,795 --> 01:10:23,315
forwarding them to
the upper layers.

1892
01:10:23,315 --> 01:10:25,295
The sequence and
the name part

1893
01:10:25,295 --> 01:10:28,000
is pretty much untouched.

1894
01:10:28,430 --> 01:10:31,620
After that, what
happens here,

1895
01:10:31,620 --> 01:10:33,820
I talked about that,

1896
01:10:34,160 --> 01:10:38,370
it keeps track of the
previous N-sequence,

1897
01:10:38,370 --> 01:10:40,085
so the reason has to

1898
01:10:40,085 --> 01:10:42,735
handle lost
bundle interest.

1899
01:10:42,735 --> 01:10:45,060
Let's say that we have
a bundle interval

1900
01:10:45,060 --> 01:10:46,620
of 10 at the center.

1901
01:10:46,620 --> 01:10:48,510
We have the sender, and

1902
01:10:48,510 --> 01:10:50,145
looking at the
transport and link,

1903
01:10:50,145 --> 01:10:52,490
we also have the producer
or the receiver,

1904
01:10:52,490 --> 01:10:54,100
and from left to

1905
01:10:54,100 --> 01:10:55,860
right we have the
sequence numbers.

1906
01:10:55,860 --> 01:10:57,655
Of course, the first

1907
01:10:57,655 --> 01:10:58,920
sequence number comes into

1908
01:10:58,920 --> 01:11:01,620
play depending on
the bundle interval,

1909
01:11:01,620 --> 01:11:04,125
there would be
10 data packets

1910
01:11:04,125 --> 01:11:06,570
scheduled from the
producer side,

1911
01:11:06,570 --> 01:11:08,160
and we can see
that the previous

1912
01:11:08,160 --> 01:11:09,990
N-sequence is also 10.

1913
01:11:09,990 --> 01:11:12,990
Now, all the other
interests packets from

1914
01:11:12,990 --> 01:11:14,045
the sender side would

1915
01:11:14,045 --> 01:11:16,170
be suppressed at the link,

1916
01:11:16,170 --> 01:11:19,670
and then for the next
interest packet,

1917
01:11:19,670 --> 01:11:21,465
there would be
a new bundle.

1918
01:11:21,465 --> 01:11:23,280
However, assuming that,

1919
01:11:23,280 --> 01:11:26,780
that bundled interest
was lost at the link,

1920
01:11:26,780 --> 01:11:31,470
so the receiver is
practically sitting idle,

1921
01:11:31,470 --> 01:11:33,905
and not sending out
any data packets.

1922
01:11:33,905 --> 01:11:36,750
But there should be
some recovery because

1923
01:11:36,750 --> 01:11:40,385
we're losing all the new
10 interest packets.

1924
01:11:40,385 --> 01:11:43,020
What happens is that
when the next bundle

1925
01:11:43,020 --> 01:11:45,240
comes in, the
receiver side,

1926
01:11:45,240 --> 01:11:48,310
would assign the
start sequence

1927
01:11:48,310 --> 01:11:49,890
to the previous
end sequence

1928
01:11:49,890 --> 01:11:56,130
to fill the gap of
the lost bundle,

1929
01:11:56,130 --> 01:11:58,820
so we call it receiver
side gap-filling.

1930
01:11:58,820 --> 01:12:01,475
At least it provides
some amount

1931
01:12:01,475 --> 01:12:06,070
of reliability from
the receiver side.

1932
01:12:06,980 --> 01:12:09,390
Let's take a look at

1933
01:12:09,390 --> 01:12:11,160
some simulation results on

1934
01:12:11,160 --> 01:12:14,120
goodput and also effect
of bundle interval.

1935
01:12:14,120 --> 01:12:16,985
When we talk about
goodput improvement,

1936
01:12:16,985 --> 01:12:21,120
test on a 802.11b and

1937
01:12:21,120 --> 01:12:23,535
simulated maximum
capacity of

1938
01:12:23,535 --> 01:12:25,540
11 and 24 megabits
per second.

1939
01:12:25,540 --> 01:12:28,100
We can see that
with BLEnD we can

1940
01:12:28,100 --> 01:12:30,085
achieve more
than 30 percent

1941
01:12:30,085 --> 01:12:32,050
of goodput improvement.

1942
01:12:32,050 --> 01:12:34,260
When we start to

1943
01:12:34,260 --> 01:12:35,760
play around with
the bundle size,

1944
01:12:35,760 --> 01:12:38,640
we can see that even
a small amount of

1945
01:12:38,640 --> 01:12:40,085
bundling can improve

1946
01:12:40,085 --> 01:12:42,410
the goodput by
a large amount,

1947
01:12:42,410 --> 01:12:45,075
and increasing the bundles

1948
01:12:45,075 --> 01:12:47,325
gives small increments

1949
01:12:47,325 --> 01:12:50,315
of improvement in goodput.

1950
01:12:50,315 --> 01:12:53,150
But the main
reason is that,

1951
01:12:53,150 --> 01:12:56,175
why do we see these
improvements?

1952
01:12:56,175 --> 01:12:59,130
Is because the
reduction in

1953
01:12:59,130 --> 01:13:01,025
the link layer
transmission events

1954
01:13:01,025 --> 01:13:02,370
at the sender side.

1955
01:13:02,370 --> 01:13:04,170
You can see that with even

1956
01:13:04,170 --> 01:13:05,470
a small amount of bundle

1957
01:13:05,470 --> 01:13:08,670
the link layer
transmission events

1958
01:13:08,670 --> 01:13:11,055
has been significantly
lowered.

1959
01:13:11,055 --> 01:13:12,240
Where we would have like

1960
01:13:12,240 --> 01:13:16,210
70,000 without
any bundling,

1961
01:13:16,210 --> 01:13:18,060
we would drop below

1962
01:13:18,060 --> 01:13:21,545
10,000 transmissions
at the link.

1963
01:13:21,545 --> 01:13:23,520
Now, talking about

1964
01:13:23,520 --> 01:13:25,005
the challenges
and these are

1965
01:13:25,005 --> 01:13:28,145
the most significant part

1966
01:13:28,145 --> 01:13:29,820
of this overall talk.

1967
01:13:29,820 --> 01:13:33,940
The first one is
RTT fluctuation.

1968
01:13:34,010 --> 01:13:37,050
The producer processes
the bundle interest

1969
01:13:37,050 --> 01:13:38,685
immediately and
sends the data back.

1970
01:13:38,685 --> 01:13:41,910
Also, we saw that the
receiver side handles

1971
01:13:41,910 --> 01:13:43,485
the lost bundle interests

1972
01:13:43,485 --> 01:13:45,675
which is a
delayed reaction,

1973
01:13:45,675 --> 01:13:48,555
so there is RTT
fluctuation going on.

1974
01:13:48,555 --> 01:13:51,080
The way we prove
it is that we

1975
01:13:51,080 --> 01:13:52,770
played around with

1976
01:13:52,770 --> 01:13:54,840
the RTT variance
multiplier,

1977
01:13:54,840 --> 01:13:59,795
and for 100
megabytes of file,

1978
01:13:59,795 --> 01:14:04,695
we expect roughly
71,000 data packets.

1979
01:14:04,695 --> 01:14:07,300
What we see here
is that for

1980
01:14:07,300 --> 01:14:10,455
the default
multiplier of four,

1981
01:14:10,455 --> 01:14:13,740
the retransmission
events and the Psent

1982
01:14:13,740 --> 01:14:17,325
or the producer send
events are very high.

1983
01:14:17,325 --> 01:14:20,385
As we increase
the multiplier,

1984
01:14:20,385 --> 01:14:23,500
the retransmission
events goes down.

1985
01:14:23,630 --> 01:14:25,935
Also the producer send

1986
01:14:25,935 --> 01:14:27,930
events goes down as well,

1987
01:14:27,930 --> 01:14:31,635
which in terms
improves the goodput.

1988
01:14:31,635 --> 01:14:33,900
The next challenge is

1989
01:14:33,900 --> 01:14:36,735
duplicate data in
multiple hops.

1990
01:14:36,735 --> 01:14:39,155
What happens here is that

1991
01:14:39,155 --> 01:14:40,380
although we didn't present

1992
01:14:40,380 --> 01:14:43,580
in the paper that's
accepted at Moe Kong,

1993
01:14:43,580 --> 01:14:46,605
we tried to play around
it a little bit,

1994
01:14:46,605 --> 01:14:48,360
and in here see

1995
01:14:48,360 --> 01:14:50,175
the consumer D is
the data node,

1996
01:14:50,175 --> 01:14:51,780
and we look at

1997
01:14:51,780 --> 01:14:54,775
the pitch of C and
the middle node A.

1998
01:14:54,775 --> 01:14:57,185
It has two interests

1999
01:14:57,185 --> 01:14:59,060
to send at the
application.

2000
01:14:59,060 --> 01:15:01,030
But at the link,

2001
01:15:01,030 --> 01:15:04,770
we have just the name
prefix slash eight,

2002
01:15:04,770 --> 01:15:05,795
and the sequence is

2003
01:15:05,795 --> 01:15:07,335
basically in the
bundled tech.

2004
01:15:07,335 --> 01:15:09,660
The nonce for this
bundle tag is

2005
01:15:09,660 --> 01:15:12,165
the same for both the
interests packets.

2006
01:15:12,165 --> 01:15:14,530
It goes to the next hop,

2007
01:15:14,530 --> 01:15:19,860
and then is again the
same for the next hop.

2008
01:15:19,860 --> 01:15:22,800
When node A is
going to send

2009
01:15:22,800 --> 01:15:26,535
or brought the
interest packet,

2010
01:15:26,535 --> 01:15:28,365
to the next hop,

2011
01:15:28,365 --> 01:15:31,080
the overseer overhears it.

2012
01:15:31,080 --> 01:15:32,640
Given the nonce is

2013
01:15:32,640 --> 01:15:35,655
different for the
other sequence number,

2014
01:15:35,655 --> 01:15:38,130
there are two
entries in the pit.

2015
01:15:38,130 --> 01:15:39,420
What happens is that when

2016
01:15:39,420 --> 01:15:40,755
the data comes back,

2017
01:15:40,755 --> 01:15:41,910
C receives the data,

2018
01:15:41,910 --> 01:15:43,440
it looks at two entries,

2019
01:15:43,440 --> 01:15:45,180
one from the app
and one from

2020
01:15:45,180 --> 01:15:46,620
node A to C

2021
01:15:46,620 --> 01:15:48,855
ends up forwarding the
data packet to pay.

2022
01:15:48,855 --> 01:15:50,390
This is bad for

2023
01:15:50,390 --> 01:15:53,970
channel utilization and
also duplicate data,

2024
01:15:53,970 --> 01:15:55,240
which is
practically useless

2025
01:15:55,240 --> 01:15:56,715
in this particular case.

2026
01:15:56,715 --> 01:15:58,770
We can keep a name

2027
01:15:58,770 --> 01:16:00,755
non-stable at the
senders link,

2028
01:16:00,755 --> 01:16:04,605
so just keeping
track of the nonces.

2029
01:16:04,605 --> 01:16:06,125
One good thing is that

2030
01:16:06,125 --> 01:16:07,410
this duplication

2031
01:16:07,410 --> 01:16:09,540
happens at the
discovery phase,

2032
01:16:09,540 --> 01:16:12,770
considering that we are
using self-learning.

2033
01:16:12,770 --> 01:16:15,215
This table size of the
link should be very

2034
01:16:15,215 --> 01:16:17,835
small and would
have low overhead.

2035
01:16:17,835 --> 01:16:20,990
Talking about more
research opportunities,

2036
01:16:20,990 --> 01:16:23,010
maybe a rate-base
congestion

2037
01:16:23,010 --> 01:16:25,725
controller to avoid
the RTT filtration.

2038
01:16:25,725 --> 01:16:27,780
Dynamic bundle interval to

2039
01:16:27,780 --> 01:16:30,630
scale well over different
link capacities.

2040
01:16:30,630 --> 01:16:33,690
Sender side bundle
loss reaction that

2041
01:16:33,690 --> 01:16:34,890
would help to reduce

2042
01:16:34,890 --> 01:16:36,750
the producer's
side idle time.

2043
01:16:36,750 --> 01:16:39,570
Of course, given
that we see that

2044
01:16:39,570 --> 01:16:42,540
we are optimizing
channel utilization,

2045
01:16:42,540 --> 01:16:44,730
so this would also
be helpful to reduce

2046
01:16:44,730 --> 01:16:47,475
the hidden station effect
and minimize loss,

2047
01:16:47,475 --> 01:16:50,465
and last but not

2048
01:16:50,465 --> 01:16:53,445
least, hop-by-hop
transport opportunity.

2049
01:16:53,445 --> 01:16:55,634
When we have
multi-hop networks,

2050
01:16:55,634 --> 01:16:58,140
less mobility may be

2051
01:16:58,140 --> 01:17:01,950
explore multipath
for load balancing.

2052
01:17:01,950 --> 01:17:03,495
But when we talk about

2053
01:17:03,495 --> 01:17:05,700
this hop-by-hop transport,

2054
01:17:05,700 --> 01:17:07,935
it's currently not
present there,

2055
01:17:07,935 --> 01:17:09,780
so maybe extends sync

2056
01:17:09,780 --> 01:17:11,690
for transport
functionalities

2057
01:17:11,690 --> 01:17:18,000
of each hop with some
rate management.

2058
01:17:18,000 --> 01:17:20,160
This, and of course,

2059
01:17:20,160 --> 01:17:21,870
there are many
more possibilities

2060
01:17:21,870 --> 01:17:23,775
in the overall work.

2061
01:17:23,775 --> 01:17:26,280
This was the early
work that we

2062
01:17:26,280 --> 01:17:28,590
presented and
thank you for

2063
01:17:28,590 --> 01:17:31,200
joining in and
any questions

2064
01:17:31,200 --> 01:17:32,880
I would really
like to take

2065
01:17:32,880 --> 01:17:34,740
those and explore

2066
01:17:34,740 --> 01:17:38,170
future opportunities.
Thank you.

2067
01:17:38,420 --> 01:17:40,770
>> Thank you Ashiq,
you actually

2068
01:17:40,770 --> 01:17:42,720
ended a couple of
minutes early.

2069
01:17:42,720 --> 01:17:44,640
There's quite a bit of

2070
01:17:44,640 --> 01:17:47,970
a discussion going
on on Slack.

2071
01:17:47,970 --> 01:17:51,345
If you want to join
in and chime in.

2072
01:17:51,345 --> 01:17:53,470
>> Yeah, absolutely.

2073
01:17:53,970 --> 01:17:56,600
>> Go ahead and
stop sharing,

2074
01:17:56,600 --> 01:17:58,680
and we'll have Saurab,

2075
01:17:58,680 --> 01:18:00,825
step up with his
presentation.

2076
01:18:00,825 --> 01:18:01,920
Saurab, go ahead and start

2077
01:18:01,920 --> 01:18:03,475
sharing your screen.

2078
01:18:03,475 --> 01:18:05,220
Saurab is a PhD student

2079
01:18:05,220 --> 01:18:06,360
at the University
of Memphis,

2080
01:18:06,360 --> 01:18:07,490
working with land,

2081
01:18:07,490 --> 01:18:09,215
he received his master's

2082
01:18:09,215 --> 01:18:10,560
degree in computer science

2083
01:18:10,560 --> 01:18:14,595
from Memphis in
December 2020,

2084
01:18:14,595 --> 01:18:16,510
and his bachelor's degree

2085
01:18:16,510 --> 01:18:17,820
in Computer Engineering

2086
01:18:17,820 --> 01:18:21,335
from Tribhuvan
University in Nepal.

2087
01:18:21,335 --> 01:18:23,160
I hope I said
that somewhere

2088
01:18:23,160 --> 01:18:25,090
close to right, so
I can [inaudible].

2089
01:18:25,090 --> 01:18:27,660
His places of interest,

2090
01:18:27,660 --> 01:18:30,000
of course, include
data networking

2091
01:18:30,000 --> 01:18:32,480
and distributed computing.

2092
01:18:32,480 --> 01:18:36,585
Saurab, if you are here.

2093
01:18:36,585 --> 01:18:39,555
Ashiq, you can
mute your mic.

2094
01:18:39,555 --> 01:18:41,670
>> Oh sorry about that.

2095
01:18:41,670 --> 01:18:44,390
>> I need to quit
re-join because

2096
01:18:44,390 --> 01:18:48,280
I can't share the screen.
Give me a moment.

2097
01:19:02,980 --> 01:19:05,520
>> Check your
microphone is still not

2098
01:19:05,520 --> 01:19:09,180
muted. There you go.

2099
01:19:09,180 --> 01:19:16,560
[BACKGROUND]

2100
01:19:16,560 --> 01:19:23,850
A little bit,

2101
01:19:23,850 --> 01:19:25,139
if you're having
difficulty,

2102
01:19:25,139 --> 01:19:28,080
I could try to
display your slides.

2103
01:19:28,080 --> 01:19:30,180
Just let us know
what you prefer.

2104
01:19:30,180 --> 01:19:44,240
[BACKGROUND]

2105
01:19:44,240 --> 01:19:46,110
Did we lose him?

2106
01:20:01,880 --> 01:20:03,685
>> Can you hear me?

2107
01:20:03,685 --> 01:20:04,980
>> Yes.

2108
01:20:04,980 --> 01:20:06,720
>> Sorry for the delay.

2109
01:20:06,720 --> 01:20:07,350
>> That's okay,

2110
01:20:07,350 --> 01:20:08,010
you're going to go ahead

2111
01:20:08,010 --> 01:20:09,495
and share your slides.

2112
01:20:09,495 --> 01:20:11,200
>> Yeah,

2113
01:20:19,910 --> 01:20:21,060
can

2114
01:20:21,060 --> 01:20:23,370
you see my screen?

2115
01:20:23,370 --> 01:20:26,250
>> Yeah, we're seeing
the speaker's view.

2116
01:20:26,250 --> 01:20:28,650
We're going to try
going to full-screen.

2117
01:20:28,650 --> 01:20:29,730
>> Is it fine now?

2118
01:20:29,730 --> 01:20:31,140
>> Excellence.
Yes, perfect,

2119
01:20:31,140 --> 01:20:32,040
you're good to go.

2120
01:20:32,040 --> 01:20:33,405
>> To there moving right?

2121
01:20:33,405 --> 01:20:34,560
>> Yeah.

2122
01:20:34,560 --> 01:20:35,970
>> Thank you so much

2123
01:20:35,970 --> 01:20:37,980
Christos for the
introduction.

2124
01:20:37,980 --> 01:20:39,600
Our work is on

2125
01:20:39,600 --> 01:20:40,890
adaptive duplicate
suppression for

2126
01:20:40,890 --> 01:20:44,380
multicasting in a
Multi-Access NDN network.

2127
01:20:45,500 --> 01:20:47,580
We have little
bit more about

2128
01:20:47,580 --> 01:20:48,360
the problem statement from

2129
01:20:48,360 --> 01:20:49,875
the previous
speaker as well,

2130
01:20:49,875 --> 01:20:51,915
but I'm a little bit
repeating it here again.

2131
01:20:51,915 --> 01:20:53,790
On the multicasting,
we can run into

2132
01:20:53,790 --> 01:20:54,810
a scenario where a lot of

2133
01:20:54,810 --> 01:20:56,190
redundant traffic flows
into the network.

2134
01:20:56,190 --> 01:20:58,680
You can see
here some nodes

2135
01:20:58,680 --> 01:21:00,600
can send an interest
out for some files.

2136
01:21:00,600 --> 01:21:01,770
While the data
hasn't come back

2137
01:21:01,770 --> 01:21:02,655
some other nodes can

2138
01:21:02,655 --> 01:21:03,960
send the same
interest out,

2139
01:21:03,960 --> 01:21:05,835
and then there can be
a lot of traffic and

2140
01:21:05,835 --> 01:21:06,840
all other nodes also

2141
01:21:06,840 --> 01:21:08,010
can send the
same interests,

2142
01:21:08,010 --> 01:21:11,890
which it can make the
situation even worse.

2143
01:21:12,680 --> 01:21:15,940
The similar
scenario occurs

2144
01:21:16,070 --> 01:21:19,660
in case of data reply
over the networks.

2145
01:21:19,760 --> 01:21:21,900
The situation
even get worse

2146
01:21:21,900 --> 01:21:23,430
when unsolicited
data occurs

2147
01:21:23,430 --> 01:21:24,915
because the node can

2148
01:21:24,915 --> 01:21:26,985
just reply the data
from the cache.

2149
01:21:26,985 --> 01:21:29,220
In that scenario,
many nodes

2150
01:21:29,220 --> 01:21:30,780
can reply the same
data packets,

2151
01:21:30,780 --> 01:21:32,130
so there can be
taken to a lot of

2152
01:21:32,130 --> 01:21:34,930
duplicates in that
scenario as well.

2153
01:21:35,240 --> 01:21:38,670
Our goal for this work

2154
01:21:38,670 --> 01:21:39,930
is to reduce the number of

2155
01:21:39,930 --> 01:21:42,420
redundant requests
and data replies

2156
01:21:42,420 --> 01:21:44,550
and to increase the
overall bandwidth.

2157
01:21:44,550 --> 01:21:46,110
Right now we mostly focus

2158
01:21:46,110 --> 01:21:48,240
on the single-hop
scenario.

2159
01:21:48,240 --> 01:21:50,325
Ideally, the suppression

2160
01:21:50,325 --> 01:21:51,975
should add up to the
network condition.

2161
01:21:51,975 --> 01:21:54,090
In case of lossy
environment,

2162
01:21:54,090 --> 01:21:55,710
only one
interesting data of

2163
01:21:55,710 --> 01:21:57,900
the same name
can be sent by

2164
01:21:57,900 --> 01:21:59,910
a node and then on

2165
01:21:59,910 --> 01:22:02,055
the multicast, same
multi-access link.

2166
01:22:02,055 --> 01:22:03,810
If the environment
is lossy,

2167
01:22:03,810 --> 01:22:06,705
then small number of
duplicates it's fine.

2168
01:22:06,705 --> 01:22:08,310
We also want to place

2169
01:22:08,310 --> 01:22:09,870
this functionality in
the multicast face so

2170
01:22:09,870 --> 01:22:12,645
that it can support a
lot of applications,

2171
01:22:12,645 --> 01:22:18,070
so it'll be intrinsic
to the end of itself.

2172
01:22:19,330 --> 01:22:21,980
The high-level design is,

2173
01:22:21,980 --> 01:22:27,785
we have two
different cases.

2174
01:22:27,785 --> 01:22:29,180
One is look
behind case, and

2175
01:22:29,180 --> 01:22:30,410
the other one
is look ahead

2176
01:22:30,410 --> 01:22:33,780
case which I'll talk
about in a minute.

2177
01:22:34,130 --> 01:22:36,450
The strategy is here

2178
01:22:36,450 --> 01:22:37,935
to record all
the interest,

2179
01:22:37,935 --> 01:22:40,200
that is name and
duplicate count receive

2180
01:22:40,200 --> 01:22:41,550
from or sent to

2181
01:22:41,550 --> 01:22:43,260
a multicast face into
a measurement table,

2182
01:22:43,260 --> 01:22:44,340
so just record all

2183
01:22:44,340 --> 01:22:46,170
these names and
duplicate counts.

2184
01:22:46,170 --> 01:22:48,420
Each of these entries
in the measurement

2185
01:22:48,420 --> 01:22:50,355
table has a
short lifetime,

2186
01:22:50,355 --> 01:22:52,740
order of
propagation delay.

2187
01:22:52,740 --> 01:22:54,450
Approximately
that's the lifetime

2188
01:22:54,450 --> 01:22:56,220
of this intro in the
measurement table.

2189
01:22:56,220 --> 01:22:59,265
If the interests
satisfied or timed out,

2190
01:22:59,265 --> 01:22:59,910
remove

2191
01:22:59,910 --> 01:23:02,370
the corresponding
interest from the table.

2192
01:23:02,370 --> 01:23:06,360
Also before sending
that interest

2193
01:23:06,360 --> 01:23:08,070
of data packet to
a multicast face,

2194
01:23:08,070 --> 01:23:09,585
check if it is
already in the table.

2195
01:23:09,585 --> 01:23:10,770
Which means if
the interests

2196
01:23:10,770 --> 01:23:11,940
of data is already
in the table,

2197
01:23:11,940 --> 01:23:12,780
which means it's in

2198
01:23:12,780 --> 01:23:13,620
a flight so you don't have

2199
01:23:13,620 --> 01:23:16,500
to duplicate that
interests of data.

2200
01:23:16,500 --> 01:23:18,630
If it is in the table,

2201
01:23:18,630 --> 01:23:20,520
just drop the
interests of data.

2202
01:23:20,520 --> 01:23:23,160
If not, then you go to
the look-ahead case.

2203
01:23:23,160 --> 01:23:24,660
In the look-ahead
case, which

2204
01:23:24,660 --> 01:23:26,340
obviously means when
there is no record

2205
01:23:26,340 --> 01:23:28,650
in the measurement
table before forming

2206
01:23:28,650 --> 01:23:30,120
an interest to a
multicast face

2207
01:23:30,120 --> 01:23:31,545
, you wait for some time.

2208
01:23:31,545 --> 01:23:32,910
This is a
suppression timer.

2209
01:23:32,910 --> 01:23:35,655
Wait for some
time, and then if

2210
01:23:35,655 --> 01:23:37,020
another interest
of data is

2211
01:23:37,020 --> 01:23:38,505
overheard during
this weight,

2212
01:23:38,505 --> 01:23:40,650
you can cancel
the forwarding.

2213
01:23:40,650 --> 01:23:42,690
They don't need to
send a duplicate out.

2214
01:23:42,690 --> 01:23:45,730
The suppression timer
should be adopted.

2215
01:23:46,460 --> 01:23:48,540
As we mentioned the goal,

2216
01:23:48,540 --> 01:23:49,650
this is one of
the other goal.

2217
01:23:49,650 --> 01:23:51,585
It's adaptive to the
network conditions,

2218
01:23:51,585 --> 01:23:54,225
if there is a large
number of duplicates,

2219
01:23:54,225 --> 01:24:00,480
then suppression
timer can be higher.

2220
01:24:00,480 --> 01:24:03,540
If it's not, then the

2221
01:24:03,540 --> 01:24:05,880
suppression timer
can be decreased.

2222
01:24:05,880 --> 01:24:07,950
For the lossy
link permitting

2223
01:24:07,950 --> 01:24:09,540
a few duplicates
would be fine,

2224
01:24:09,540 --> 01:24:11,370
so the wait time
can be relatively

2225
01:24:11,370 --> 01:24:13,770
smaller for that case.

2226
01:24:13,770 --> 01:24:16,830
The design logic is we
implemented this in

2227
01:24:16,830 --> 01:24:19,260
the link service and

2228
01:24:19,260 --> 01:24:20,640
we hope that it
should be applied.

2229
01:24:20,640 --> 01:24:21,975
We implemented
here because

2230
01:24:21,975 --> 01:24:23,850
can be applied to all
the applications.

2231
01:24:23,850 --> 01:24:25,020
They can find a work in

2232
01:24:25,020 --> 01:24:26,860
progress in this link.

2233
01:24:26,990 --> 01:24:29,300
This is our incoming

2234
01:24:29,300 --> 01:24:30,740
data and interests
pipeline.

2235
01:24:30,740 --> 01:24:34,325
How does the
suppression worksheet,

2236
01:24:34,325 --> 01:24:35,990
when something is

2237
01:24:35,990 --> 01:24:37,805
received from
the neighbors,

2238
01:24:37,805 --> 01:24:38,720
interested data is

2239
01:24:38,720 --> 01:24:40,505
received from
the neighbors?

2240
01:24:40,505 --> 01:24:43,050
If the same interests
of data it already

2241
01:24:43,050 --> 01:24:44,910
scheduled for the
transmission,

2242
01:24:44,910 --> 01:24:48,885
then just cancel the
previously scheduled.

2243
01:24:48,885 --> 01:24:50,430
If the same
interests of data

2244
01:24:50,430 --> 01:24:52,230
is received and
it will check

2245
01:24:52,230 --> 01:24:53,850
whether the same
as it already

2246
01:24:53,850 --> 01:24:54,990
scheduled for
transmission,

2247
01:24:54,990 --> 01:24:56,115
you cancel that one.

2248
01:24:56,115 --> 01:24:58,875
If not, then check in
the measurement table.

2249
01:24:58,875 --> 01:25:01,590
In the measurement
table, if there is

2250
01:25:01,590 --> 01:25:03,060
no measurement for this

2251
01:25:03,060 --> 01:25:04,710
intercept data that
is just received,

2252
01:25:04,710 --> 01:25:06,120
then you add a bunch

2253
01:25:06,120 --> 01:25:07,680
of other things
in the table.

2254
01:25:07,680 --> 01:25:09,780
Add interests or data,
record to the table,

2255
01:25:09,780 --> 01:25:11,475
and initialize a
duplicate counter.

2256
01:25:11,475 --> 01:25:12,750
This duplicate
counter necessarily

2257
01:25:12,750 --> 01:25:13,710
means how many
duplicates you

2258
01:25:13,710 --> 01:25:14,895
received from the network

2259
01:25:14,895 --> 01:25:15,960
but that's the counter.

2260
01:25:15,960 --> 01:25:17,760
You initialize the
duplicate counter

2261
01:25:17,760 --> 01:25:19,185
for that interests
of data.

2262
01:25:19,185 --> 01:25:21,150
Then also schedule that

2263
01:25:21,150 --> 01:25:23,100
interested data
record expression.

2264
01:25:23,100 --> 01:25:24,210
This record in

2265
01:25:24,210 --> 01:25:25,590
the table doesn't
stay forever,

2266
01:25:25,590 --> 01:25:27,240
as we mentioned
earlier so it

2267
01:25:27,240 --> 01:25:29,220
expires in a short
period of time.

2268
01:25:29,220 --> 01:25:30,915
Also scheduled
that expression.

2269
01:25:30,915 --> 01:25:32,220
But if it is already in

2270
01:25:32,220 --> 01:25:33,480
the table and we

2271
01:25:33,480 --> 01:25:35,250
check whether that
is interest of data.

2272
01:25:35,250 --> 01:25:37,650
If it is
interests, then we

2273
01:25:37,650 --> 01:25:39,840
increase the duplicate
count of the interest

2274
01:25:39,840 --> 01:25:42,120
and then handle
this interest

2275
01:25:42,120 --> 01:25:44,715
to the local
forwarding pipeline.

2276
01:25:44,715 --> 01:25:45,750
If it is a data,

2277
01:25:45,750 --> 01:25:47,890
then there's a bunch
of stuff to do.

2278
01:25:48,230 --> 01:25:50,250
This is EWMA,

2279
01:25:50,250 --> 01:25:50,460
which

2280
01:25:50,460 --> 01:25:53,250
means Exponentially
Weighted Moving Average,

2281
01:25:53,250 --> 01:25:55,800
I'll talk about this
in the next slide.

2282
01:25:55,800 --> 01:25:58,560
We compute the exponential
weighted moving

2283
01:25:58,560 --> 01:26:00,630
average of the interests
prefix if it's data.

2284
01:26:00,630 --> 01:26:02,220
Because when the
data comes back

2285
01:26:02,220 --> 01:26:03,915
it means the interest
is satisfied,

2286
01:26:03,915 --> 01:26:04,890
so we have to remove

2287
01:26:04,890 --> 01:26:06,285
the interest
from the table.

2288
01:26:06,285 --> 01:26:08,490
We compute that for the
interest prefix and

2289
01:26:08,490 --> 01:26:09,630
remove the
corresponding interest

2290
01:26:09,630 --> 01:26:11,175
record from the
measurement table.

2291
01:26:11,175 --> 01:26:12,870
After removing we

2292
01:26:12,870 --> 01:26:14,145
also update the
suppression timer.

2293
01:26:14,145 --> 01:26:15,240
The suppression timer will

2294
01:26:15,240 --> 01:26:16,170
be highly

2295
01:26:16,170 --> 01:26:17,460
correlated with the
duplicate count,

2296
01:26:17,460 --> 01:26:19,410
as we said, so it
has to be adaptive.

2297
01:26:19,410 --> 01:26:21,030
That's why we update

2298
01:26:21,030 --> 01:26:23,580
a suppression timer for
this interest prefix.

2299
01:26:23,580 --> 01:26:25,680
Finally, we increase
the duplicate data

2300
01:26:25,680 --> 01:26:28,680
count for the data.

2301
01:26:28,680 --> 01:26:30,885
Also as we mentioned here,

2302
01:26:30,885 --> 01:26:32,955
there is a record
scheduling

2303
01:26:32,955 --> 01:26:34,500
of interest and
data in the table,

2304
01:26:34,500 --> 01:26:37,590
if interests of data,

2305
01:26:37,590 --> 01:26:39,030
if it expires, we update

2306
01:26:39,030 --> 01:26:41,010
the corresponding
suppression timer

2307
01:26:41,010 --> 01:26:43,480
of the interests or
the data prefix.

2308
01:26:44,150 --> 01:26:46,650
But this is how the
incoming interest in

2309
01:26:46,650 --> 01:26:50,970
data works.

2310
01:26:50,970 --> 01:26:52,905
For the outgoing
interest with data

2311
01:26:52,905 --> 01:26:54,510
when the interests of data

2312
01:26:54,510 --> 01:26:55,020
is received from

2313
01:26:55,020 --> 01:26:56,235
the local forwarding
pipeline,

2314
01:26:56,235 --> 01:26:58,305
we check if that is in
the measurement table.

2315
01:26:58,305 --> 01:26:59,430
If it is in the
measurement table,

2316
01:26:59,430 --> 01:27:01,080
we simply drop
that interest

2317
01:27:01,080 --> 01:27:01,830
of data you don't have

2318
01:27:01,830 --> 01:27:05,160
to fold that duplication
for network.

2319
01:27:05,160 --> 01:27:07,980
If it is not in the
measurement table,

2320
01:27:07,980 --> 01:27:10,125
then we set a suppression
timer for this,

2321
01:27:10,125 --> 01:27:12,225
the suppression timer
that we compute here.

2322
01:27:12,225 --> 01:27:13,500
This will be used to

2323
01:27:13,500 --> 01:27:15,610
set the suppression timer.

2324
01:27:16,190 --> 01:27:19,365
Once the suppressant
timer expires,

2325
01:27:19,365 --> 01:27:21,660
we add this record

2326
01:27:21,660 --> 01:27:22,680
whether it is
an interest of

2327
01:27:22,680 --> 01:27:24,360
data in the
measurement module.

2328
01:27:24,360 --> 01:27:27,240
Which means the nodes

2329
01:27:27,240 --> 01:27:28,890
its own forwarding is also

2330
01:27:28,890 --> 01:27:30,570
added to the
measurement module.

2331
01:27:30,570 --> 01:27:31,350
This is a measurement

2332
01:27:31,350 --> 01:27:33,300
[inaudible] that I
talked previously.

2333
01:27:33,300 --> 01:27:35,430
Nodes on folding

2334
01:27:35,430 --> 01:27:36,540
is also added
to the module,

2335
01:27:36,540 --> 01:27:38,940
and then finally
the interests

2336
01:27:38,940 --> 01:27:41,200
of data it is forwarded
to the network.

2337
01:27:42,320 --> 01:27:44,880
The exponential weighted
moving average,

2338
01:27:44,880 --> 01:27:46,620
we compute the
exponential weighted

2339
01:27:46,620 --> 01:27:48,690
moving average of the
duplicate counts.

2340
01:27:48,690 --> 01:27:50,550
Previously I showed
it in the slides,

2341
01:27:50,550 --> 01:27:54,090
here, when we

2342
01:27:54,090 --> 01:27:55,770
receiving interest on
data we can insulate

2343
01:27:55,770 --> 01:27:56,820
the duplicate counter and

2344
01:27:56,820 --> 01:27:58,170
then distribute
the counter.

2345
01:27:58,170 --> 01:27:59,805
We use this to compute the

2346
01:27:59,805 --> 01:28:02,145
exponential weighted
moving average.

2347
01:28:02,145 --> 01:28:03,600
Basically, we use

2348
01:28:03,600 --> 01:28:06,580
this formula to compute
the moving average.

2349
01:28:08,660 --> 01:28:11,730
This is a smoothing
factor. We basically

2350
01:28:11,730 --> 01:28:13,290
also considering the

2351
01:28:13,290 --> 01:28:14,370
previous duplicate counts,

2352
01:28:14,370 --> 01:28:16,110
not only the present
duplicate count but

2353
01:28:16,110 --> 01:28:17,625
also considering

2354
01:28:17,625 --> 01:28:18,690
the previous
duplicate counts

2355
01:28:18,690 --> 01:28:19,965
for the same prefix.

2356
01:28:19,965 --> 01:28:26,160
That's why we smooth
this duplicate count.

2357
01:28:26,160 --> 01:28:27,690
As I said, the
granularity is

2358
01:28:27,690 --> 01:28:29,595
name minus the
last component,

2359
01:28:29,595 --> 01:28:31,860
also the moving average is

2360
01:28:31,860 --> 01:28:32,400
reset after

2361
01:28:32,400 --> 01:28:33,855
the maximum measurement
inactively period.

2362
01:28:33,855 --> 01:28:37,230
Which means it will
computed for the prefix.

2363
01:28:37,230 --> 01:28:40,710
If nothing is received

2364
01:28:40,710 --> 01:28:43,860
for that prefix for
quite a period of time,

2365
01:28:43,860 --> 01:28:45,720
then we remove
that measurement

2366
01:28:45,720 --> 01:28:46,740
because it might not

2367
01:28:46,740 --> 01:28:50,650
be relevant for the
future prefixes anymore.

2368
01:28:51,080 --> 01:28:53,565
The suppression
time and the timer.

2369
01:28:53,565 --> 01:28:58,020
We use one algorithm

2370
01:28:58,020 --> 01:29:00,030
to compute the
suppression time

2371
01:29:00,030 --> 01:29:01,305
and the
corresponding timer.

2372
01:29:01,305 --> 01:29:02,820
The main goal
of this is to

2373
01:29:02,820 --> 01:29:04,110
maintain the
duplicate count

2374
01:29:04,110 --> 01:29:05,400
below the duplicate
threshold.

2375
01:29:05,400 --> 01:29:07,320
This duplicate threshold,

2376
01:29:07,320 --> 01:29:08,280
it's configured based on

2377
01:29:08,280 --> 01:29:09,555
the loss rate of
the environment.

2378
01:29:09,555 --> 01:29:11,370
If the network is very

2379
01:29:11,370 --> 01:29:12,975
lossy then the threshold
can be higher,

2380
01:29:12,975 --> 01:29:14,850
if the network is
pretty stable,

2381
01:29:14,850 --> 01:29:15,570
there is no loss then

2382
01:29:15,570 --> 01:29:16,440
the duplicates
threshold can

2383
01:29:16,440 --> 01:29:19,990
be pretty much smaller.

2384
01:29:21,640 --> 01:29:23,870
Here, I've shown
how we update

2385
01:29:23,870 --> 01:29:25,130
the suppression timer.

2386
01:29:25,130 --> 01:29:28,070
It has three phases
and how it is updated.

2387
01:29:28,070 --> 01:29:30,785
If the moving average
is above the threshold

2388
01:29:30,785 --> 01:29:32,510
and is increasing
which means

2389
01:29:32,510 --> 01:29:34,010
there are a lot of
duplicates in the network,

2390
01:29:34,010 --> 01:29:35,210
so it's increasing and

2391
01:29:35,210 --> 01:29:36,545
the moving average is not

2392
01:29:36,545 --> 01:29:38,480
decreasing and
is also able to

2393
01:29:38,480 --> 01:29:39,800
threshold then
we exponentially

2394
01:29:39,800 --> 01:29:41,405
increases the
suppression timer.

2395
01:29:41,405 --> 01:29:43,070
It increases here and

2396
01:29:43,070 --> 01:29:44,300
the suppression
timer increases

2397
01:29:44,300 --> 01:29:44,915
exponentially,

2398
01:29:44,915 --> 01:29:46,520
so it resists
at some point.

2399
01:29:46,520 --> 01:29:50,840
Now, the moving
average is still above

2400
01:29:50,840 --> 01:29:54,530
the threshold but if

2401
01:29:54,530 --> 01:29:55,490
the moving
average is still

2402
01:29:55,490 --> 01:29:56,780
threshold but it
is decreasing,

2403
01:29:56,780 --> 01:29:58,700
if that's the
condition then

2404
01:29:58,700 --> 01:30:00,710
we keep the suppression
timer as it is,

2405
01:30:00,710 --> 01:30:02,780
so it is a carryover of
the suppression time.

2406
01:30:02,780 --> 01:30:04,040
We don't decrease it

2407
01:30:04,040 --> 01:30:06,140
until we reach to a point

2408
01:30:06,140 --> 01:30:08,195
when the moving average

2409
01:30:08,195 --> 01:30:09,785
is below the threshold.

2410
01:30:09,785 --> 01:30:11,060
Then when moving
average comes

2411
01:30:11,060 --> 01:30:12,665
below the threshold
which means

2412
01:30:12,665 --> 01:30:16,010
it asumes that knowledge

2413
01:30:16,010 --> 01:30:17,840
has done a good
job in the past,

2414
01:30:17,840 --> 01:30:19,165
so that's why now

2415
01:30:19,165 --> 01:30:21,220
the suppression
timer is in a range,

2416
01:30:21,220 --> 01:30:23,095
so you start decreasing
it linearly.

2417
01:30:23,095 --> 01:30:24,565
Increases to
some point and

2418
01:30:24,565 --> 01:30:27,000
again, this thing happens.

2419
01:30:27,000 --> 01:30:30,395
The expectation is after
some period of time,

2420
01:30:30,395 --> 01:30:32,135
after running for a while,

2421
01:30:32,135 --> 01:30:34,190
the algorithm
will itself find

2422
01:30:34,190 --> 01:30:35,300
an operating range for

2423
01:30:35,300 --> 01:30:36,305
that particular
environment.

2424
01:30:36,305 --> 01:30:37,805
That's an expectation.

2425
01:30:37,805 --> 01:30:41,370
It's finding an
operating range.

2426
01:30:42,250 --> 01:30:44,570
That's the
algorithm on how

2427
01:30:44,570 --> 01:30:46,580
we address the
suppression time.

2428
01:30:46,580 --> 01:30:48,905
The suppression timer it's

2429
01:30:48,905 --> 01:30:51,500
a random between zero

2430
01:30:51,500 --> 01:30:52,670
and the suppression time.

2431
01:30:52,670 --> 01:30:54,800
The timer is the
one which will be

2432
01:30:54,800 --> 01:30:59,075
used before folding an
interest or data out.

2433
01:30:59,075 --> 01:31:01,490
The suppression
time is computed

2434
01:31:01,490 --> 01:31:03,500
regularly after we receive

2435
01:31:03,500 --> 01:31:05,450
the new duplicate account.

2436
01:31:05,450 --> 01:31:07,160
This is updated
regularly but

2437
01:31:07,160 --> 01:31:10,235
when the node decides
to forward something,

2438
01:31:10,235 --> 01:31:11,855
we compute the
suppression timer.

2439
01:31:11,855 --> 01:31:14,795
The suppression
timer will be

2440
01:31:14,795 --> 01:31:16,640
always correlated

2441
01:31:16,640 --> 01:31:19,190
with the duplicates
in the network.

2442
01:31:19,190 --> 01:31:21,540
But of course,
certain prefix.

2443
01:31:21,880 --> 01:31:23,840
I'll go to the
implementation

2444
01:31:23,840 --> 01:31:25,250
and experimental setup.

2445
01:31:25,250 --> 01:31:26,780
As I've said, it
is implemented in

2446
01:31:26,780 --> 01:31:29,480
the current NFD at face
in the link service.

2447
01:31:29,480 --> 01:31:32,435
For the experiment,
we use a

2448
01:31:32,435 --> 01:31:36,110
mini-NDN Wi-Fi and this

2449
01:31:36,110 --> 01:31:37,805
is the topology
that we use.

2450
01:31:37,805 --> 01:31:41,060
Here, the consumers
simultaneously fetch

2451
01:31:41,060 --> 01:31:45,080
615-kilobyte of file which

2452
01:31:45,080 --> 01:31:46,730
has 81 segments using

2453
01:31:46,730 --> 01:31:47,525
catchunks and putchunks

2454
01:31:47,525 --> 01:31:49,025
over the
multi-access link.

2455
01:31:49,025 --> 01:31:51,230
This is the
topology and then

2456
01:31:51,230 --> 01:31:52,340
these are some
of the constants

2457
01:31:52,340 --> 01:31:53,555
that we use in
the experiments.

2458
01:31:53,555 --> 01:31:55,490
The smoothing_factor
is this and there are

2459
01:31:55,490 --> 01:31:57,440
a bunch of other
constants that

2460
01:31:57,440 --> 01:31:59,810
we have used for the
experiments as well

2461
01:31:59,810 --> 01:32:04,200
as for the implementation.

2462
01:32:05,350 --> 01:32:07,910
This is our
preliminary evaluation

2463
01:32:07,910 --> 01:32:09,740
we are still working
on the evaluations.

2464
01:32:09,740 --> 01:32:11,540
But this is one

2465
01:32:11,540 --> 01:32:13,295
number that I would
like to share.

2466
01:32:13,295 --> 01:32:15,665
Here, this is the
average number of

2467
01:32:15,665 --> 01:32:17,930
received increased
data unsolicited,

2468
01:32:17,930 --> 01:32:20,310
interest with data
packet received.

2469
01:32:20,470 --> 01:32:24,005
How many of them are
received by a consumer?

2470
01:32:24,005 --> 01:32:26,300
In this experiment,
we have

2471
01:32:26,300 --> 01:32:28,595
this three consumers
and one producer.

2472
01:32:28,595 --> 01:32:31,550
The interest packet
without suppression,

2473
01:32:31,550 --> 01:32:33,800
there were 204 interests
packet was received.

2474
01:32:33,800 --> 01:32:39,440
Basically, they were
altogether 81 segments

2475
01:32:39,440 --> 01:32:41,645
but total number of

2476
01:32:41,645 --> 01:32:43,280
interests received
by a consumer which

2477
01:32:43,280 --> 01:32:44,960
means a consumer is also

2478
01:32:44,960 --> 01:32:46,925
receiving the interest
from its neighbors,

2479
01:32:46,925 --> 01:32:48,560
so this is the number

2480
01:32:48,560 --> 01:32:50,480
of data

2481
01:32:50,480 --> 01:32:53,310
the consumer received
without suppression.

2482
01:32:53,380 --> 01:32:57,515
From 145 of
those data were

2483
01:32:57,515 --> 01:32:59,660
unsolicited
because it only

2484
01:32:59,660 --> 01:33:02,160
expected roughly
81 segments.

2485
01:33:04,210 --> 01:33:07,820
The other data packets
were unsolicited here.

2486
01:33:07,820 --> 01:33:09,710
With suppression,
you can see

2487
01:33:09,710 --> 01:33:11,570
the interest packet
is substantially

2488
01:33:11,570 --> 01:33:13,940
reduced just to 90
which is you would

2489
01:33:13,940 --> 01:33:16,820
expect about 81-82
interest to go

2490
01:33:16,820 --> 01:33:19,460
out and then it
is reduced to

2491
01:33:19,460 --> 01:33:24,750
substantially
almost three times.

2492
01:33:25,390 --> 01:33:28,505
Not through number
2.5 times, I'll say.

2493
01:33:28,505 --> 01:33:29,675
Then also for the data,

2494
01:33:29,675 --> 01:33:31,460
it is also reduced
substantially and

2495
01:33:31,460 --> 01:33:34,070
then unsolicited
data is very less.

2496
01:33:34,070 --> 01:33:36,500
At the producer
side, all together,

2497
01:33:36,500 --> 01:33:37,940
producer without
suppression received

2498
01:33:37,940 --> 01:33:40,560
307 interests packets.

2499
01:33:40,690 --> 01:33:42,950
With suppression,
it just received

2500
01:33:42,950 --> 01:33:45,185
135 interest packets.

2501
01:33:45,185 --> 01:33:47,075
This is a very

2502
01:33:47,075 --> 01:33:48,380
substantial reduction

2503
01:33:48,380 --> 01:33:49,160
in the duplicate counts.

2504
01:33:49,160 --> 01:33:51,215
[NOISE] Here we can
see in this table,

2505
01:33:51,215 --> 01:33:52,640
the expected
number of packets

2506
01:33:52,640 --> 01:33:53,675
from the consumer
and producer.

2507
01:33:53,675 --> 01:33:54,950
We were using
the duplicate

2508
01:33:54,950 --> 01:33:56,265
threshold of 1.5,

2509
01:33:56,265 --> 01:33:58,000
so ideally you
would expect

2510
01:33:58,000 --> 01:34:00,040
246 of those interests in

2511
01:34:00,040 --> 01:34:02,770
data packets
combined which

2512
01:34:02,770 --> 01:34:04,300
is 1.5 is the threshold.

2513
01:34:04,300 --> 01:34:06,760
Up to 1.5 duplicate
is allowed,

2514
01:34:06,760 --> 01:34:08,810
so which means
you would expect

2515
01:34:08,810 --> 01:34:11,820
82 interests plus
82 data packets,

2516
01:34:12,490 --> 01:34:14,990
total number of
segments into

2517
01:34:14,990 --> 01:34:16,890
1.5 which is 246.

2518
01:34:16,890 --> 01:34:19,990
With suppression,
only 262 packets

2519
01:34:19,990 --> 01:34:21,310
were observed.

2520
01:34:21,310 --> 01:34:22,780
Total number of
interests in

2521
01:34:22,780 --> 01:34:24,310
data packet from
both consumer and

2522
01:34:24,310 --> 01:34:26,320
producer which is
135 interests packet

2523
01:34:26,320 --> 01:34:26,740
you can see it

2524
01:34:26,740 --> 01:34:29,650
here and 127 data packet

2525
01:34:29,650 --> 01:34:31,545
which was received
by the consumers.

2526
01:34:31,545 --> 01:34:33,995
Without suppression
it was pretty high,

2527
01:34:33,995 --> 01:34:35,600
307 interests packet was

2528
01:34:35,600 --> 01:34:36,620
received by the producers.

2529
01:34:36,620 --> 01:34:37,970
Total number of
packet is [NOISE]

2530
01:34:37,970 --> 01:34:40,535
307 plus 225 which
is the data packet.

2531
01:34:40,535 --> 01:34:42,410
You can see from
this table,

2532
01:34:42,410 --> 01:34:44,120
the reduction in the
duplicate traffic

2533
01:34:44,120 --> 01:34:45,875
is almost 50 percent.

2534
01:34:45,875 --> 01:34:47,750
That's why with

2535
01:34:47,750 --> 01:34:49,190
the suppression

2536
01:34:49,190 --> 01:34:50,495
model that we
have implemented,

2537
01:34:50,495 --> 01:34:52,415
we have come
up to this far

2538
01:34:52,415 --> 01:34:53,270
reducing

2539
01:34:53,270 --> 01:34:55,890
the large number of
duplicate packet.

2540
01:34:55,990 --> 01:34:57,650
Some of the challenges

2541
01:34:57,650 --> 01:34:58,430
that we're facing right

2542
01:34:58,430 --> 01:35:00,050
now is the fluctuation of

2543
01:35:00,050 --> 01:35:01,730
suppression time
and finding

2544
01:35:01,730 --> 01:35:03,650
optimal operating range.

2545
01:35:03,650 --> 01:35:05,270
Here in this experiment,

2546
01:35:05,270 --> 01:35:06,920
this was the same
experiment that I showed

2547
01:35:06,920 --> 01:35:11,810
earlier which
had 82 segments.

2548
01:35:11,810 --> 01:35:14,090
The suppression time
was fluctuating

2549
01:35:14,090 --> 01:35:15,830
from quite high
and then it

2550
01:35:15,830 --> 01:35:17,300
was coming back down

2551
01:35:17,300 --> 01:35:19,760
all the way to the
minimum value.

2552
01:35:19,760 --> 01:35:21,260
We're not expected
to come to

2553
01:35:21,260 --> 01:35:24,050
the very minimum value

2554
01:35:24,050 --> 01:35:26,510
but we expect it

2555
01:35:26,510 --> 01:35:28,730
to stay in some of
the operating range.

2556
01:35:28,730 --> 01:35:30,440
Then again, it goes up and

2557
01:35:30,440 --> 01:35:31,490
then again comes down

2558
01:35:31,490 --> 01:35:32,570
to the almost
minimum value.

2559
01:35:32,570 --> 01:35:34,490
If the suppression
time comes to this

2560
01:35:34,490 --> 01:35:36,530
low which is the
minimum value then

2561
01:35:36,530 --> 01:35:37,910
obviously the number
of duplicates

2562
01:35:37,910 --> 01:35:39,725
will start
increasing because

2563
01:35:39,725 --> 01:35:40,670
the node will not

2564
01:35:40,670 --> 01:35:41,750
have enough
suppression time

2565
01:35:41,750 --> 01:35:44,510
and all the nodes

2566
01:35:44,510 --> 01:35:45,710
will forward their
interests of data,

2567
01:35:45,710 --> 01:35:46,040
so that's

2568
01:35:46,040 --> 01:35:48,230
why the duplicate
account loss increase.

2569
01:35:48,230 --> 01:35:49,880
This is one of the
problems that we

2570
01:35:49,880 --> 01:35:51,365
are observing right now.

2571
01:35:51,365 --> 01:35:54,410
I also run another
experiment

2572
01:35:54,410 --> 01:35:56,705
with five megabytes
of file with

2573
01:35:56,705 --> 01:35:59,315
700 segments to see
how the behaviors

2574
01:35:59,315 --> 01:36:02,900
goes for the
longer period of

2575
01:36:02,900 --> 01:36:04,835
time and almost a

2576
01:36:04,835 --> 01:36:06,050
similar behavior
to observe.

2577
01:36:06,050 --> 01:36:07,940
It goes up and then comes

2578
01:36:07,940 --> 01:36:09,080
back down to the
very minimum

2579
01:36:09,080 --> 01:36:10,400
and then again goes up.

2580
01:36:10,400 --> 01:36:14,030
The operating range
is still not found,

2581
01:36:14,030 --> 01:36:15,350
so which means this is one

2582
01:36:15,350 --> 01:36:15,920
of the challenges that

2583
01:36:15,920 --> 01:36:17,150
we're facing right now.

2584
01:36:17,150 --> 01:36:20,945
This might be because
of several things,

2585
01:36:20,945 --> 01:36:22,940
the algorithm, it might
not be well tuned

2586
01:36:22,940 --> 01:36:23,840
or the parameters that

2587
01:36:23,840 --> 01:36:25,055
we are using right now.

2588
01:36:25,055 --> 01:36:26,975
I showed those constants

2589
01:36:26,975 --> 01:36:28,535
in the previous slides.

2590
01:36:28,535 --> 01:36:30,020
Some of them are
listed here,

2591
01:36:30,020 --> 01:36:32,675
so the smoothing_factor,
adative_decrease.

2592
01:36:32,675 --> 01:36:35,780
How you decrease the
suppression time

2593
01:36:35,780 --> 01:36:37,475
once the goal is reached,

2594
01:36:37,475 --> 01:36:39,170
what is the number
that you use?

2595
01:36:39,170 --> 01:36:39,620
Similarly,

2596
01:36:39,620 --> 01:36:40,880
the
multiplicative_increase

2597
01:36:40,880 --> 01:36:42,710
is also another number.

2598
01:36:42,710 --> 01:36:44,870
What is the factor
that you use

2599
01:36:44,870 --> 01:36:46,280
to increase the
suppression time?

2600
01:36:46,280 --> 01:36:48,650
These are the
parameters that

2601
01:36:48,650 --> 01:36:50,525
still requires tuning,

2602
01:36:50,525 --> 01:36:54,110
so these factors plus
the algorithm might be

2603
01:36:54,110 --> 01:36:57,140
affecting this not finding

2604
01:36:57,140 --> 01:37:00,000
optimal range but we
are working on it.

2605
01:37:00,100 --> 01:37:04,310
That's why these constants

2606
01:37:04,310 --> 01:37:05,735
need to be carefully
chosen and

2607
01:37:05,735 --> 01:37:07,490
based on the network
it might be different,

2608
01:37:07,490 --> 01:37:10,260
so you need to
properly tune them.

2609
01:37:10,360 --> 01:37:12,680
In conclusion,
in this work,

2610
01:37:12,680 --> 01:37:13,520
we designed and
implemented

2611
01:37:13,520 --> 01:37:15,410
an adaptive duplicate
suppression for

2612
01:37:15,410 --> 01:37:18,575
multicasting and a
multi-access NDN network.

2613
01:37:18,575 --> 01:37:19,400
We also performed

2614
01:37:19,400 --> 01:37:20,705
some experiments
to demonstrate

2615
01:37:20,705 --> 01:37:24,095
how our implementation
is working.

2616
01:37:24,095 --> 01:37:25,895
In future,

2617
01:37:25,895 --> 01:37:27,605
we want to work on
the challenges that I

2618
01:37:27,605 --> 01:37:29,990
showed in the
previous slide and

2619
01:37:29,990 --> 01:37:31,010
especially on tuning the

2620
01:37:31,010 --> 01:37:32,555
algorithm and
the constants.

2621
01:37:32,555 --> 01:37:35,030
We also want to perform
more experiments with

2622
01:37:35,030 --> 01:37:35,960
various scenarios and

2623
01:37:35,960 --> 01:37:37,670
network size
and conditions.

2624
01:37:37,670 --> 01:37:38,390
Also,

2625
01:37:38,390 --> 01:37:40,175
compare the other
metrics such as delays.

2626
01:37:40,175 --> 01:37:41,630
Delays will also be one

2627
01:37:41,630 --> 01:37:43,115
of the interesting
numbers to show,

2628
01:37:43,115 --> 01:37:44,900
because it will show how

2629
01:37:44,900 --> 01:37:46,490
the suppression
is affecting

2630
01:37:46,490 --> 01:37:48,290
the delay in the network,

2631
01:37:48,290 --> 01:37:51,200
like the content
fetching delay.

2632
01:37:51,200 --> 01:37:53,180
It might be a little
bit increasing

2633
01:37:53,180 --> 01:37:55,800
or decreasing or we
have to see that.

2634
01:37:56,560 --> 01:37:58,760
We're also looking at
the possibility of

2635
01:37:58,760 --> 01:38:00,740
using machine learning to

2636
01:38:00,740 --> 01:38:02,270
determine the suppression
time and also

2637
01:38:02,270 --> 01:38:04,790
tune the constants
that I showed earlier.

2638
01:38:04,790 --> 01:38:07,460
Some of those areas

2639
01:38:07,460 --> 01:38:08,510
we're actively looking in

2640
01:38:08,510 --> 01:38:10,425
the future for
our future work.

2641
01:38:10,425 --> 01:38:12,295
These are the references.

2642
01:38:12,295 --> 01:38:13,975
Thank you and please

2643
01:38:13,975 --> 01:38:16,160
let me know if you
have any questions.

2644
01:38:16,660 --> 01:38:19,640
>> Thank you,
sir. I appreciate

2645
01:38:19,640 --> 01:38:21,125
you ending on time.

2646
01:38:21,125 --> 01:38:22,970
There's a discussion
going on,

2647
01:38:22,970 --> 01:38:24,605
on Slack about
what happens

2648
01:38:24,605 --> 01:38:26,135
if you drop an interest.

2649
01:38:26,135 --> 01:38:29,390
You may join in and
answer the question.

2650
01:38:29,390 --> 01:38:31,880
This was the last
presentation for the panel,

2651
01:38:31,880 --> 01:38:33,575
so I think we've
reached the end.

2652
01:38:33,575 --> 01:38:36,215
Thank you to all the
presenters and Lotfi,

2653
01:38:36,215 --> 01:38:38,390
passing this on to you.

2654
01:38:38,390 --> 01:38:40,100
>> Thank you, Christos

2655
01:38:40,100 --> 01:38:42,200
and all the presenters.

2656
01:38:42,200 --> 01:38:47,030
This concludes the
NDN Com 2021 program.

2657
01:38:47,030 --> 01:38:48,680
I hope it was a good

2658
01:38:48,680 --> 01:38:50,885
learning experience
for everyone.

2659
01:38:50,885 --> 01:38:52,460
I think the banners were

2660
01:38:52,460 --> 01:38:54,680
great and for some

2661
01:38:54,680 --> 01:38:56,090
of the presentation
sessions,

2662
01:38:56,090 --> 01:38:57,350
I think we could
have done better

2663
01:38:57,350 --> 01:38:58,490
if we made sure

2664
01:38:58,490 --> 01:39:01,580
we had enough time for
Q&A and discussions.

2665
01:39:01,580 --> 01:39:05,210
Hopefully, we can improve
on this next time.

2666
01:39:05,210 --> 01:39:07,640
Also, it would be
good if we can

2667
01:39:07,640 --> 01:39:09,830
summarize the main
actionable items from

2668
01:39:09,830 --> 01:39:11,750
this meeting that we think

2669
01:39:11,750 --> 01:39:14,675
the community should
consider going forward.

2670
01:39:14,675 --> 01:39:17,330
We would reach out
to some of you,

2671
01:39:17,330 --> 01:39:19,130
in particular,
panel chairs

2672
01:39:19,130 --> 01:39:22,275
to see how much
can be done there.

2673
01:39:22,275 --> 01:39:25,120
One last thing on Slack,

2674
01:39:25,120 --> 01:39:27,699
there were questions
about the availability

2675
01:39:27,699 --> 01:39:31,150
of the video recordings
and the slides.

2676
01:39:31,150 --> 01:39:33,700
The recording should
be available on

2677
01:39:33,700 --> 01:39:36,265
the event page
in 1-2 weeks,

2678
01:39:36,265 --> 01:39:38,650
and the slides will
also be made available

2679
01:39:38,650 --> 01:39:41,785
once we confirm with
the presenters.

2680
01:39:41,785 --> 01:39:44,365
With that and on behalf

2681
01:39:44,365 --> 01:39:46,630
of NDN Com co-chairs,

2682
01:39:46,630 --> 01:39:48,865
thanks again to all
the presenters,

2683
01:39:48,865 --> 01:39:52,180
panelists and moderators
and session chairs

2684
01:39:52,180 --> 01:39:55,580
and everyone
have a good rest

2685
01:39:55,580 --> 01:39:59,040
of your day. Bye

2686
01:40:00,310 --> 01:40:02,645
>> Last one for
the audience,

2687
01:40:02,645 --> 01:40:04,460
I'd like to say
that really

2688
01:40:04,460 --> 01:40:07,325
appreciates your
great work Lotfi,

2689
01:40:07,325 --> 01:40:09,680
for making this
NDN Com such a

2690
01:40:09,680 --> 01:40:12,365
great success. Thank you.

2691
01:40:12,365 --> 01:40:13,430
>> You're welcome.

2692
01:40:13,430 --> 01:40:15,930
>> For all your co-chairs.

2693
01:40:16,900 --> 01:40:20,705
>> Great. Thank you
everyone, again.

2694
01:40:20,705 --> 01:40:25,710
See you-all in the
next round of NDN Com.